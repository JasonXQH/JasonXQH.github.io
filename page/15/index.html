<!DOCTYPE html>
<html lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jasonxqh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/15/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jasonxqh.github.io/page/15/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jason‘s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason‘s Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/03/19/Java%E5%9F%BA%E7%A1%803/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/19/Java%E5%9F%BA%E7%A1%803/" class="post-title-link" itemprop="url">Java基础3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-19 00:27:30" itemprop="dateCreated datePublished" datetime="2021-03-19T00:27:30+08:00">2021-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-22 11:12:54" itemprop="dateModified" datetime="2022-08-22T11:12:54+08:00">2022-08-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java基础3"><a href="#Java基础3" class="headerlink" title="Java基础3"></a>Java基础3</h1><h2 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h2><h3 id="What-are-Exceptions"><a href="#What-are-Exceptions" class="headerlink" title="What are Exceptions"></a>What are Exceptions</h3><p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/5.png" style="zoom:67%;"></p>
<p>当我们调用一个将字符串变成大写的函数、传入的却是一个空指针。运行后Java就会给我们一个报错： “name is null“ 。</p>
<p>Java给我们的报错信息非常有用，因为他能帮我们将发生错误的每一句代码都列出，并且一直到最深处。</p>
<h3 id="Types-of-Exceptions"><a href="#Types-of-Exceptions" class="headerlink" title="Types of Exceptions"></a>Types of Exceptions</h3><h4 id="Checked-exception"><a href="#Checked-exception" class="headerlink" title="Checked exception"></a>Checked exception</h4><p>比如说我想读取一个文件，但是这个文件刚刚被删掉了，这时候就会报错。Java 强迫我们在写这类代码的时候一定要做检查，是否存在该文件。否则在编译 的时候就会报错</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/6.png" style="zoom:67%;"></p>
<p>当我们新建了一个FileReader对象、要打开一个 file.txt文件时，Java会提醒我们要为其添加一个 exception，否则连编译都过不了。包括接下来我们要学的线程中的 <code>sleep()、join()</code>函数。</p>
<h4 id="Unchecked-exception-Runtime-exception"><a href="#Unchecked-exception-Runtime-exception" class="headerlink" title="Unchecked exception/Runtime exception"></a>Unchecked exception/Runtime exception</h4><p>如同我们刚才讲的例子： <code>NullPointerException</code> 还有其他几种 <code>Runtime Exceptions</code> ，它们不会在编译前就报错。因此我们要养成良好的编程习惯以及积累经验来规避这些问题</p>
<ul>
<li>ArithmeticException</li>
<li>IllegalArgumentException</li>
<li>IndexOutOfBoundsException</li>
<li>IllegalStateException</li>
</ul>
<p>Checked 和 Unchecked Excption 主要区别在：</p>
<ul>
<li>Runtime exceptions:<ul>
<li>在定义方法时<strong>不需要声明</strong>会抛出runtime exception;</li>
<li>在调用这个方法时<strong>不需要捕获</strong>这个runtime exception;</li>
</ul>
</li>
</ul>
<p>runtime exception是从java.lang.RuntimeException或java.lang.Error类衍生出来的。</p>
<ul>
<li>Checked exceptions:<ul>
<li>定义方法时<strong>必须声明</strong>所有可能会抛出的checked exception;</li>
<li>在调用这个方法时，<strong>必须捕获</strong>它的checked exception，不然就得把它的exception传递下去;</li>
</ul>
</li>
</ul>
<p>从逻辑的角度来说，checked exceptions和runtime exception是有不同的使用目的的。checked exception用来指示一种调用方<strong>能够直接处理</strong>的异常情况。而runtime exception则用来指示一种<strong>调用方本身无法处理</strong>或恢复的程序错误</p>
<h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h4><p>第三种是我们束手无策的错误，比如写了个无限循环，或者是内存溢出了。我们必须规避这种低级错误。</p>
<h3 id="Exceptions-Hierarchy"><a href="#Exceptions-Hierarchy" class="headerlink" title="Exceptions Hierarchy"></a>Exceptions Hierarchy</h3><p>现在我们来看一下 Exception 的组织结构。首先，最上层的是 <code>Throwable Class</code> ,这个class中包含了<code>Exception class</code>和<code>Error</code>两个类。  Exception 类中又包括 <code>RuntimeException class</code> 也就是unchecked Exception</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/7.png" style="zoom:67%;"></p>
<h3 id="Catching-Exceptions"><a href="#Catching-Exceptions" class="headerlink" title="Catching Exceptions"></a>Catching Exceptions</h3><p>对于 checked exception, 我们可以用 <code>try-catch</code> 代码块来捕捉错误：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/9.png" style="zoom:67%;"></p>
<p>这样既可以打印 StackTrace来帮助我们找到错误，又可以让整个程序正常结束。最终，问题出在 Java.io库中的open0函数。</p>
<h3 id="Catching-Multiple-Types-of-Exceptions"><a href="#Catching-Multiple-Types-of-Exceptions" class="headerlink" title="Catching Multiple Types of Exceptions"></a>Catching Multiple Types of Exceptions</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader(<span class="string">"File.txt"</span>);</span><br><span class="line">            <span class="keyword">var</span> value = reader.read();</span><br><span class="line">            <span class="keyword">new</span> SimpleDateFormat().parse(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (FileNotFoundException | ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Could not read data"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们想要捕捉多个 Exception，我们可以使用多个 catch块。如果报错的信息是一样的，我们还可以用 或 运算符将它们放在一起。</p>
<p>注意，<code>IOException</code> 这个 catch block不能放到前面，否则会报错：因为IOException 包含了所有输入输出的错误，是一个“兜底“的类，如果将其放在第一个，就导致FileNotFoundException被IOException处在的代码块率先捕捉了。</p>
<h3 id="The-finally-Block"><a href="#The-finally-Block" class="headerlink" title="The finally Block"></a>The finally Block</h3><p>如果reader成功打开、我做好处理之后，想要把文件关掉，这时候应该怎么写？</p>
<p>我们应该把 <code>reader.close()</code>放在try代码块中吗？ 显然不行，因为如果try成功打开了文件，但在<code>var value = reader.read();</code>时抛出了一个错误，会直接跳到catch块，try后面的代码就不再被执行了。</p>
<p>我们应该直接把 <code>reader.close()</code>放在catch之后吗？ 貌似也不行。因为这样如果在未来我们在try-catch 和 close两者之间插入新的代码，并抛出新的错误的时候，reader还是不会被正常关闭。</p>
<p>因此，我们应该使用 finally block.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileReader reader = <span class="keyword">null</span>;<span class="comment">//一定要预设为null不然finally block不好做判断</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> FileReader(<span class="string">"File.txt"</span>);</span><br><span class="line">            <span class="keyword">var</span> value = reader.read();</span><br><span class="line">            <span class="keyword">new</span> SimpleDateFormat().parse(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Could not read data"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(reader!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>finally在try代码块正常被进入执行，jvm正常执行处理的情况下，是一定会被执行的。</strong> 如果在 try block中存在return；那么finally的执行时间是：retrun表达式执行之后，在return返回操作之前。</p>
<h3 id="The-try-with-resources-Statement"><a href="#The-try-with-resources-Statement" class="headerlink" title="The try-with-resources Statement"></a>The try-with-resources Statement</h3><p>但是像刚才那样写finally block 会比较丑。我们有更好的方法来实现： 就是将申明对象、打开文件都放到 try后面的括号当中，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader(<span class="string">"File.txt"</span>)) &#123;</span><br><span class="line">            <span class="keyword">var</span> value = reader.read();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Could not read data"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法叫做 <code>try-with-resources Statement</code>,这样一来，我们就不用显式地写 close() 了，jvm会自动帮我们生成和上面的finally block一样的代码。</p>
<p><a href="https://docs.oracle.com/en/java/javase/16/docs/api/index.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/index.html</a></p>
<p>在官方的文档中，我们可以找到AutoCloseable这个接口，这个接口下所有的子类都可以用这种<code>try-with-resources Statement</code>方法来自动关闭。比如说：FileReader、FileWriter这样的类。</p>
<h3 id="Throwing-Exceptions"><a href="#Throwing-Exceptions" class="headerlink" title="Throwing Exceptions"></a>Throwing Exceptions</h3><p>之前我们做的都是找到错误、抓住错误，但是现在我们要来主动抛出一个错误。</p>
<p>首先我们来讲 <code>defensive programming</code> ，也就是说遇到了错误，我们主动抛出并终结整个程序，如：</p>
<p> <img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/10.png" style="zoom:67%;"></p>
<p>我们新建了一个类，这里面会对value值进行一个判断，如果value小于0，就会抛出一个 <code>IllegalArgumentException()</code>错误，并结束整个程序。</p>
<p>如果我们的程序对value值得符号要求很高，如果输入不合法的值对整个程序的性能造成很大的影响(如库、框架等供多人使用的程序)，那么我们就应该适用这种 <code>defensive programming</code> 的方法，严格要求。</p>
<p>那么如果要throw一个 Checked Exception,该怎么写呢？比如说我在 Account 账户中抛出一个 IOException()这类异常，然后我必须在main函数中做一个 try-catch block 来接住这个exception</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/11.png" style="zoom:67%;"></p>
<p>注意了，在 Account 类中的 desposit 函数如果要抛出一个 <code>IOException</code>的话，必须在函数声明后面标明：<code>throws IOException</code>来告诉调用方我这个方法可能会抛出一个异常，而你调用者需要接收。</p>
<h3 id="Re-throwing-Exceptions"><a href="#Re-throwing-Exceptions" class="headerlink" title="Re-throwing Exceptions"></a>Re-throwing Exceptions</h3><p>现在我们在 ExceptionDemo 中接收 Account 抛出来的信息，然后再main函数中调用 <code>ExceptionDemo.show()</code>， 如果我现在希望ExceptionDemo收到异常信息后能将 StackTrace 记录到日志，并让main函数向用户打印一个有好的信息，应该怎么办？</p>
<p>这时候，我们应该 Re-throwing ,也就是说在收到Account  发出的异常信号的时候，ExceptionsDemo再向它的调用方(也就是main) 抛出一个错误，类似于一个接力的效果。然后在main中用<code>try-catch</code> 接收信号并打印一些信息：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/12.png" style="zoom:67%;"></p>
<h3 id="Custom-Exceptions"><a href="#Custom-Exceptions" class="headerlink" title="Custom Exceptions"></a>Custom Exceptions</h3><p>Java已经为我们提供了很多基础异常类了，但是有些时候我们还是需要为我们的项目客制化一些异常。</p>
<p>比如说刚才那个例子，我在Account 中设立一个 withdraw(取钱的函数)，方法逻辑是：如果要取出的钱大于账户余额，那么就抛出一个异常。但这时用java提供的标准异常也不太贴切，因此我们可以自定义一个异常。</p>
<p>首先我们要创建一个自定义的异常类，异常类要以 <code>Exception</code>作为结尾，要有辨识度。然后我们要决定这个异常类是属于 <code>checked exception</code> (继承Exception类) 还是 <code>unchecked exception</code> (继承RuntimeException类)，然后</p>
<p>继承Exception 类之后，我们要自定义异常警告。因为 异常类是一个有参构造函数，因此我们还需要设置<code>super(&quot;异常信息&quot;)</code> 。这里我们也提供了两种构造函数，一种默认构造函数直接设置异常信息为 Insufficient funds in your account, 第二种则是让调用者自定义报错信息的有参构造函数。</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/13.png" style="zoom:67%;"></p>
<h3 id="Chaining-Exceptions"><a href="#Chaining-Exceptions" class="headerlink" title="Chaining Exceptions"></a>Chaining Exceptions</h3><p>Chaining Exception 就是将一个更广泛的异常包裹一个比较具体的异常。那刚才的例子来说，我们有一个比较具体的异常： <code>InsufficientFundsException()</code> 但是造成取钱失败的异常还可能有很多种，因此我们可以创建一个更加广泛地异常类 <code>AccountException()</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.exceptions;</span><br><span class="line"><span class="comment">//这里我super中传入的是一个异常的原因，比如 InsufficientFundsException 这个异常类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountException</span><span class="params">(Exception cause)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 Account 类当中，当取款大于余额的时候，我们会向上抛出一个 AccountException类，并在这个类中传入原因：InsufficientFundsException，告诉调用者这是因为余额不够导致的账户异常。这就是 chain exception</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">float</span> value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">float</span> value)</span> <span class="keyword">throws</span> AccountException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value &gt; balance)</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> AccountException(<span class="keyword">new</span> InsufficientFundsException());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ExceptionsDemo类中,我们捕捉一个 AccountException类，然后通过 <code>e.getCause()</code> 获取AccountException中的异常类型并通过<code>getMessage()</code>打印出改原因的异常信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> account = <span class="keyword">new</span> Account();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            account.withdraw(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AccountException e) &#123;</span><br><span class="line">            <span class="keyword">var</span> cause = e.getCause();</span><br><span class="line">            System.out.println(cause.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h2><p>泛型就是参数化类型</p>
<ul>
<li>适用于多种数据类型执行相同的代码</li>
<li>泛型中的类型在使用时指定</li>
<li>泛型归根到底就是C++中的“模版”</li>
</ul>
<h3 id="The-Need-for-Generics"><a href="#The-Need-for-Generics" class="headerlink" title="The Need for Generics"></a>The Need for Generics</h3><p>比如我创建了一个 <code>List()</code> 类，如下：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/14.png"></p>
<p>那么如果我想创建一个 User 类的List，就要创建一个新的 UserList 类，久而久之，类就变得很繁杂。这时候我们就需要用到泛型了。</p>
<h3 id="A-Poor-Solution"><a href="#A-Poor-Solution" class="headerlink" title="A Poor Solution"></a>A Poor Solution</h3><p>遇到这种情况，使用 <code>Object Class</code> 是一种下策。因为虽然 所有的类都继承自Object类，但是有很多缺点</p>
<ol>
<li>比如我向Object List中存放了很多的元素(如Integer.valueOf(1)), 现在我想通过get 取出 List当中的第一个元素，但是这时候返回的类型是 Object,要得到int类型的返回结果我们必须进行强制类型转换，否则就会造成报错。</li>
<li>此外，List的管理会变得比较混乱，我们会搞不清楚 List中到底存储着什么类型的数据。</li>
</ol>
<h3 id="Generic-Classes"><a href="#Generic-Classes" class="headerlink" title="Generic Classes"></a>Generic Classes</h3><p>我们新创建一个 <code>GenericList</code> 类，需要在尖括号中一般使用 E或者T 来代表种类。</p>
<p>这里我们声明一个 类型为 T 的数组，因为我们没有办法直接 <code>new T[10]</code>，因为我们不知道传进来的是 int还是string，没办法实例化。这里我们必须创建一个 Object数组然后将其用强制类型转换变成 T 类型。</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/15.png"></p>
<p>然后 我们在main函数就可以声明各种类型的 list了,注意在声明的时候要传入数据类型，而且调用get()方法的时候也不用进行强制类型转换了。</p>
<h3 id="Generics-and-Primitive-Types"><a href="#Generics-and-Primitive-Types" class="headerlink" title="Generics and Primitive Types"></a>Generics and Primitive Types</h3><p>在声明泛型类实例的时候，我们不能穿入 Primitive Types，即 int, boolean，float 之类</p>
<p>如果我们要将这些类型的数据存入到泛型类实例当中，我们就必须要使用到 <strong>Wrapper class</strong></p>
<p>Java中每一个  <strong>Primitive Type</strong> 都有一个对应的 <strong>Wrapper class</strong>(包装类)</p>
<ul>
<li>int -&gt; Integer</li>
<li>float -&gt; Float</li>
<li>boolean -&gt; Boolean</li>
</ul>
<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><p>如果我们只想让我们的泛型存储数值类型的数据，那么我们可以让 <code>&lt;T extends Number&gt;</code> </p>
<p>所有的包装类<strong>（Integer、Long、Byte、Double、Float、Short）</strong>都是抽象类 Number 的子类。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">包装类</th>
<th style="text-align:left">基本数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">boolean</td>
</tr>
<tr>
<td style="text-align:left">Byte</td>
<td style="text-align:left">byte</td>
</tr>
<tr>
<td style="text-align:left">Short</td>
<td style="text-align:left">short</td>
</tr>
<tr>
<td style="text-align:left">Integer</td>
<td style="text-align:left">int</td>
</tr>
<tr>
<td style="text-align:left">Long</td>
<td style="text-align:left">long</td>
</tr>
<tr>
<td style="text-align:left">Float</td>
<td style="text-align:left">float</td>
</tr>
<tr>
<td style="text-align:left">Double</td>
<td style="text-align:left">Double</td>
</tr>
</tbody>
</table>
</div>
<p>这时候，我再创建一个 String 类型的泛型实例就会报错了。</p>
<p>除了<code>extends Number</code> 之外，我们还可以 <code>extends Comparable</code> ,也就是只能使用可比较的数据类型： String, Integer等，但是如果我们直接传入 User，就会报错，因为我们自己申明的User类暂时是不能比较的。</p>
<p>要想 User能够比较，我们还需要在声明 User 类的时候让其 implements Comparable,如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(User o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意了，这里要在 Comparable后面用尖括号写上User,然后让Idea自动生成一个 <code>compareTo</code> 的重写函数，这样重写函数中的参数就是User，否则就是Object，而Object范围太广，不太安全。</p>
<p>还可以是 extends Cloneable,是另外一个很有用的接口。比如:<code>&lt;T extends Comparable &amp; Cloneable &gt;</code> </p>
<h3 id="Type-Erasure"><a href="#Type-Erasure" class="headerlink" title="Type Erasure"></a>Type Erasure</h3><p>现在我们在底层看看泛型是怎么实现的。</p>
<p> 我们首先看看没有限制条件的 Generics 的 Bytecode:</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/16.png"></p>
<p>我们发现在ByteCode里面，我们声明的T类型的数组都变成了 Object数组。 也就是说和我们一开始自己写的Object数组是一样的，那么泛型和Object数组的区别在哪里呢？</p>
<p>在于编译的时候Java会帮助我们检查数据类型是否正确，而自己写的Object数组则不会判断，我们可以传入数字也可以是实例化的对象。因此，泛型更便于我们对数据进行管理。 </p>
<p>当我们对泛型做出限定的时候，如 Comparable、Number， ByteCode中数据类型也会从Object变为Number、Comparable等。</p>
<h3 id="Comparable-Interface"><a href="#Comparable-Interface" class="headerlink" title="Comparable Interface"></a>Comparable Interface</h3><p><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Comparable.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Comparable.html</a></p>
<p>我们上面说了，可以通过 User implements Comparable来把User类变成可比较的类,注意了，这里我们要传入比较的数据类型，否则Java会默认是两个Object在做比较。</p>
<p>如下面这段代码，我们在User里面创建一个points的变量，然后对其进行比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.generics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> points;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> points)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.points = points;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(User other)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this &lt; o -&gt; -1</span></span><br><span class="line">        <span class="comment">// this == o -&gt; 0</span></span><br><span class="line">        <span class="comment">// this &gt; o -&gt; 1</span></span><br><span class="line">        <span class="keyword">return</span> points- other.points;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main函数中，我们就可以对两个User实例进行比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> com.company.generics.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> user1 = <span class="keyword">new</span> User(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">var</span> user2 = <span class="keyword">new</span> User(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">if</span>(user1.compareTo(user2)&lt;<span class="number">0</span>)</span><br><span class="line">            System.out.println(<span class="string">"user1&lt;user2"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(user1.compareTo(user2)==<span class="number">0</span>)</span><br><span class="line">            System.out.println(<span class="string">"user1==user2"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"user1&gt;user2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Generic-Methods"><a href="#Generic-Methods" class="headerlink" title="Generic Methods"></a>Generic Methods</h3><p>除了泛型类，还有泛型方法。 在使用限定词的时候，类是 implements， 而方法则是 extends</p>
<p>比如我创建一个 Utils 类，里面有一个max方法，用来返回两个对象中较大的那一个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.generics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">T <span class="title">max</span><span class="params">(T first ,T second)</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (first.compareTo(second)&gt;<span class="number">0</span> )? first:second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数定义时，需要在尖括号中写 <code>&lt;T extends Comparable&lt;T&gt;&gt;</code> 返回数据类型也为T，然后利用<code>compareTo</code> 函数来比较二者的大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    User max_user = Utils.max(<span class="keyword">new</span> User(<span class="number">10</span>),<span class="keyword">new</span> User(<span class="number">20</span>));</span><br><span class="line">    System.out.println(max_user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果输出的却是这样的结果：<code>com.company.generics.User@3f99bd52</code></p>
<p>是因为返回的对象调用 toString()函数，因此输出了一个hashcode，要解决这个问题，我们需要在 编写 User类的时候重写 <code>toString()</code> 函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> points;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> points)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.points = points;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(User other)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this &lt; o -&gt; -1</span></span><br><span class="line">        <span class="comment">// this == o -&gt; 0</span></span><br><span class="line">        <span class="comment">// this &gt; o -&gt; 1</span></span><br><span class="line">        <span class="keyword">return</span> points- other.points;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"points="</span> + points +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行得到： <code>User{points=20}</code> </p>
<h3 id="Multiple-Type-Parameters"><a href="#Multiple-Type-Parameters" class="headerlink" title="Multiple Type Parameters"></a>Multiple Type Parameters</h3><p>不管是泛型类还是泛型方法都可以传入多种不同类型的参数，我们各给出一个例子：</p>
<p><strong>泛型类</strong></p>
<p>这里我们创建了一个 键值对的类，K 代表key的数据类型，V代表value的数据类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.generics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.Key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyValuePair</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KeyValuePair</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，对于方法我们也可以使用多个类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T key,V value)</span></span>&#123;</span><br><span class="line">    System.out.println(key + <span class="string">"="</span>+ value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Generic-Classes-and-Inheritance"><a href="#Generic-Classes-and-Inheritance" class="headerlink" title="Generic Classes and Inheritance"></a>Generic Classes and Inheritance</h3><p>当我们用一个类来继承泛型类的时候，关系可如下图所示：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/17.png"></p>
<p>也就是说Integer继承了Number，在一般的实例中，Number 是可以接收 Interger类型的参数的；但是在泛型类的实例中 如<code>Box&lt;Number&gt;</code>  只能接收数据类型为Number的数据，不接受 <code>Box&lt;Integer&gt;</code> 和 <code>Box&lt;Double&gt;</code>的参数。</p>
<p>所以说在泛型类中，虽然传入的类之间存在继承关系，但是他们的泛型类是不存在继承关系的。原因在于它们都继承自Object类型，但是二者相互独立。</p>
<p>我们用刚才的例子看一下：</p>
<p>首先我们创建一个 <code>Instructor</code> 类，并让其继承自<code>User</code> 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.generics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instructor</span> <span class="keyword">extends</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Instructor</span><span class="params">(<span class="keyword">int</span> points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(points);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在Utils中声明两个方法，一个是普通的 <code>printUser</code>方法，另一个则是接收 <code>GenericList&lt;User&gt;</code> 的<code>printUsers</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printUsers</span><span class="params">(GenericList&lt;User&gt; users)</span></span>&#123;</span><br><span class="line">    System.out.println(users.get(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果在 main 函数当中，可以用printUser来打印一个 Instructor实例，但是不能用 printUsers来打印一个 <code>GenericList&lt;Instructor&gt;</code> 实例：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/18.png"></p>
<p>为了解决这个问题，我们可以用Wildcards(术语叫通配符，其实就类似于扑克中的万能牌)</p>
<h3 id="Wildcards"><a href="#Wildcards" class="headerlink" title="Wildcards"></a>Wildcards</h3><p>我们可以将 printUsers方法这样写：问号就是通配符，代表着一个unknown的数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printUsers</span><span class="params">(GenericList&lt;?&gt; users)</span></span>&#123;</span><br><span class="line">    System.out.println(users.get(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样虽然解决了问题，但是这样一来，我们可以向 <code>printUsers</code>传入任何数据类型，比如Integer，String等，把他们当做Users打印出来显然是不行的。因此在使用通配符之后还需要加上限定条件</p>
<h4 id="extends"><a href="#extends" class="headerlink" title="? + extends"></a>? + extends</h4><p>当我们使用了通配符 ？之后，相当于java创建了一个我们看不见的 类叫做 <code>CAP#1</code> 用来存放未知的数据类型。 因为可能有多个通配符，所以CAP后面的编号也不同。</p>
<p>如果我们用 <code>?+extends User</code> 的话，就相当于 Class CAP#1 继承了User，而 Instructor 也是继承User的，因此这时候可以向printUsers传入 User以及它的子类，而不能传入 Integer、String这种数据类型了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printUsers</span><span class="params">(GenericList&lt;? extends User&gt; users)</span></span>&#123;</span><br><span class="line">    User x = users.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如这里我们可以用 User来接收get函数的返回值，因为User是 Cap#1的父类，但是不能用Instructor来接收，因为Instructor和Cap#1是”兄弟“关系，是独立的两个类。</p>
<p>但是，我们不能在这里使用 <code>add()</code>函数。因为CAP#1是个抽象概念，我们没有办法实例化一个CAP#1对象并将其加到Users当中去。</p>
<p>因此如果选择 <code>?+extends</code> 对象是只读不可写的</p>
<h4 id="super"><a href="#super" class="headerlink" title="? + super"></a>? + super</h4><p>super和extends则是刚好相反。只可写不可读</p>
<p>在使用了super关键词后，？相当于 User类的父类，也就是 Object Class</p>
<p>因此<code>GenericList&lt;? super User&gt; users</code> 之后,Java会把users看做是：<code>GenericList&lt;Object&gt; temp</code> 这个对象</p>
<p>这时候我们调用 add方法，因为添加的对象都是Object的子类，因此不会报错。然而我们却无法使用get方法了，因为这时候get的返回类型为Object，但是Java并不知道你用什么类型来接收。很可能两种数据类型是不兼容的，因此不能使用：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/19.png"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>总结：</th>
<th>可读</th>
<th>可写</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>?+extends</strong></td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td><strong>?+super</strong></td>
<td>×</td>
<td>√</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>提到集合就不得不提一下数组，好多集合底层都是依赖于数组的实现。数组一旦初始化后，长度就确定了，存储数据对象不能达到动态扩展，其次数组存储元素不便于对数组进行<code>添加</code>、<code>修改</code>、<code>删除操作</code>，而且数组可以存储重复元素。这个时候集合对作用显现出来了。集合分为<code>Collection</code>和<code>Map</code>两种体系。Collection的集合类的继承树如下图所示：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/21.png"></p>
<p>化简可得：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/22.png"></p>
<p>Collection 接口有 3 种子类型集合: <code>List</code>、<code>Set</code> 和 <code>Queue</code>，再下面是一些抽象类，最后是具体实现类。常用的有 <code>ArrayList</code>用来当数组用，<code>LinkedList</code>即链表；在<code>Queue</code>下常用的是<code>PriorityQueue</code>,即优先队列；在<code>Set</code>下常用 <code>Hashset</code> 用来做哈希映射。</p>
<p>简单的来说，Java中的collection类似于C++中的stl，有多种封装好的数据结构。</p>
<h3 id="The-Iterable-Interface"><a href="#The-Iterable-Interface" class="headerlink" title="The Iterable Interface"></a>The Iterable Interface</h3><p>下面是 Iterable的官方文档：</p>
<p><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Iterable.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Iterable.html</a></p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/23.png"></p>
<p>在这个接口中一共有三个函数，我们要重写iterator()这个函数，因为这个函数会返回一个迭代器对象。迭代器的数据类型取决于泛型对象的数据类型</p>
<p>当一个类继承了 Iterable之后，他就可以被迭代了。这里，我们先用自建的代码来模拟 ArratList 。这里我虽然重写了Iterator但是没有写任何代码，只是为了做个演示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T[] items = (T[])<span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main函数中，我们用iterator来接收迭代器，这里返回的是一个String 类型的迭代器。</p>
<p>iterator中两个内置方法很重要，一个是 hasNext()， 也就是用来判断是否存在下一个元素；还有一个是next()即让迭代器指向下一个元素。使用while循环，可以遍历对象中的所有元素。(虽然hasNext()和next()我暂时还没有重写)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> list = <span class="keyword">new</span> GenericList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">var</span> iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="keyword">var</span> current = iterator.next();</span><br><span class="line">        System.out.println(current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，while循环可以这样来简化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> item : list)&#123;</span><br><span class="line">     	System.out.println(item);</span><br><span class="line">   	&#125;</span><br></pre></td></tr></table></figure>
<p>在底层的bytecode都是一样的。</p>
<p>使用了Iterable接口，我们就没有必要在GenericList类中将 <code>private T[] items</code>设置成 <code>public T[] items</code>，照样可以迭代。</p>
<h3 id="The-Iterator-Interface"><a href="#The-Iterator-Interface" class="headerlink" title="The Iterator Interface"></a>The Iterator Interface</h3><p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/24.png"></p>
<p>现在我们继续实现我们自建的 GenericList，刚才只是说了我们可以实现什么功能，但并没有将方法都写出来。</p>
<p>首先我们要在 <code>GenericList</code>中创建一个新的类，叫做<code>ListIterator</code>, 这个类讲接入 <code>Iterator</code>接口并重写 <code>hasNext()</code>、<code>next()</code> 两个函数。并让<code>GenericList</code>中的 <code>iterator</code>方法的返回一个 <code>ListIterator</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] items = (T[]) <span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        items[count++] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//返回一个ListIterator实例，并将自身(GenericList)当做参数传入。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListIterator(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ListIterator 类是定义在Generic 里面的，因此能访问到私有变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">private</span> GenericList&lt;T&gt; list;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"><span class="comment">//定义 ListIterator的有参构造函数，传入参数类型为 GenericList&lt;T&gt;</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ListIterator</span><span class="params">(GenericList&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.list = list;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//重写 hasNext()函数</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (index &lt; list.count);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//重写next函数，返回list中的下一个元素</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> list.items[index++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，一个建议的ArrayList就做完了，我们可以测试一下让其遍历输出：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/25.png"></p>
<h3 id="The-Collection-Interface"><a href="#The-Collection-Interface" class="headerlink" title="The Collection Interface"></a>The Collection Interface</h3><p>学会了ArrayList原理之后，我们正式来讲讲 Collection 接口, 这是官方文档</p>
<p><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Collection.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Collection.html</a></p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/26.png"></p>
<p>在文档中，我们看到，Collection实现了 <code>Iterable&lt;E&gt;</code> 接口，这说明 collection中的子接口以及子类都是可以迭代的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">         Collection&lt;String&gt; collection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         collection.add(<span class="string">"a"</span>);</span><br><span class="line">         collection.add(<span class="string">"b"</span>);</span><br><span class="line">         collection.add(<span class="string">"c"</span>);</span><br><span class="line">         Collections.addAll(collection,<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>);</span><br><span class="line"></span><br><span class="line">         collection.remove(<span class="string">"a"</span>);</span><br><span class="line">         System.out.println(collection);</span><br><span class="line">         System.out.println(collection.size());</span><br><span class="line"></span><br><span class="line">         <span class="keyword">var</span> objectArray = collection.toArray();</span><br><span class="line">         <span class="keyword">var</span> stringArray = collection.toArray(<span class="keyword">new</span> String[<span class="number">5</span>]);</span><br><span class="line">         System.out.println(objectArray);</span><br><span class="line">         System.out.println(stringArray);</span><br><span class="line"></span><br><span class="line">         Collection&lt;String&gt; other = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         other.addAll(collection);</span><br><span class="line"></span><br><span class="line">         System.out.println(collection.contains(<span class="string">"a"</span>));</span><br><span class="line">         collection.clear();</span><br><span class="line">         System.out.println(collection.isEmpty());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是要注意了， collection是不支持通过索引访问的，即我们不能使用中括号或者 <code>add(index,element)</code>这种方法来添加元素的。</p>
<h3 id="The-List-Interface"><a href="#The-List-Interface" class="headerlink" title="The List Interface"></a>The List Interface</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//List 同样也有 add 操作，但是list可以通过index来决定插入的位置</span></span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        list.add(<span class="string">"b"</span>);</span><br><span class="line">        list.add(<span class="string">"c"</span>);</span><br><span class="line">        list.add(<span class="number">0</span>,<span class="string">"!"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"><span class="comment">// 打印得到： [!, a, b, c]， 同样也有 addAll 方法。</span></span><br><span class="line">        Collections.addAll(list,<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>);</span><br><span class="line"><span class="comment">// set 是替换的方法，这里我们将 list中的第一个元素(!)替换成 "a+"</span></span><br><span class="line">        list.set(<span class="number">0</span>,<span class="string">"a+"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"><span class="comment">//打印得到：[a+, a, b, c, d, e, f]</span></span><br><span class="line"><span class="comment">//删除第一个元素</span></span><br><span class="line">      	list.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"><span class="comment">//打印得到：[a, b, c, d, e, f]</span></span><br><span class="line">      	</span><br><span class="line">      <span class="comment">//打印出元素的"b"的位置，打印得： 1 </span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">"b"</span>));</span><br><span class="line">      <span class="comment">//打印出元素"ss"的位置，打印得： -1 因为ss并不在list中</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">"ss"</span>));</span><br><span class="line">			<span class="comment">// 打印出list的子列表，即[a,b],因为不包括list[2]</span></span><br><span class="line">        System.out.println(list.subList(<span class="number">0</span>,<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="The-Comparable-Interface"><a href="#The-Comparable-Interface" class="headerlink" title="The Comparable Interface"></a>The Comparable Interface</h3><p>在泛型那章已经讲过 Comparable Interface了，一般来说我们自定义的类如果要实现Comparable接口的话，一般需要重写 compareTo 和 toString 两个方法，如下面这个比较字符串的 Customer类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Customer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Customer other)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this &lt; other -&gt; -1</span></span><br><span class="line">        <span class="comment">// this == other -&gt; 0</span></span><br><span class="line">        <span class="comment">// this &gt; other -&gt; 1</span></span><br><span class="line">        <span class="keyword">return</span> name.compareTo(other.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="The-Comparator-Interface"><a href="#The-Comparator-Interface" class="headerlink" title="The Comparator Interface"></a>The Comparator Interface</h3><p>现在我们虽然实现了 Customer的排名，但实现起来却比较的麻烦，需要在类内实现。这时Comparator这个接口就可以在类外实现对象的比较。</p>
<p><strong>简单来说，Comparable就是定义一个单独的对象比较器，继承自Comparator接口，实现compare（）方法</strong></p>
<p>比如现在 Customer 中多了一个 Email 参数，然后我们就新建一个 <code>EmailComparator</code>类如下：</p>
<p>在这个类中我们重写 compare方法并按照email进行排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Customer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Customer o1, Customer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getEmail().compareTo(o2.getEmail());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在main函数中我们对Customer数组进行一个排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Customer&gt; customers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    customers.add(<span class="keyword">new</span> Customer(<span class="string">"b"</span>, <span class="string">"e3"</span>));</span><br><span class="line">    customers.add(<span class="keyword">new</span> Customer(<span class="string">"a"</span>, <span class="string">"e2"</span>));</span><br><span class="line">    customers.add(<span class="keyword">new</span> Customer(<span class="string">"c"</span>, <span class="string">"e1"</span>));</span><br><span class="line">  <span class="comment">//在调用sort的时候，将比较器放在第二个参数上</span></span><br><span class="line">    Collections.sort(customers,<span class="keyword">new</span> EmailComparator()); </span><br><span class="line">  	System.out.println(customers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印得到 [c, a, b]，说明确实是按照email进行排列的</p>
<h3 id="The-Queue-Interface"><a href="#The-Queue-Interface" class="headerlink" title="The Queue Interface"></a>The Queue Interface</h3><p>现在我们来讲 队列接口，这是<code>Queue&lt;E&gt;</code> 的文档：</p>
<p><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Queue.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Queue.html</a></p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/27.png"></p>
<p>我们看到在 Queue接口下比较常用的就是 ArrayDeque(先进先出)、LinkedList(即继承自Queue又继承自List)、PriorityQueue等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue  = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">  <span class="comment">//和list一样，queue也有add函数，但是加到队列的末尾</span></span><br><span class="line">  	queue.add(<span class="string">"c"</span>);</span><br><span class="line">    queue.add(<span class="string">"a"</span>);</span><br><span class="line">    queue.add(<span class="string">"b"</span>);</span><br><span class="line">  <span class="comment">// peek()就是获取队列的第一个元素</span></span><br><span class="line">    <span class="keyword">var</span> front = queue.peek();</span><br><span class="line">    System.out.println(front);<span class="comment">// c</span></span><br><span class="line">    System.out.println(queue);<span class="comment">// [c, a, b]</span></span><br><span class="line">    <span class="keyword">var</span> remove = queue.remove();<span class="comment">// 删除第一个元素</span></span><br><span class="line">    System.out.println(remove);<span class="comment">// c</span></span><br><span class="line">    System.out.println(queue);<span class="comment">// [a, b]</span></span><br><span class="line">		<span class="comment">//poll()和remove()都是删除队列第一个元素</span></span><br><span class="line">  	<span class="comment">//他们的唯一区别就是当队列为空时，poll返回null而remove会抛出异常</span></span><br><span class="line">  	System.out.println(queue.poll());<span class="comment">// a</span></span><br><span class="line">    queue.poll();</span><br><span class="line">    System.out.println(queue.poll());<span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="The-Set-Interface"><a href="#The-Set-Interface" class="headerlink" title="The Set Interface"></a>The Set Interface</h3><p><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Set.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Set.html</a></p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/28.png"></p>
<p>和C++一样，Set 是不包含重复的元素的. 如果把一个ArrayList放到Set当中，也会将其变成一个不重复的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;String&gt; collection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Collections.addAll(collection, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"c"</span>);</span><br><span class="line">    Set&lt;String&gt; set =  <span class="keyword">new</span> HashSet&lt;&gt;(collection);</span><br><span class="line">    System.out.println(set);<span class="comment">//[a, b, c]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在来介绍一些Set中的方法</p>
<p>set其实就是一个集合，数学上集合的操作在Java中都有对应的方法。</p>
<p>比如 <strong>并</strong>，就可以用 <code>addAll()</code> 方法求得</p>
<p><strong>交</strong>，可以用 <code>retainAll()</code>方法求得</p>
<p>A-B, 可以用 <code>removeAll()</code>方法求得</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>));</span><br><span class="line">  Set&lt;String&gt; set2 = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">"d"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Union</span></span><br><span class="line">  set1.addAll(set2);</span><br><span class="line">  System.out.println(set1);<span class="comment">//[a, b, c, d]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//复原</span></span><br><span class="line">  set1 = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>));</span><br><span class="line">  <span class="comment">// Intersection</span></span><br><span class="line">  set1.retainAll(set2);</span><br><span class="line">  System.out.println(set1);<span class="comment">//[b, c]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//复原</span></span><br><span class="line">  set1 = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>));</span><br><span class="line">  <span class="comment">//Difference</span></span><br><span class="line">  set1.removeAll(set2);</span><br><span class="line">  System.out.println(set1);<span class="comment">//[a]</span></span><br></pre></td></tr></table></figure>
<h3 id="The-Map-Interface"><a href="#The-Map-Interface" class="headerlink" title="The Map Interface"></a>The Map Interface</h3><p> 在Java和C++中，哈希表可以用 Map接口来实现，在C#、python中，可以用Dictionary(词典)来实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 = <span class="keyword">new</span> Customer(<span class="string">"a"</span>,<span class="string">"e1"</span>);</span><br><span class="line"><span class="keyword">var</span> c2 = <span class="keyword">new</span> Customer(<span class="string">"b"</span>,<span class="string">"e2"</span>);</span><br><span class="line"><span class="keyword">var</span> unknown = <span class="keyword">new</span> Customer(<span class="string">"Unknown"</span>,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">Map&lt;String,Customer&gt;map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(c1.getEmail(),c1);<span class="comment">// email作为key，而Customer对象作为value</span></span><br><span class="line">map.put(c2.getEmail(),c2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> customer = map.get(<span class="string">"e1"</span>);</span><br><span class="line">System.out.println(customer);<span class="comment">//a</span></span><br><span class="line"></span><br><span class="line">customer = map.get(<span class="string">"e10"</span>);<span class="comment">//如果按一个不存在的key去找，会返回10</span></span><br><span class="line">System.out.println(customer);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//找到就返回e10配对的对象，否则就返回unknown</span></span><br><span class="line">customer = map.getOrDefault(<span class="string">"e10"</span>,unknown);</span><br><span class="line">System.out.println(customer);<span class="comment">//Unknown</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> exists = map.containsKey(<span class="string">"e10"</span>);</span><br><span class="line">System.out.println(exists);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">map.replace(<span class="string">"e1"</span>,<span class="keyword">new</span> Customer(<span class="string">"a++"</span>,<span class="string">"e1"</span>));</span><br><span class="line">System.out.println(map);<span class="comment">//&#123;e1=a++, e2=b&#125;</span></span><br></pre></td></tr></table></figure>
<p>但是注意了，map是不能够被迭代的，因此我们没用办法用for each loop来直接遍历map，但是我们有其他的方法：</p>
<p>我们可以使用map内置的 entrySet方法来获得每一组键值对</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：e1=a++  e2=b</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出值 ：a++  b</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出索引 key： e1  e2</span></span><br></pre></td></tr></table></figure>
<p>当然，也可以使用<code>map.values()</code>直接获得value</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (customer : map.values()) &#123;</span><br><span class="line">   	System.out.println(customer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Lambda-Expressions"><a href="#Lambda-Expressions" class="headerlink" title="Lambda Expressions"></a>Lambda Expressions</h2><h3 id="Functional-Interfaces"><a href="#Functional-Interfaces" class="headerlink" title="Functional Interfaces"></a>Functional Interfaces</h3><p>函数式接口，是指内部只有<strong>一个</strong>抽象方法的接口。注意，只能有一个，并且是抽象的方法</p>
<p>比如说我声明一个 <code>Printer</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后用一个<code>ConsolePrinter</code>类来实现这个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsolePrinter</span> <span class="keyword">implements</span> <span class="title">Printer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在LambdasDemo类中将实例传入到参数为接口的greet()方法中，完成打印。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        greet(<span class="keyword">new</span> ConsolePrinter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">(Printer printer)</span></span>&#123;</span><br><span class="line">        printer.print(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这与我们之前<a href="https://jasonxqh.github.io/2020/07/05/Java基础2/">Java基础2</a>中关于接口的操作思路一样，但是有时候我们并不想创建这样一个功能如此特殊的类来实现接口，因为用一次以后可能再也不会使用了。因此接下来我们要来介绍匿名内部类。</p>
<h3 id="Anonymous-Inner-Classes"><a href="#Anonymous-Inner-Classes" class="headerlink" title="Anonymous Inner Classes"></a>Anonymous Inner Classes</h3><p>匿名内部类就是没有名字的、方法内部的类，通常用来简化代码的编写。</p>
<p>匿名内部类的使用场景： 我们只使用一次接口并用来实现某些特殊的功能的时候</p>
<p>匿名类是不能有名称的类，所以没办法引用它们。必须在创建时，作为new语句的一部分来声明它们。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        greet(<span class="keyword">new</span> Printer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">                System.out.println(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">(Printer printer)</span></span>&#123;</span><br><span class="line">        printer.print(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名内部类，虽然已经方便了许多。但是更好的方法是使用 <code>Lambda Expression</code></p>
<h3 id="Lambda-Expressions-1"><a href="#Lambda-Expressions-1" class="headerlink" title="Lambda Expressions"></a>Lambda Expressions</h3><p>Lambda 表达式的作用就像是一个匿名内部类，但是又不属于类。比如说我们重写刚才的匿名内部类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    greet(message-&gt;&#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说使用 Lambda expression 可以代替一个类。在这里我们甚至不需要写 <code>message</code>的数据类型，因为当我们使用Lambda表达式的时候Java会根据调用它的方法(这里是<code>greet()</code>)找到对应的接口及其数据类型。</p>
<p>当我们只传入1个参数的时候，参数不需要用括号包裹。但是当我们传入0个或者多个参数的时候，需要使用小括号包裹。</p>
<p>如果这个Lambda Expression花括号中只含有一句代码，那么花括号也可以被省略，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">greet(message -&gt; System.out.println(message))</span><br></pre></td></tr></table></figure>
<h3 id="Variable-Capture"><a href="#Variable-Capture" class="headerlink" title="Variable Capture"></a>Variable Capture</h3><p>如果我们使用一个匿名内部类，我们可以在类内新建一些变量，但是在 <code>Lambda Expression</code> 中，是不能新建变量的。但是可以使用当前方法中定义的变量，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void show()&#123;</span><br><span class="line">    String prefix &#x3D; &quot;-&quot;;</span><br><span class="line"></span><br><span class="line">    greet((message)-&gt;&#123;</span><br><span class="line">        System.out.println(prefix+message);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可使用当前类中定义的静态变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String prefix = <span class="string">"-"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        greet((message)-&gt;&#123;</span><br><span class="line">            System.out.println(prefix+message);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">(Printer printer)</span></span>&#123;</span><br><span class="line">        printer.print(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 当然，如果要使用非静态变量的话，需要将 show()方法也定义成非静态的。</p>
<h3 id="Method-References"><a href="#Method-References" class="headerlink" title="Method References"></a>Method References</h3><p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/42.png"></p>
<p>方法引用一共有四种，目的是用来简化Lambda表达式的。一般引用格式是： 类名+静态方法名，要求是引用的静态方法跟 Lambda表达式是客观等价的(参数值、参数类型、返回值一致)</p>
<p>比如说刚才的例子中 ，<code>println</code>方法就和Lambda表达式是客观等价的，因此我们可以直接简化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">       greet(System.out::println);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>当然，我们也可以在类中自定义一个静态函数然后实现函数引用：</p>
<p>在这里我们定义了静态函数 <code>LambdaDemo</code> 并在 greet中引用了它</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String message)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        greet(LambdasDemo::print);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">(Printer printer)</span></span>&#123;</span><br><span class="line">        printer.print(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上图，第四种方法就是引用一个构造函数。可以使用 <code>类+new</code> 的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LambdasDemo</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        greet(LambdasDemo::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">(Printer printer)</span></span>&#123;</span><br><span class="line">        printer.print(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Built-in-Functional-Interfaces"><a href="#Built-in-Functional-Interfaces" class="headerlink" title="Built-in Functional Interfaces"></a>Built-in Functional Interfaces</h3><p>文档：<a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/package-summary.html</a></p>
<p>Java提供了四种内建的函数式接口：Consumer、Supplier、 Function、Predicate</p>
<p>Consumer接口的意思是它值接收一个参数，且不返回任何东西。就好像把一个值给消费掉了。</p>
<p>Supplier接口的意思是它并不接收任何参数，但返回一个值，就好像它在提供一个值。</p>
<p>Function接口的意思是它会把一个值映射到另一个值上， <code>obj map(obj)</code></p>
<p>Predicate接口的意思是判断一个对象是否符合某个条件，<code>bool test(condition)</code></p>
<p>现在我们来一一介绍四种接口</p>
<h3 id="The-Consumer-Interface"><a href="#The-Consumer-Interface" class="headerlink" title="The Consumer Interface"></a>The Consumer Interface</h3><p>文档：<a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/Consumer.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/Consumer.html</a></p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/43.png"></p>
<p>此外这个接口还有几个变形，比如 <code>BiConsumer</code>也就是接收两个参数但是不返回任何值</p>
<p>这里我们引用一个例子：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/44.png"></p>
<p>List集合中的 <code>forEach()</code>方法就实现了一个 Consumer接口，因此我们要传入一个值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>这就是Declarative Programming, 也就是说这句命令做了些啥。</p>
<h3 id="Chaining-Consumer"><a href="#Chaining-Consumer" class="headerlink" title="Chaining Consumer"></a>Chaining Consumer</h3><p>现在我们来说说 链式的Consumer，在这里我们定义了两个lambda函数分别实现 Consumer接口：一个是打印原来的元素，另一个打印大写后的元素。</p>
<p>然后我们使用forEach方法的时候，先调用print，在print后调用内建的 addThen,又可以调用一个 Consumer对象.可以一直这样调用下去，比如：<code>list.forEach(print.andThen(printUpperCase).andThen(print));</code></p>
<p>调用顺序是：对于每一个元素，前调用print方法，然后调用printUpperCase方法，即先打印小写字母再打印大写祖母</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/45.png"></p>
<p>我们查看Consumer的源码就能看出原理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现这个函数的返回值也是一个 Consumer的对象，当一个Consumer调用<code>andThen</code>，它先执行前面的对象，再调用after执行后面的对象，这样就会使我们的传入的两个Consumer对象按照顺序执行。</p>
<h3 id="The-Supplier-Interface"><a href="#The-Supplier-Interface" class="headerlink" title="The Supplier Interface"></a>The Supplier Interface</h3><p>文档：<a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/Consumer.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/Consumer.html</a></p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/46.png"></p>
<p>这个接口只有一个方法，即<code>get</code> </p>
<p>这里我们创建了一个 <code>getRandom</code> 的 Lambda 表达式，用来随机生成一个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Supplier&lt;Double&gt; getRandom = () -&gt; Math.random();</span><br><span class="line">        <span class="keyword">var</span> random = getRandom.get();</span><br><span class="line">        System.out.println(random);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边要注意的是，如果我们不调用 <code>getRandom.get()</code>，这个Lambda 表达式是不会执行的。这叫做：Lazy evaluation. </p>
<p>和Consumer接口一样，Supplier接口也有多种变形： <code>DoubleSupplier</code>，<code>BooleanSupplier</code>,<code>IntSupplier</code>等，这些接口只能返回特定类型的数据。</p>
<h3 id="The-Function-Interface"><a href="#The-Function-Interface" class="headerlink" title="The Function Interface"></a>The Function Interface</h3><p>文档：<a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/Function.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/Function.html</a></p>
<p>基本模板：<code>Interface Function&lt;T,R&gt;</code></p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/47.png"></p>
<p>这个接口需要设置两个数据类型 T和R.文档中这么解释: </p>
<p><code>T</code> - the type of the input to the function </p>
<p><code>R</code> - the type of the result of the function</p>
<p>当然还有 Function 接口的变形如 <code>BiFunction&lt;T,U,R&gt;</code>，也就是设置三个数据类型，两个接收的和一个返回的：</p>
<p><code>T</code> - the type of the first argument to the function</p>
<p><code>U</code> - the type of the second argument to the function</p>
<p><code>R</code> - the type of the result of the function</p>
<p>还有像 <code>IntFunction&lt;R&gt;</code>这种接口，因为它已经规定了<strong>接收值得数据类型</strong>为int，因此只要确定返回值类型 R即可；和<code>IntFunction&lt;R&gt;</code>相对的是 <code>ToIntFunction&lt;T&gt;</code>接口，它规定了<strong>返回值的数据类型</strong>为int，因此我们要确定其接收值得数据类型T</p>
<p>这里我们创建了 一个 Lambda函数map，其作用就是接收一个String类型的字符串并返回Integer类型的该字符串的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Function&lt;String,Integer&gt; map = str-&gt;str.length();</span><br><span class="line">        <span class="keyword">var</span> length = map.apply(<span class="string">"Sky"</span>);</span><br><span class="line">        System.out.println(length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Composing-Functions"><a href="#Composing-Functions" class="headerlink" title="Composing Functions"></a>Composing Functions</h3><p>因为 Function接口也有 <code>andThen()</code>方法,所以我们也可以链式使用 Function接口。</p>
<p>这里我们 同样定义了两个 lambda函数，第一个是将字符串中的’:’替换成’-‘。第二个是在字符串外面添加花括号。</p>
<p>我们有两种方式实现链式Function</p>
<p>我认为第一种更加直观：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Function&lt;String,String&gt; replaceColon = str -&gt; str.replace(<span class="string">":"</span>,<span class="string">"-"</span>);</span><br><span class="line">        Function&lt;String,String&gt; addBraces = str -&gt; <span class="string">"&#123;"</span>+str+<span class="string">"&#125;"</span> ;</span><br><span class="line">        <span class="keyword">var</span> result = replaceColon</span><br><span class="line">                .andThen(addBraces)</span><br><span class="line">                .apply(<span class="string">"key:value"</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = addBraces.compose(replaceColon).apply(<span class="string">"Key:Value"</span>);</span><br></pre></td></tr></table></figure>
<p>打印后得到： {key-value}</p>
<h3 id="The-Predicate-Interface"><a href="#The-Predicate-Interface" class="headerlink" title="The Predicate Interface"></a>The Predicate Interface</h3><p><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/Predicate.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/Predicate.html</a></p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/48.png"></p>
<p>我们使用这个接口来筛选数据。最重要的就是这个 <code>test()</code>方法，它会判断t是否符合某些条件。</p>
<p>此外还有 <code>BiPredicate&lt;T,U&gt;</code>，用来检测传入的两个参数是否符合某些条件；<code>IntPredicate</code> 它只接受Integer类型的数据并返回一个布尔值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Predicate&lt;String&gt; isLongerThan5 = str -&gt; str.length() &gt;<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">var</span> result = isLongerThan5.test(<span class="string">"sky"</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们设计了一个Lambda函数用来判断输入的String类型的字符串的长度是否大于5. </p>
<p>打印得到 false</p>
<h3 id="Combining-Predicates"><a href="#Combining-Predicates" class="headerlink" title="Combining Predicates"></a>Combining Predicates</h3><p>将 Predicates结合起来又有些不太一样，因为这些都是条件。因此我们可以将两个条件通过 <code>and()</code>,<code>or()</code> 变成一个新的 Predicate，比如说：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Predicate&lt;String&gt; hasLeftBrace = str-&gt;str.startsWith(<span class="string">"&#123;"</span>);</span><br><span class="line">        Predicate&lt;String&gt; hasRightBrace = str-&gt;str.endsWith(<span class="string">"&#125;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> hasBothBrace =hasLeftBrace.and(hasRightBrace);</span><br><span class="line">        <span class="keyword">var</span> eitherOneBrace = hasLeftBrace.or(hasRightBrace);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个方法，叫做 <code>negate()</code>，也就是将条件取反变成新的条件，如 <code>hasLeftBrace.negate()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(hasBothBrace.test(<span class="string">"&#123;sss"</span>));		<span class="comment">// false</span></span><br><span class="line">System.out.println(eitherOneBrace.test(<span class="string">"&#123;sss"</span>));	<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="The-BinaryOperator-Interface"><a href="#The-BinaryOperator-Interface" class="headerlink" title="The BinaryOperator Interface"></a>The BinaryOperator Interface</h3><p>现在我们来介绍一种特殊的函数式接口： <code>BinaryOperator&lt;T&gt;</code></p>
<p><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/BinaryOperator.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/BinaryOperator.html</a></p>
<p>这个接口是一个特殊的 BiFunction()接口，即接受两个参数，并返回一个值，这三个值得类型都必须相同。</p>
<p>比如说这里我们定义一个 BinaryOperator的函数为add，作用是将两个Integer类型的整数相加。我们还可以利用 <code>andThen()</code>将BinaryOperator和Function两个类型的函数复合起来，求两数之和的平方数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// a,b -&gt; a+b -&gt; square</span></span><br><span class="line">        BinaryOperator&lt;Integer&gt; add = (a,b)-&gt;a+b;</span><br><span class="line">        Function&lt;Integer,Integer&gt; square = a-&gt;a*a;</span><br><span class="line">        <span class="keyword">var</span> result = add.andThen(square).apply(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">      <span class="comment">//结果为9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="The-UnaryOperator-Interface"><a href="#The-UnaryOperator-Interface" class="headerlink" title="The UnaryOperator Interface"></a>The UnaryOperator Interface</h3><p><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/UnaryOperator.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/UnaryOperator.html</a></p>
<p><code>UnaryOperator&lt;T&gt;</code>接口是一种特殊的 Function()接口，即接受一个参数并返回一个值，但它们的类型必须相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        UnaryOperator&lt;Integer&gt; square = n-&gt;n*n;</span><br><span class="line">        UnaryOperator&lt;Integer&gt; increment = n-&gt;n+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> result = increment.andThen(square).apply(<span class="number">1</span>);</span><br><span class="line">        System.out.println(result);<span class="comment">//打印的4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们新建了两个 <code>UnaryOperator</code> 对象，一个用来+1，一个用来求平方，使用<code>andThen()</code>将它们复合</p>
<h2 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h2><p>Java8 引入了 Stream，这可以让你以一种声明的方式处理数据。也就是说，Stream使用了一种类似用SQL 语句从数据库查询数据的直观方式来提供一种对Java集合(collection)运算的表达的高阶抽象。这可以让我们写出高效率的、干净、简洁的代码。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; transactionsIds = </span><br><span class="line">widgets.stream()</span><br><span class="line">             .filter(b -&gt; b.getColor() == RED)</span><br><span class="line">             .sorted((x,y) -&gt; x.getWeight() - y.getWeight())</span><br><span class="line">             .mapToInt(Widget::getWeight)</span><br><span class="line">             .sum();</span><br></pre></td></tr></table></figure>
<h3 id="Imperative-vs-Functional-Programming"><a href="#Imperative-vs-Functional-Programming" class="headerlink" title="Imperative vs Functional Programming"></a>Imperative vs Functional Programming</h3><p>首先我们来看命令式编程和函数式编程之间的区别。</p>
<p>下面给出 Imperative Code的例子：我们看到命令式编程完全就是一步一步执行下去的，仿佛就是我们在对计算机下命令。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Movie&gt; movies = List.of(</span><br><span class="line">            <span class="keyword">new</span> Movie(<span class="string">"a"</span>,<span class="number">10</span>),</span><br><span class="line">            <span class="keyword">new</span> Movie(<span class="string">"b"</span>,<span class="number">15</span>),</span><br><span class="line">            <span class="keyword">new</span> Movie(<span class="string">"c"</span>,<span class="number">20</span>)</span><br><span class="line">    ); </span><br><span class="line">    <span class="comment">// Imperative Programming</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> movie : movies)</span><br><span class="line">        <span class="keyword">if</span>(movie.getLikes()&gt;<span class="number">10</span>)</span><br><span class="line">            count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们用函数式编程来重写上面这段命令式编程的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count2 = movies.stream()</span><br><span class="line">        .filter(movie -&gt; movie.getLikes()&gt;<span class="number">10</span>)</span><br><span class="line">        .count();</span><br></pre></td></tr></table></figure>
<p>命令式编程更像是我们告诉电脑应该怎么做:循环，判断；而stream则是直接show出来它做了什么：filter+count</p>
<p>它就好比是对Collection中的元素流通过管道，并在管道中进行筛选、分流、聚合等操作，最终得到我们想要的结果。</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/29.png"></p>
<h3 id="Creating-a-Stream"><a href="#Creating-a-Stream" class="headerlink" title="Creating a Stream"></a>Creating a Stream</h3><p>我们可以从这几处来创建流：</p>
<ul>
<li>From collections</li>
<li>From arrays</li>
<li>From an arbitrary number of objects</li>
<li>Infinite/ finite streams</li>
</ul>
<p>Stream 提供了新的方法 ‘forEach’ 来迭代流中的每个数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//从数组中创建流</span></span><br><span class="line">    <span class="keyword">int</span> [] numbers = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    Arrays.stream(numbers)</span><br><span class="line">            .forEach(n -&gt; System.out.println(n));</span><br><span class="line">	<span class="comment">//从随机数中创建流</span></span><br><span class="line">    <span class="keyword">var</span> stream = Stream.generate(()-&gt;Math.random());</span><br><span class="line">    stream</span><br><span class="line">            .limit(<span class="number">3</span>)<span class="comment">//这里如果不做限制，会有无限多个随机数产生</span></span><br><span class="line">            .forEach(n -&gt; System.out.println(n));</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mapping-Elements"><a href="#Mapping-Elements" class="headerlink" title="Mapping Elements"></a>Mapping Elements</h3><p>map 方法用于映射每个元素到对应的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Movie&gt; movies = List.of(</span><br><span class="line">            <span class="keyword">new</span> Movie(<span class="string">"a"</span>,<span class="number">10</span>),</span><br><span class="line">            <span class="keyword">new</span> Movie(<span class="string">"b"</span>,<span class="number">15</span>),</span><br><span class="line">            <span class="keyword">new</span> Movie(<span class="string">"c"</span>,<span class="number">20</span>)</span><br><span class="line">    );</span><br><span class="line">  <span class="comment">//最基础的就是map方法，他获取movies中的每个元素并取得他们的标题，然后输出</span></span><br><span class="line">   movies.stream()</span><br><span class="line">           .map(movie -&gt; movie.getTitle())</span><br><span class="line">           .forEach(name-&gt; System.out.println(name));</span><br><span class="line">  <span class="comment">//mapToInt则是将得到的数据全部转换为 int 类型的数据,同样还有mapToDouble</span></span><br><span class="line">   movies.stream()</span><br><span class="line">           .mapToInt(movie -&gt; movie.getLikes())</span><br><span class="line">           .forEach(likes -&gt; System.out.println(likes));</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外还有<code>flatmap()</code>方法，The <code>flatMap()</code> operation has the effect of applying a one-to-many transformation to the elements of the stream, and then flattening the resulting elements into a new stream.</p>
<p>首先我们用 <code>of()</code>创建一个含有两个 List 集合的流，然后让其打印元素。</p>
<p>然后我们让其调用<code>flatMap</code>,让 传入的List集合扁平化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stream = Stream.of(List.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),List.of(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">stream.forEach(list -&gt; System.out.println(list));</span><br><span class="line"><span class="comment">/* 打印得</span></span><br><span class="line"><span class="comment">[1, 2, 3]</span></span><br><span class="line"><span class="comment">[4, 5, 6]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">stream</span><br><span class="line">       	  .flatMap(list -&gt; list.stream())</span><br><span class="line">    	    .forEach(n -&gt; System.out.println(n));</span><br><span class="line"><span class="comment">/* 打印得</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//注意，如果我们调用的是map(),那么打印出来的是这个流对象，而不是流中的元素：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.stream.ReferencePipeline$Head@3a71f4dd</span></span><br><span class="line"><span class="comment">java.util.stream.ReferencePipeline$Head@7adf9f5f</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="Filtering-Elements"><a href="#Filtering-Elements" class="headerlink" title="Filtering Elements"></a>Filtering Elements</h3><p>filter 方法用于通过设置的条件过滤出元素, 这里我们要分清 stream的两种类型的操作：Intermediate Operation 以及 Terminal Operation</p>
<p>Intermediate Operation 就是 <code>map()、filter()</code> 之类的操作，它们会继续返回一个stream供我们后续操作</p>
<p>Terminal Operation 的例子就是 <code>forEach()</code>，它会直接在终端输出结果</p>
<p>如果只使用 Intermidiate Operation那么终端中什么都不会输出。为了使filter更加利于理解，我们可以将筛选条件单独定义成一个变量，如下面这个例子：</p>
<p>注：<code>Predicate &lt;T&gt;</code> 接口是一个函数式接口，它接受一个输入参数，然后返回一个布尔值结果。该接口用于测试对象是 true 或 false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> movies = List.of(</span><br><span class="line">                <span class="keyword">new</span> Movie(<span class="string">"a"</span>,<span class="number">10</span>),</span><br><span class="line">                <span class="keyword">new</span> Movie(<span class="string">"b"</span>,<span class="number">15</span>),</span><br><span class="line">                <span class="keyword">new</span> Movie(<span class="string">"c"</span>,<span class="number">20</span>)</span><br><span class="line">        );</span><br><span class="line"> <span class="comment">// m 是一个参数传递到Predicate 接口的 test 方法</span></span><br><span class="line"> <span class="comment">// 如果 m.getLikes()&gt;10,那么就会返回 true</span></span><br><span class="line">        Predicate&lt;Movie&gt; isPopular = m -&gt; m.getLikes() &gt; <span class="number">10</span>;</span><br><span class="line">        movies.stream()</span><br><span class="line">                .filter(isPopular)</span><br><span class="line">                .forEach(movie -&gt; System.out.println(movie.getTitle()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Slicing-Streams"><a href="#Slicing-Streams" class="headerlink" title="Slicing Streams"></a>Slicing Streams</h3><p> slicing stream是一个大类别，包含了 <code>limit(n)</code>、<code>skip(n)</code>、<code>takeWhile(predicate)</code>、<code>dropWhile(predicate)</code> 这些方法</p>
<h4 id="limit-n"><a href="#limit-n" class="headerlink" title="limit(n)"></a>limit(n)</h4><p>顾名思义，就是只限制 n 条数据，如下：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/49.png"></p>
<h4 id="skip-n"><a href="#skip-n" class="headerlink" title="skip(n)"></a>skip(n)</h4><p>顾名思义，就是跳过前n条数据。</p>
<p>假设现在有1000条电影数据，每10条一页，我想看第三页的数据，应该怎么编写代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movies.stream()</span><br><span class="line">			.skip(<span class="number">20</span>)</span><br><span class="line">			.limit(<span class="number">10</span>)</span><br><span class="line">			.forEach(m -&gt; System.out.println(m.getTitle()));</span><br></pre></td></tr></table></figure>
<h4 id="takeWhile-predicate"><a href="#takeWhile-predicate" class="headerlink" title="takeWhile(predicate)"></a>takeWhile(predicate)</h4><p>这个方法传入一个实现了 predicate接口的 lambda表达式，用来筛选满足条件的数据。但是注意了，这个和filter是不一样的。filter是筛选所有满足条件的数据，而takeWhile()方法则是一碰到不符合条件的数据就立即停止。</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/50.png"></p>
<p>上面的例子中，虽然第三条数据的 likes&lt;15,但是 takeWhile()在遇到第二条数据的时候就已经停止了筛选。</p>
<h4 id="dropWhile-predicate"><a href="#dropWhile-predicate" class="headerlink" title="dropWhile(predicate)"></a>dropWhile(predicate)</h4><p>dropWhile则和takeWhile恰好相反。就是去除掉那些符合条件的数据，直到遇到第一条不满足条件的数据为止。比如说刚才一模一样的代码，将takeWhile改成dropWhile，就会打印 b和c，因为会把a去除掉，而遇到b的时候就停止筛选了</p>
<h3 id="Sorting-Streams"><a href="#Sorting-Streams" class="headerlink" title="Sorting Streams"></a>Sorting Streams</h3><p>我们之前介绍了 <code>Comparable</code>和<code>Comparator</code>接口，是用来对对象进行排序的方法。</p>
<p>现在在stream中我们可以简化写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movies.stream()</span><br><span class="line">        .sorted((a,b)-&gt;a.getTitle().compareTo(b.getTitle()))<span class="comment">//原来我们这么写</span></span><br><span class="line">        .sorted(Comparator.comparing(Movie::getTitle))<span class="comment">//现在我们可以这么写</span></span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>如果我们要倒序排列，那么：<code>.sorted(Comparator.comparing(Movie::getTitle).reversed())</code>即可</p>
<h3 id="Getting-Unique-Elements"><a href="#Getting-Unique-Elements" class="headerlink" title="Getting Unique Elements"></a>Getting Unique Elements</h3><p>我们可以通过 stream中的 <code>distinct()</code>方法来获得集合中非重复的数据，比如说：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/52.png"></p>
<h3 id="Peeking-Elements"><a href="#Peeking-Elements" class="headerlink" title="Peeking Elements"></a>Peeking Elements</h3><p>peek和map 有点相似，但是peek接收的是一个 Consumer，而map接受的是一个Function。</p>
<p>Consumer是没有返回值的，它只是对Stream中的元素进行某些操作，但是操作之后的数据并不返回到Stream中，所以Stream中的元素还是原来的元素。</p>
<p>而Function是有返回值的，这意味着对于Stream的元素的所有操作都会作为新的结果返回到Stream中。</p>
<p>我们常常用 <code>peek()</code>来debug我们的程序，因为它不会对Stream的元素作任何操作，又不是一个Terminal的操作会把Stream终止。</p>
<p>通过下面这个例子，我们能更深刻的理解 peek和map之间的差别了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> movies = List.of(</span><br><span class="line">                <span class="keyword">new</span> Movie(<span class="string">"a"</span>,<span class="number">10</span>),</span><br><span class="line">                <span class="keyword">new</span> Movie(<span class="string">"b"</span>,<span class="number">15</span>),</span><br><span class="line">                <span class="keyword">new</span> Movie(<span class="string">"c"</span>,<span class="number">20</span>)</span><br><span class="line">        );</span><br><span class="line">        movies.stream()</span><br><span class="line">                .filter(m-&gt;m.getLikes()&gt;<span class="number">10</span>)</span><br><span class="line">                .peek(m -&gt; System.out.println(<span class="string">"filtered: "</span>+m.getTitle()))</span><br><span class="line">                .map(m-&gt;m.getTitle())</span><br><span class="line">                .peek(t -&gt; System.out.println(<span class="string">"mapped: "</span>+t))</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始我们筛选出了集合中点赞数大于10的数据，这里是两个Movie对象b和c</p>
<p>然后我们通过peek对其进行了一个输出</p>
<p>之后我们通过map将对象映射成他们的名字了，因此现在stream中只有两个字符串 b和c</p>
<p>然后我们再通过peek对其进行输出，这时候我们直接打印t和上面那样调用 <code>getTitle()</code>的效果是一样的，因为map已经对流进行了映射。</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/53.png"></p>
<h3 id="Simple-Reducers"><a href="#Simple-Reducers" class="headerlink" title="Simple Reducers"></a>Simple Reducers</h3><p>刚才我们讲的一系列操作，目的是创建客制化的管道。接下来我们来讲Reducer，其目的就是将流中的元素直接变成一个对象。比如说<code>count()</code>，它直接返回集合中的元素数量；</p>
<p><code>anyMatch(predicate)</code>, 返回布尔值，只要含有符合条件的就返回true；</p>
<p><code>allMatch(predicate)</code>以及 <code>noneMatch(predicate)</code>，逻辑和 <code>anyMatch相同</code></p>
<p><code>findFirst()</code> 返回 <code>Optional</code> 类，本质上，这是一个包含有可选值的包装类，这意味着 Optional 类既可以含有对象也可以为空。我们可以通过<code>get()</code>获取Optional中的对象本体。findFirst也就是返回集合中的第一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> movies = List.of(</span><br><span class="line">            <span class="keyword">new</span> Movie(<span class="string">"a"</span>,<span class="number">10</span>),</span><br><span class="line">            <span class="keyword">new</span> Movie(<span class="string">"b"</span>,<span class="number">15</span>),</span><br><span class="line">            <span class="keyword">new</span> Movie(<span class="string">"c"</span>,<span class="number">20</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result= movies.stream()</span><br><span class="line">                                .findFirst()</span><br><span class="line">                                .get();</span><br><span class="line">    System.out.println(result.getTitle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>findAny()</code>和    <code>findFirst()</code>逻辑相同，只不过是返回任意一个集合中的对象。</p>
<p><code>max(comparator)</code> 这个方法需要接受一个 comparator 对象作为比较的依据. 用来返回拥有 最大参数的对象</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/54.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result= movies.stream()</span><br><span class="line">                  .max(Comparator.comparing(Movie::getLikes))</span><br><span class="line">                  .get();</span><br><span class="line">System.out.println(result.getTitle());</span><br></pre></td></tr></table></figure>
<p><code>min(comparator)</code>和max()的逻辑相同。</p>
<h3 id="Reducing-a-Stream"><a href="#Reducing-a-Stream" class="headerlink" title="Reducing a Stream"></a>Reducing a Stream</h3><h3 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h3><h3 id="Grouping-Elements"><a href="#Grouping-Elements" class="headerlink" title="Grouping Elements"></a>Grouping Elements</h3><h3 id="Partitioning-Elements"><a href="#Partitioning-Elements" class="headerlink" title="Partitioning Elements"></a>Partitioning Elements</h3><h3 id="Primitive-Type-Streams"><a href="#Primitive-Type-Streams" class="headerlink" title="Primitive Type Streams"></a>Primitive Type Streams</h3><h2 id="Concurrency-and-Multi-threading"><a href="#Concurrency-and-Multi-threading" class="headerlink" title="Concurrency and Multi-threading"></a>Concurrency and Multi-threading</h2><h3 id="Processes-and-Threads"><a href="#Processes-and-Threads" class="headerlink" title="Processes and Threads"></a>Processes and Threads</h3><p>我们在CSAPP中已经了解了进程和线程的关系。在一个进程中，一定有一个主线程，还可以有其他支线程。比如说我们在迅雷中一次下载了三个文件，那么这三个文件就可以占据三个线程。</p>
<p>现在我们来看一下关于这台电脑中关于线程的信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.activeCount());</span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一句是打印当前这个项目使用的进程数，下面一句打印当前电脑总的可用线程数。</p>
<p>因为 m1 是四大核四小盒，这里打印出来的是一共8个进程 。当我在 i7-9750(六核) 上运行时，打印得到12个线程。</p>
<h3 id="Starting-a-Thread"><a href="#Starting-a-Thread" class="headerlink" title="Starting a Thread"></a>Starting a Thread</h3><p>现在我们来讲怎么创建一个线程。要创建一个线程，我们首先要让一个类引入 Runnable 接口,并在其中重写 run函数。Runnable接口是Java.lang 中一个内置的接口。引入这个接口就代表着这个任务将被在一条线程中执行。这个接口中只有一个函数： <code>run()</code> , 当启动线程开始运作之后，会自动调用  <code>run()</code>函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadFileTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Downloading a file: "</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在 <code>ThreadDemo</code> 类中，将一个 <code>DownloadFileTask()</code> 实例传入，并调用 <code>start()</code>函数启动线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DownloadFileTask());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/1.png" style="zoom:120%;"></p>
<p>打印结果如上图所示：首先打印的是当前所在的线程，也就是 main，然后我们进行了一个循环，调用了十个新的线程，并依次打印出他们的名字。</p>
<h3 id="Pausing-a-Thread"><a href="#Pausing-a-Thread" class="headerlink" title="Pausing a Thread"></a>Pausing a Thread</h3><p>现在我们尝试将一个线程“挂起”一段时间以模仿下载的过程。</p>
<p>要让线程挂起，我们可以使用 <code>sleep()</code> 方法，这里我选择让线程挂起5秒钟(注意，5000是以毫秒为单位，但并不是非常精确的5000毫秒，这和底层操作系统有关系) </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadFileTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Downloading a file: "</span>+Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Download complete: "</span>+ Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我直接写 <code>Tread.sleep(5000)</code>，那么 idea会报错，我们需要用 try/catch 将其包裹起来。打印结果如下： </p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/2.png" style="zoom:120%;"></p>
<p>如果我们只有一个线程来下载这10个文件，那么就需要用50秒的时间，但是现在我们有10个线程，所以只需要5秒就能完成任务。</p>
<p>如果我们现在要下载成百上千的文件，但是我们电脑没有那么多线程。这时候，就要用到 JVM 中的 <code>Thread Scheduler</code>,这是用来决定 java中每条线程执行的时间。所以当任务量大于线程数的时候，JVM 会执行分时操作。也就是每一个线程都能分到一点时间，让我们用户看起来像是在并行下载。</p>
<h3 id="Joining-a-Thread"><a href="#Joining-a-Thread" class="headerlink" title="Joining a Thread"></a>Joining a Thread</h3><p><code>join()</code>方法是<code>Thread</code>类中的一个方法，该方法的定义是等待该线程终止。其实就是<code>join()</code>方法将挂起<strong>调用线程</strong>的执行，直到<strong>被调用的对象</strong>完成它的执行。</p>
<p>比如说，一开始我不使用 <code>join()</code>，这样，主线程就运行主进程自己的代码，只是开辟了一条线程运行其他的代码。因此我们看到打印出来的先是主线程的运行结果</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/3.png" style="zoom:120%;"></p>
<p>但是使用了 <code>join()</code>方法之后，主线程就会等待子线程结束后再运行。比如说：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/4.png" style="zoom:120%;"></p>
<h3 id="Interrupting-a-Thread"><a href="#Interrupting-a-Thread" class="headerlink" title="Interrupting a Thread"></a>Interrupting a Thread</h3><p>有时候我们必须要去终止一个运行中的线程，这时候就需要用到 <code>thread.interrupt()</code> 这个函数了。通常终止一个线程的逻辑是： 调用者发出一个interrupt信号，被调用的线程将对收到的信号做一个判断，如果是interrupt信号，就终止运行中的线程。否则就“充耳不闻”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadFileTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Downloading a file: "</span>+Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt; Integer.MAX_VALUE;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) <span class="keyword">return</span>;</span><br><span class="line">            System.out.println(<span class="string">"Downloading byte"</span>+ i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边我进行一个无限循环，然后判断主线程是否给我发送了一个 Interrupt信号，如果是就return掉，否则就继续打印。</p>
<p>注意了，如果线程正在挂起时向其发送 <code>interrupted</code> 信号，这样是会报错的。因此我们在用 <code>thread.sleep()</code> 的时候，需要用 <code>try-catch</code> 来包裹。</p>
<h3 id="Concurrency-Issues"><a href="#Concurrency-Issues" class="headerlink" title="Concurrency Issues"></a>Concurrency Issues</h3><p>在编写并行程序的时候会遇到一些问题：</p>
<ol>
<li>当很多不同的线程共用一个对象的时候，对对象的某些参数进行修改会导致“堵车”。这就好比三个人像同时吃掉一个汉堡。我们将这种情况叫做 “Race Condition”, </li>
<li>另一种情况就是，当一个线程对一个对象进行了修改，但是修改后的内容仅它自己可见，那么不同线程就会看到一个对象不同的状态。我们将这种情况叫做 ”Visibility Problem”</li>
</ol>
<p>我们必须要写出 <code>Thread-safe Code</code> 来规避这些问题。在很多Java的文档中，对一个类的描述是 <code>Thread Safe</code> 也就是这个类可以再很多并行的线程中使用。</p>
<h3 id="Race-Conditions"><a href="#Race-Conditions" class="headerlink" title="Race Conditions"></a>Race Conditions</h3><p>当很多线程都想修改一个对象的时候，就出现了竞争关系。</p>
<p>比如说我有以下代码：</p>
<p><code>ThreadDemo类</code></p>
<p>在这个调用的类当中，我们创建一个线程数组，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">var</span> status = <span class="keyword">new</span> DownloadStatus();</span><br><span class="line">       List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">var</span> thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DownloadFileTask(status));</span><br><span class="line">           thread.start();</span><br><span class="line">           threads.add(thread);</span><br><span class="line">       &#125;</span><br><span class="line">      <span class="comment">//将所有的线程都打开后，我们还需要等待所有的线程都停止。这里使用一个循环来解决。</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> thread : threads)&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               thread.join();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        System.out.println(status.getTotalBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DownloadFileTask</code>类</p>
<p>在这个Run函数当中，我们做一个10000次的循环，每一次循环都调用status对象的 <code>incrementTotalBytes()</code>函数。用来模拟下载一个 10000 bits的文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadFileTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DownloadStatus status;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownloadFileTask</span><span class="params">(DownloadStatus status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt; <span class="number">10_000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) <span class="keyword">return</span>;</span><br><span class="line">            status.incrementTotalBytes();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DownloadStatus</code>类</p>
<p>在这个类中，有一个下载总比特数的私有变量，当有线程中的对象调用<code>incrementTotalBytes()</code>的时候，totalBytes就会自增1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadStatus</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> totalBytes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotalBytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> totalBytes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementTotalBytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">        totalBytes++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在预期的情况下，我们打开了10 个线程，每个线程都会下载10_000比特的数据，那么<code>totalBytes</code>的结果应该是100_000, 但是我们多次运行之后，一直都是八九万，并没有到十万。这是因为发生了<code>Race condition</code>，线程在互相争抢修改同一个数据的时候，会发生数据丢失。</p>
<p>当我们调用 <code>incrementTotalBytes()</code> 的时候，电脑会从内存中找到totalBytes的值，然后存储至cpu，然后cpu对值进行加1操作；操作结束后，这个值会被重新存储至内存中。</p>
<p>那么现在假设两个线程同时读取了 <code>totalBytes</code>然后对其进行加1操作，这时候，CPU也只是会将<code>totalBytes</code>加上1而已，并不会加上2。这就是导致了刚才的数据丢失。</p>
<h3 id="Strategies-for-Thread-Safety"><a href="#Strategies-for-Thread-Safety" class="headerlink" title="Strategies for Thread Safety"></a>Strategies for Thread Safety</h3><p>我们有一些写出 <code>Thread Safe Code</code> 的策略：</p>
<ul>
<li>Confinement</li>
</ul>
<p>这个概念很简单，就是原本是多个线程操作一个对象，现在变成了每个线程都操作属于它自己的对象，最后将对象中的值加起来就得到最后的总值。</p>
<ul>
<li>Immutability</li>
</ul>
<p>这个操作更加直白，就是我们将要操作的对象变成不可改变的。比如说 String 对象就是 Immutable 的，因为当我们对一个 String 对象进行修改的时候会创建一个新的String，之前的String并不会遭改变</p>
<ul>
<li>Synchronization</li>
</ul>
<p>同步操作，这使得同一个对象在不同的线程之间可以协调、同步。我们可以利用<strong>lock</strong>以及<strong>Synchronize</strong>关键词来实现这个操作.</p>
<p>我们使用锁将”有争议的部分”锁起来，一次只能让一个线程来访问，这样就能做到隔离的效果。然而，这样很容易造成死锁，因此不推荐使用</p>
<ul>
<li>Atomic Object </li>
</ul>
<p>原子对象。之前 若要对<code>totalBytes</code> 进行修改需要进行3个步骤，但是当我们使用原子对象的时候，只需要一个步骤即可，这就防止两个线程同时操作一个对象的情况出现了。</p>
<ul>
<li>Partitioning  </li>
</ul>
<p>中文叫分区</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/20.png" style="zoom:120%;"></p>
<h3 id="Confinement"><a href="#Confinement" class="headerlink" title="Confinement"></a>Confinement</h3><p>现在我们重构刚才那段代码。之前发生Race condition的时候，我们只创建了一个 <code>DownloadStatus</code> 对象，十个线程都对一个 <code>totalBytes</code> 变量进行操作，因此它们开始争夺。</p>
<p>我们现在要做的就是“隔离”，简单来说就是给每一个thread都新建一个DownloadStatus，线程的操作只对它自己的DownloadStatus中的TotalBytes进行操作，最后将这十个 TotalBytes变量累加得到最后答案。</p>
<p>因为我们要对每一个线程新建一个下载任务，因此我们还要一个 列表来保存这些Tasks。并且我们不再需要向<code>DownloadFileTask</code> 构造器传入status参数了，因为我们要对每一个Task新建一个DownloadStatus对象 ,但是我们要在 <code>DownloadFileTask</code>类中为status做一个getter，方便外界获取当前的下载状态。</p>
<p> <img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/30.png" style="zoom:100%;"></p>
<p>现在我们重构 ThreadDemo 类，因为我们要为每一个线程单独设一个DownloadFileTask，因此为了方便将其中的TotalBytes相加，我们要新建一个List对其进行管理。并在创建的时候将每一个Task加入到数组当中去。最后我们用 Stream 将tasks数组中的所有任务中的totalbytes相加，得到最终结果。</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/31.png" style="zoom:100%;"></p>
<p>打印得： Optional[100000]，即10个线程的下载总和，一个Byte都没丢掉</p>
<h3 id="Locks"><a href="#Locks" class="headerlink" title="Locks"></a>Locks</h3><p>上面我们说了隔离，这里我们再提供一种方案。就是设计一个锁，使得同一个对象在同一时间只能被访问修改一次。当一个线程想要正在修改对象的时候，就把这个对象锁起来，别的线程都无法访问。</p>
<p>根据上面的信息，我们现在要在 <code>DownloadStatus</code>上加一个锁。首先我们声明一个lock：</p>
<p><code>private Lock lock = new ReentrantLock()</code> 也就是一个可重入锁对象。<em>reentrant</em> 锁意味着什么呢？简单来说，它有一个与锁相关的获取计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，然后锁需要被释放两次才能获得真正释放</p>
<p>然后我们在调用 <code>incrementTotalBytes</code> 的时候先上一个锁，等自增1结束后再解锁。这就好比一个人进了酒店房间办事，然后把门给锁了，办完事后再把门打开。</p>
<p>但是为了程序的正常运行，我们需要用 <code>try-finally block</code> ，因为如果在 <code>totalBytes++</code>的时候抛出了一个异常（我们当然知道自增1不会抛出异常，但是在未来我们自己的程序中这可能是一段很复杂的代码，因此必须要try），那么这个锁就永远无法打开了，会导致死锁。因此我们要保证 <code>lock.unlock()</code> 在任何情况下都能执行。 </p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/32.png" style="zoom:100%;"></p>
<p>打印结果：100000</p>
<h3 id="The-synchronized-Keyword"><a href="#The-synchronized-Keyword" class="headerlink" title="The synchronized Keyword"></a>The synchronized Keyword</h3><p>要让线程之间同步，我们还可以使用 synchronized 关键词。这样我们就不用很麻烦的先锁住、然后再解锁了。</p>
<p>但是Java程序依靠<code>synchronized</code>对线程进行同步，使用<code>synchronized</code>的时候，锁住的是哪个对象非常重要。</p>
<p>让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装。更好的方法是把<code>synchronized</code>逻辑封装起来。 </p>
<p>比如我们现在就要用synchronized来封装<code>totalBytes++</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementTotalBytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        totalBytes++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，线程调用<code>incrementTotalBytes</code>方法时，它不必关心同步逻辑，因为<code>synchronized</code>代码块在<code>incrementTotalBytes</code>方法内部。并且，我们注意到，<code>synchronized</code>锁住的对象是<code>this</code>，即当前实例，这又使得创建多个<code>DownloadStatus</code>实例的时候，它们之间互不影响，可以并发执行。</p>
<p>当我们锁住的是 <code>this</code>实例的时候，实际上可以用 <code>synchronized</code>来修饰这个方法，因此这两种方法是等价的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">incrementTotalBytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">       totalBytes++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，用<code>synchronized</code>修饰的方法就是同步方法，它表示整个方法都必须用<code>this</code>实例加锁。不能对其他实例加锁。</p>
<p>但是，对 <code>this</code> 实例加锁也是有缺点的。比如说：我又新建了一个totalFiles变量来记录已下载完成的文件总数。因为文件一多，很可能是两个文件同时下载完成的，因此我们也需要用 <code>synchronized</code>关键字来修饰</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/33.png" style="zoom:100%;"></p>
<p>那么问题来了：<code>incrementTotalByts</code>和<code>incrementTotalFiles</code>这两个方法都给 <code>this</code>对象上了锁。那么如果存在某一个时刻，要同时调用这两个方法的时候，必须等其中一个方法运行完之后把this对象解锁了之后才可以继续执行另一个方法。如果这只是一个小型应用，也许没事；但是如果这个应用非常庞大，需要上锁的参数非常多，那么同时调用的时刻会很多，会造成不必要的等待、降低程序的性能。</p>
<p>为了解决这个问题，我们可以给每一个需要上锁的变量新建一个专属对象。并用这个对象传入<code>synchronized</code>关键字。如下图所示：</p>
<p>我们创建了两个Object类型的对象，一个叫<code>totalBytesLock</code>用来锁住<code>totalBytes</code>; 以及<code>totalFilesLock</code>用来锁住<code>totalFiles</code> 变量。</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/34.png" style="zoom:100%;"></p>
<p>在今后的开发中我们最好选择变量的专属对象来上锁，而不要一直使用<code>this</code>对象</p>
<h3 id="The-volatile-Keyword"><a href="#The-volatile-Keyword" class="headerlink" title="The volatile Keyword"></a>The volatile Keyword</h3><p><a href="https://blog.csdn.net/u012723673/article/details/80682208" target="_blank" rel="noopener">https://blog.csdn.net/u012723673/article/details/80682208</a></p>
<p>Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量，相比于synchronized（synchronized通常称为重量级锁），volatile更轻量级，因为它不会引起线程上下文的切换和调度。但是volatile 变量的同步性较差（有时它更简单并且开销更低），而且其使用也更容易出错。</p>
<p>在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。Java提供了volatile来保证<strong>可见性</strong>，当一个变量被volatile修饰后，表示着<strong>线程本地缓存无效</strong>，当一个线程<strong>修改共享变量</strong>后他会<strong>立即被更新到主存</strong>中，其他线程读取共享变量时，会<strong>直接从主内存中读取</strong></p>
<p>我们先来看一个没有 <code>volatile</code> 版本的代码，分析一下里面有什么错误：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/35.png" style="zoom:100%;"></p>
<p>首先我们在 <code>DownloadStatus</code> 中新建一个 <code>isDone</code>布尔变量，来表明这个下载任务是否已经完成。并设定一个 <code>getter</code>返回<code>isDone</code> 和一个 <code>setter</code>将<code>isDown</code>设为True</p>
<p>然后在<code>DownloadFileTask</code>类中，我们在下载结束后调用 <code>status.done()</code>将<code>isDone()</code> 设置为True并输出Download complete</p>
<p>最后在<code>ThreadDemo</code>类中，新建两个线程，第一个线程传入DownloadFileTask对象，第二个线程里面是个 Lambda表达式，它会一直询问status中的变量isDone是否为True，一直到下载完成 ，isDone==True,才会跳出循环并输出<code>totalBytes</code>的值。</p>
<p>我们运行这个demo，却发现程序迟迟不打印<code>totalBytes</code>的值，事实上如果我们不关闭这个程序，它就会一直运行下去。</p>
<p>为什么会发生这种事情？原因就在于 <code>thread1</code>和<code>thread2</code>两个线程之间并没有完全同步，我们注意到虽然<code>totalBytes</code>是通过 synchronized关键字修饰的，但是 <code>isDone</code> 并没有同步。因此在thread2看来，isDone始终是False。这种不可见性要从底层的JVM优化机制<strong>cache</strong>开始说起：</p>
<p>有一个变量，存储在主存中，值为1。现在CPU的两个核分别执行一条线程，将这个变量从主存中读入到CPU当中去，存储在不同的cache中，因为从cache中读取数据要比从主存中读取快得多。但是这两个CPU之间并不知道对方的cache中存的这个变量的值。因此，当CPU1将cache中的变量从1修改到2的时候，CPU2看到的该变量仍然是1，就算CPU将该变量回写到主存当中去，CPU2的cache中因为已经存储了该变量，因此仍然看不到改变后的结果。这就是多线程的<strong>不可见性</strong></p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/36.png" style="zoom:100%;"></p>
<p>一种可行但是不建议的方法就是将 <code>DownloadStatus</code>中的<code>isDone()</code>和<code>done()</code>方法都使用<code>synchronized</code>关键字修饰。但是我们有更好的方法——volatile</p>
<p>在一开始我们也说了volatile的原理，那就是告诉JVM,我这个变量是随时会变的，是不稳定的。你每次访问必须从主存当中去读取，不能从cache中去读取。</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/37.png" style="zoom:100%;"></p>
<h3 id="Thread-Signalling-with-wait-and-notify"><a href="#Thread-Signalling-with-wait-and-notify" class="headerlink" title="Thread Signalling with wait() and notify()"></a>Thread Signalling with wait() and notify()</h3><p>有时候我们会使用无限循环询问一个变量是否发生变化，比如刚才例子中，一直询问下载完成没。但是这样是很占用CPU的资源的。它可能会重复循环上亿次才能等到结果。</p>
<p>为了优化上面这种情况，我们可以用<code>wait()</code>和<code>notify()</code>方法</p>
<p>顾名思义，调用<code>wait()</code>方法后，线程进入等待状态，<code>wait()</code>方法不会返回，直到将来某个时刻，线程从等待状态被其他线程唤醒后，<code>wait()</code>方法才会返回，然后，继续执行下一条语句。<strong>注意，只能在锁对象上调用<code>wait()</code>方法</strong> 。<code>notify()</code>则是在相同的锁对象上作用，完成某件事后发出一个信号，让<code>wait()</code>去接收</p>
<p>比如下面这个例子，当我们要用while来询问<code>isDone()</code>是否为true的时候，我们对status上了一个锁。然后在里面调用<code>wait()</code>让线程2沉睡。再跑到<code>DownloadFileTask</code>类中，当下载完成时我们在 status上锁了的情况下调用 <code>notifyAll()</code>发出讯号。<code>wait()</code>收到后就会跳出循环，执行打印命令。</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/38.png" style="zoom:100%;"></p>
<p>通过这种机制我们可以降低CPU的负荷，优化程序性能。但同时，在不正确的地方使用<code>wait()</code>和<code>notify()</code>可能会造成很多难以解决的问题，因此我们不推荐这种方法。</p>
<h3 id="Atomic-Objects"><a href="#Atomic-Objects" class="headerlink" title="Atomic Objects"></a>Atomic Objects</h3><p><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/concurrent/atomic/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/concurrent/atomic/package-summary.html</a></p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/39.png" style="zoom:100%;"></p>
<p>Atomic object翻译过来就是原子对象，顾名思义，这个对象是不可分割的(不要用夸克抬杠) 。 我们之前做的所有努力，就是想避免多个线程<code>totalBytes++</code>产生竞争关系，因为<code>totalBytes++</code>需要进行三步操作，并不是原子化的。</p>
<p>ava的<code>java.util.concurrent</code>包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于<code>java.util.concurrent.atomic</code>包。</p>
<p>我们以<code>AtomicInteger</code>为例，它提供的主要操作有：</p>
<ul>
<li>增加值并返回新值：<code>int addAndGet(int delta)</code></li>
<li>加1后返回新值：<code>int incrementAndGet()</code></li>
<li>获取当前值：<code>int get()</code></li>
<li>用CAS方式设置：<code>int compareAndSet(int expect, int update)</code></li>
</ul>
<p>现在我们要做的就是将<code>totalBytes++</code>原子化，回到最初发生竞争状态的那段代码，我们要对<code>DownloadStatus</code>中的totalBytes进行修改，将其变成 <code>AtomicInteger</code>类型的数据。这时候就不能直接 <code>return totalBytes</code> 了，一定要调用 <code>get()</code>来获取当前的值；此外还要把++变成 <code>incrementAndGet()</code>，即自增1后返回。</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/40.png" style="zoom:100%;"></p>
<p>打印结果为： 100_000</p>
<p>原子类的实现原理就是<strong>compare and swap(CAS)</strong>, 比如说我调用 <code>incrementAndGet</code> 的时候原子类型的数据就会比较当前值和期望值，如果他们不相等，就进行交换操作。 </p>
<p>使用<code>java.util.concurrent.atomic</code>提供的原子操作可以简化多线程编程：</p>
<ul>
<li>原子操作实现了无锁的线程安全；</li>
<li>适用于计数器，累加器等。</li>
</ul>
<h3 id="Adders"><a href="#Adders" class="headerlink" title="Adders"></a>Adders</h3><p>虽然说原子类适用于计数器、累加器等，但是当有多个线程同时对一个对象进行累加操作的时候，我们更推荐使用Adder类，它同样可以实现原子化，但是在高并发的情况下，其速度会比 Atomic更快, 简单来说，Adder具有更高的吞吐量。</p>
<p>原理：<a href="https://blog.csdn.net/codingtu/article/details/89047291?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control" target="_blank" rel="noopener">参考这篇博客</a> </p>
<p>在LongAdder类中，我们使用 <code>intValue()</code>来获得当前<code>totalBytes</code>的值并返回为int 类型，同时在自增1的时候调用<code>increment()</code>方法。 总的来说和 Atomic 类是类似的。</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/41.png" style="zoom:100%;"></p>
<h3 id="Synchronized-Collections"><a href="#Synchronized-Collections" class="headerlink" title="Synchronized Collections"></a>Synchronized Collections</h3><p>刚才我们讲的都是关于某一个变量的同步，现在我们来学对于一个集合的同步。</p>
<p>如果我们创建一个普通的 ArrayList集合，然后创建两个线程向集合中添加元素。有可能它们会发生 Race condition 导致数据丢失，为了规避这种情况的发生我们可以使用 Synchronized Collection:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//使用了 synchronizedCollection 能规避线程之间的进制，保持线程之间的同步</span></span><br><span class="line">        Collection&lt;Integer&gt; collection = </span><br><span class="line">          Collections.synchronizedCollection(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> thread1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           collection.addAll(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">var</span> thread2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           collection.addAll(Arrays.asList(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            thread1.join();</span><br><span class="line">            thread2.join();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(collection);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Concurrent-Collections"><a href="#Concurrent-Collections" class="headerlink" title="Concurrent Collections"></a>Concurrent Collections</h3><p>当并发高的时候，使用 Synchronized Collection 会导致CPU占用过高、性能下降。这时候我们可以用 <strong>Concurrent Collection</strong></p>
<p>在<a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/concurrent/package-summary.html" target="_blank" rel="noopener">Concurrent官方文档</a> 中，我们看到有 <code>ConcurrentHashMap</code>,<code>ConcurrentLinkedDeque</code>等并发集合</p>
<p>以Map为例，假如我们要对一个HashMap进行高并发的操作，我们就可以使用 <code>ConcurrentHashMap</code>类。事实上，<code>ConcurrentHashMap</code>和<code>HashMap</code>都是对 <code>Map</code>接口的实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">         Map&lt;Integer,String&gt;map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">         map.put(<span class="number">1</span>,<span class="string">"a"</span>);</span><br><span class="line">         map.get(<span class="number">1</span>);</span><br><span class="line">         map.remove(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="The-Executive-Framework"><a href="#The-Executive-Framework" class="headerlink" title="The Executive Framework"></a>The Executive Framework</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h3 id="Thread-Pools"><a href="#Thread-Pools" class="headerlink" title="Thread Pools"></a>Thread Pools</h3><h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><h3 id="Callables-and-Futures"><a href="#Callables-and-Futures" class="headerlink" title="Callables and Futures"></a>Callables and Futures</h3><h3 id="Asynchronous-Programming"><a href="#Asynchronous-Programming" class="headerlink" title="Asynchronous Programming"></a>Asynchronous Programming</h3><h3 id="Completable-Futures"><a href="#Completable-Futures" class="headerlink" title="Completable Futures"></a>Completable Futures</h3><h3 id="Creating-a-Completable-Future"><a href="#Creating-a-Completable-Future" class="headerlink" title="Creating a Completable Future"></a>Creating a Completable Future</h3><h3 id="Implementing-an-Asynchronous-API"><a href="#Implementing-an-Asynchronous-API" class="headerlink" title="Implementing an Asynchronous API"></a>Implementing an Asynchronous API</h3><h3 id="Running-Code-on-Completion"><a href="#Running-Code-on-Completion" class="headerlink" title="Running Code on Completion"></a>Running Code on Completion</h3><h3 id="Handling-Exceptions"><a href="#Handling-Exceptions" class="headerlink" title="Handling Exceptions"></a>Handling Exceptions</h3><h3 id="Transforming-a-Completable-Future"><a href="#Transforming-a-Completable-Future" class="headerlink" title="Transforming a Completable Future"></a>Transforming a Completable Future</h3><h3 id="Composing-Completable-Futures"><a href="#Composing-Completable-Futures" class="headerlink" title="Composing Completable Futures"></a>Composing Completable Futures</h3><h3 id="Combining-Completable-Futures"><a href="#Combining-Completable-Futures" class="headerlink" title="Combining Completable Futures"></a>Combining Completable Futures</h3><h3 id="Waiting-for-Many-Tasks-to-Complete"><a href="#Waiting-for-Many-Tasks-to-Complete" class="headerlink" title="Waiting for Many Tasks to Complete"></a>Waiting for Many Tasks to Complete</h3><h3 id="Waiting-for-the-First-Task"><a href="#Waiting-for-the-First-Task" class="headerlink" title="Waiting for the First Task"></a>Waiting for the First Task</h3><h3 id="Handling-timeouts"><a href="#Handling-timeouts" class="headerlink" title="Handling timeouts"></a>Handling timeouts</h3><h3 id="Project-Best-Price-Finder"><a href="#Project-Best-Price-Finder" class="headerlink" title="Project- Best Price Finder"></a>Project- Best Price Finder</h3><h3 id="Solution-Getting-a-Quote"><a href="#Solution-Getting-a-Quote" class="headerlink" title="Solution- Getting a Quote"></a>Solution- Getting a Quote</h3><h3 id="Solution-Getting-Many-Quotes"><a href="#Solution-Getting-Many-Quotes" class="headerlink" title="Solution- Getting Many Quotes"></a>Solution- Getting Many Quotes</h3><h3 id="Solution-Random-Delays"><a href="#Solution-Random-Delays" class="headerlink" title="Solution- Random Delays"></a>Solution- Random Delays</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/" class="post-title-link" itemprop="url">离散分布和连续分布（2.4-2.6）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-16 13:15:07" itemprop="dateCreated datePublished" datetime="2021-03-16T13:15:07+08:00">2021-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-06-26 21:55:18" itemprop="dateModified" datetime="2021-06-26T21:55:18+08:00">2021-06-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="常用离散分布"><a href="#常用离散分布" class="headerlink" title="常用离散分布"></a>常用离散分布</h1><h2 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h2><p>二项分布： X = “n次伯努利试验中成功的次数”</p>
<p>取值范围：0~n，为整数</p>
<p>分布列：$P(X=k)C_n^k p^k(1-p)^{n-k},k=0,1,\cdots,n$  </p>
<p>记为： $X \sim b(n,p)$ </p>
<h4 id="二点分布"><a href="#二点分布" class="headerlink" title="二点分布"></a>二点分布</h4><p>当 n=1 时的二项分布 $b(1,p)$ 称为 二点分布，或称 <strong>0-1分布</strong>，或称<strong>伯努利分布</strong>。</p>
<p>取值范围： 0，1</p>
<p>分布列： $P(X=x) = p^x(1-p)^{1-x}$ </p>
<p>二点分布主要用来描述一次伯努利试验中成功地次数(0或1) </p>
<h2 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h2><p>分布列： $P(X=k)=\frac{\lambda^k}{k!} e^{-\lambda},k=0,1,2,\cdots$  其中，参数 $\lambda&gt;0$ ，记为 $X\sim P(\lambda)$ </p>
<p>通过级数的知识，我们很容易验证泊松分布的正则性： $\sum<em>{k=0}^\infty \frac{\lambda^k}{k!}e^{-\lambda}=e^{-\lambda}\sum</em>{k=0}^{\infty} \frac{\lambda^k}{k!} =e^{-\lambda}e^{\lambda} = 1$</p>
<p>泊松分布常常用来刻画单位时间、单位面积上发生的次数。</p>
<p>泊松分布和二项分布的关系：在n重的伯努利试验中，设成功的概率为 $p<em>n$  当 $n\rightarrow \infty$  ，且 $n*p_n \rightarrow n$ 时，我们有 $\lim\limits</em>{n\rightarrow \infty}C_k^n p_n^k (1-p_n)^{n-k} = \frac{\lambda^k}{k!} e^{-\lambda}$ </p>
<p>泊松分布的概率质量函数(pmf) ：</p>
<p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/8.png" style="zoom: 67%;"></p>
<p>对泊松分布的pmf做出的解释： 每个点的意义就是单位时间或者面积内随机事件发生k次的概率。</p>
<p>CDF:</p>
<p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/9.png" style="zoom: 67%;"></p>
<p>对泊松分布的 CDF作解释 ：每个点的意义就是单位时间或者面积内随机事件发生的次数小于等于K次发生的概率</p>
<h4 id="期望与方差"><a href="#期望与方差" class="headerlink" title="期望与方差"></a>期望与方差</h4><p>求期望很简单，只要提出一个 $\lambda$ 剩下的求和为1；</p>
<p>方差的计算： 根据公式 $V(X)= E(X^2)-E(X)^2 = \lambda $ </p>
<h2 id="几何分布与负二项分布"><a href="#几何分布与负二项分布" class="headerlink" title="几何分布与负二项分布"></a>几何分布与负二项分布</h2><h3 id="几何分布"><a href="#几何分布" class="headerlink" title="几何分布"></a>几何分布</h3><p>几何分布：在伯努利试验序列中，记每次试验中事件A发生的概率为p，如果X为<strong>事件A首次出现</strong>时的<strong>试验次数</strong>，则X的可能取值为 $1,2\cdots$, 则称 X 服从几何分布，记为 $X\sim Ge(p)$ </p>
<p>分布列： $P(X=k)=(1-p)^{k-1}p , ~k=1,2\cdots$ </p>
<p>例如， 某产品的不合格率为0.05 , 则首次查到不合格品的检查次数 $X\sim Ge(0.05)$ </p>
<h4 id="性质：无记忆性"><a href="#性质：无记忆性" class="headerlink" title="性质：无记忆性"></a>性质：无记忆性</h4><p>设 $X\sim Ge(p)$ ,则对任意正整数m与n有： $P(X&gt;m+n|X&gt;m)=P(X&gt;n)$ </p>
<p>这个定理表明，在前m次试验中事件A没有出现的条件下，在接下去的n次试验中A仍然不出现的概率只与n有关，而与以前的m次试验无关，似乎忘记了前面m次的试验结果，这就是无记忆性。</p>
<h4 id="期望与方差-1"><a href="#期望与方差-1" class="headerlink" title="期望与方差"></a>期望与方差</h4><p><strong>期望:</strong></p>
<p>令 $1-p = q$ </p>
<p>$E(X)=p+2qp+3q^2p\cdots+kq^{k-1}p = p(1+2q+3q^2+\cdots+kq^{k-1})$ </p>
<p>令括号内部的式子为 $f(q)$, 则 $f(q)=(q+q^2+\cdots+q^k)’=[\frac{q(1-q^k)}{1-q}]’$</p>
<p>当$k\rightarrow \infty$的时候， $q^k\rightarrow 0$ ，因此 $[\frac{q}{1-q}]’ = \frac{1-q+q}{(1-q)^2}=\frac{1}{p^2}$ </p>
<p>所以 $E(X)=\frac{1}{p}$</p>
<p><strong>方差：</strong></p>
<p>根据公式 $V(X)=E(X^2)+E(X)^2$计算，方法和求期望一样。解得 $V(X)=\frac{1-p}{p^2}$</p>
<h3 id="负二项分布"><a href="#负二项分布" class="headerlink" title="负二项分布"></a>负二项分布</h3><p>作为几何分布的一种延伸，我们来讲负二项分布，也叫做帕斯卡分布</p>
<p>如果X 为事件 A 第 r 次出现时的试验次数，则 X的可能取值为 $r,r+1,\cdots,r+m,\cdots$ , 称 X 服从负二项分布。</p>
<p>分布列： $P(X=k)=C_{k-1}^{r-1}p^r(1-p)^{k-r} , k=r,r+1,\cdots$ </p>
<p>记为： $X\sim Nb(r,p)$   当 r=1 时，即为几何分布。</p>
<p>一个负二项分布可以写成 r 个<strong>独立同分布的几何分布的和</strong>的形式</p>
<h4 id="期望与方差-2"><a href="#期望与方差-2" class="headerlink" title="期望与方差"></a>期望与方差</h4><p>一个负二项分布可以写成r个独立同分布的几何分布的和的形式，因此其期望可以写作 $\frac{r}{p}$, 方差则可以写作$r(1-p)/p^2$</p>
<h1 id="常用连续分布"><a href="#常用连续分布" class="headerlink" title="常用连续分布"></a>常用连续分布</h1><h2 id="正态分布-高斯分布"><a href="#正态分布-高斯分布" class="headerlink" title="正态分布(高斯分布)"></a>正态分布(高斯分布)</h2><p>在统计学中常常用正态分布，在机器学习领域常常叫高斯分布。</p>
<p>若随机变量 X 的密度函数为 $p(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{\frac{(x-\mu)^2}{2\sigma^2}},-\infty&lt;x&lt;\infty$， 则称 X 服从正态分布，称X为正态变量</p>
<p>记作 $X\sim N(\mu,\sigma^2)$ 其中参数 $-\infty&lt;\mu&lt;\infty , \sigma&gt;0$ </p>
<p>密度函数(PDF) p(x):</p>
<p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/1.png" style="zoom:180%;"></p>
<p>分布函数(CDF) $p(x)=\frac{1}{\sqrt{2\pi}\sigma}\int_{-\infty}^xe^{\frac{(t-\mu)^2}{2\sigma^2}}dt$</p>
<p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/2.png" style="zoom: 50%;"></p>
<h3 id="标准正态分布"><a href="#标准正态分布" class="headerlink" title="标准正态分布"></a>标准正态分布</h3><p>当 $\mu =0,\sigma^2 =1 $ 时候。 通常记标准正态变量为U，记标准正态分布的密度函数为 $\varphi(u)$即：</p>
<p>$ \varphi(u)=\frac{1}{\sqrt{2\pi}}e^{-\frac{u^2}{2}}, -\infty&lt;u&lt;\infty$ </p>
<p> 分布函数为 $\Phi(u)$</p>
<p>$\Phi(u)=\frac{1}{\sqrt{2\pi}}\int_{-\infty}^u e^{-\frac{t^2}{2}}dt, -\infty&lt;u&lt;\infty$  </p>
<p> 由于标准正态分布的分布函数不含任何未知参数，故其值 $\Phi(u)=P(U\leq u)$ 完全可以算出。对于 $\Phi(u)$ 有</p>
<ul>
<li>$\Phi(-u)=1-\Phi(u)$ </li>
<li>$P(U&gt;u)= 1-\Phi(u)$ </li>
<li>$P(a&lt;U&lt;b)=\Phi(b)-\Phi(a)$ </li>
<li>$P(|U|&lt;c)=2\Phi(c)-1$ ，原理如下图所示，黄色阴影部分即为 $P(|U|&lt;c)$ </li>
</ul>
<p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/3.jpg"></p>
<h3 id="正态分布族"><a href="#正态分布族" class="headerlink" title="正态分布族"></a>正态分布族</h3><p>正态分布有一个家族： $\mathcal P = {N(\mu,\sigma^2):-\infty &lt; \mu&lt;\infty ,\sigma &gt;0 } $,标准正态分布也是其中的一员. 一般的正态变量都可以通过一个线性变换(标准化) 化成标准正态变量。因此与正态变量有关的一切事件的概率都可以通过查标准正态分布函数表来获得。</p>
<p><strong>定理：</strong> 若随机变量 $X\sim N(\mu,\sigma^2)$ ,则 $U=(X-\mu)/\sigma\sim N(0,1)$ </p>
<p>由以上的定理，我们可以得到一些在实际中有用的计算公式: 若随机变量 $X\sim N(\mu,\sigma^2)$ ,则：</p>
<script type="math/tex; mode=display">
P(X\leq c) = \Phi(\frac{c-\mu}{\sigma})</script><p>例题：设随机变量 X服从正态分布 $N(108,3^2)$ , 试求：1. $P(102&lt;X&lt;117)$ 2. 常数a，使得 $P(X&lt;a)=0.95$ </p>
<p>我们可以利用公式 $P(a&lt;U&lt;b)=\Phi(b)-\Phi(a)$ 可得： $P(102&lt;X&lt;117)=P(117)-P(102)=\Phi(\frac{117-108}{3})-\Phi(\frac{102-108}{3})=\Phi(3)-\Phi(-2)=0.9759$ </p>
<p> 对于2，我们首先对定理做一个变形： 由 $P(X&lt;a)=\Phi(\frac{a-108}{3})= 0.95$  可知： $\Phi^{-1}(0.95)=\frac{a-108}3$ </p>
<p>所以现在我们就要查出满足$\Phi(x)=0.95$ 的值。通过查表得： $\Phi(1.64)=0.9495,\Phi(1.65)=0.9505$ ,再用线性内插法可得 $\Phi(1.645)= 0.95$ 即 $\Phi^{-1}(0.95)=1.645$ 故：$\frac{a-108}{3} = 1.645$ 解得 $a=112.935$</p>
<h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><p>设随机变量X 服从正态分布 $N(\mu,\sigma^2)$ 试问： 随着 $\sigma$ 的增大，概率 $P(|X-\mu|&lt;\sigma)$ 是如何变化的？</p>
<p>这个例题也可以作为一个正态分布的性质来记：</p>
<p>$P(|X-\mu|&lt;\sigma)=P(-\sigma &lt;X-\mu&lt;\sigma)=P(-1&lt;\frac{X-\mu}{\sigma}&lt;1)$</p>
<p>由 $\frac{(X-\mu)}{\sigma}\sim N(0,1)$可知，$P(-1&lt;\frac{X-\mu}{\sigma}&lt;1)=\Phi(1)-\Phi(-1)$</p>
<p>因此，不管 $\sigma$如何变化， $P(|X-\mu|&lt;\sigma)$的值都是个定值。</p>
<h3 id="3-sigma-原则"><a href="#3-sigma-原则" class="headerlink" title="$3\sigma$ 原则"></a>$3\sigma$ 原则</h3><p>设随机变量 $X\sim N(\mu,\sigma^2)$ , 则 $p(\mu-k\sigma&lt;X&lt;\mu+k\sigma)=P(|\frac{X-\mu}{\sigma}|&lt;k) = \Phi(k)-\Phi(-k)=2\Phi(k)-1$ </p>
<p>当 $k=1,2,3$ 时， 有</p>
<script type="math/tex; mode=display">
P(\mu-\sigma<X<\mu+\sigma) = 2\Phi(1)-1 = 0.6826\\
P(\mu-2\sigma<X<\mu+2\sigma) = 2\Phi(1)-1 = 0.9545\\
P(\mu-3\sigma<X<\mu+3\sigma) = 2\Phi(1)-1 = 0.9973</script><p>这是正态分布的重要性之，计入某随机变量的取值概率近似满足上面三个公式，则可认为这个随机变量近似服从正态分布。三式中有一个偏差较大，则可认为这个随机变量不服从正态分布。这就是 $3\sigma$ 原则。这个原则 在 X 的观察值较多的时候常常用于判断 X 的分布是否近似服从正态分布</p>
<h3 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h3><p>由期望的定义可以知道， $E(X)=\int_{-\infty}^{\infty}\frac{x}{\sigma\sqrt{2\pi}}exp{-\frac{(x-\mu)^2}{2\sigma^2}}dx$ </p>
<p>令 $y=x-u$ 可得： $E(X)=\int_{-\infty}^{\infty}y\frac{1}{\sigma\sqrt{2\pi}}exp{-\frac{y^2}{2\sigma^2}}dy+u\frac{1}{\sigma\sqrt{2\pi}}exp{-\frac{y^2}{2\sigma^2}}$ </p>
<p>第一部分用 $I<em>1$ 表示： 因为$\int</em>{-\infty}^{\infty} = x\frac{1}{\sigma\sqrt{2\pi}}exp{-\frac{x^2}{2\sigma^2}}$ 是一个奇函数，所以第一部分等于0</p>
<p>所以原式可以写成 $E(X)=\mu\int_{-\infty}^{\infty}\frac{1}{\sigma\sqrt{2\pi}}exp{-\frac{x^2}{2\sigma^2}}$ </p>
<p>后面的积分就是求 $\int_{-\infty}^\infty N(0,\sigma^2)dx = 1$ </p>
<p>因此$E(X)=\mu$ </p>
<h3 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h3><p> <img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/14.png"></p>
<h2 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h2><p> 当分布函数(CDF)为：$F\left( x\right) =\begin{cases}0,<del>x &lt;a\ \dfrac{x-a}{b-a},</del>a\leq x\leq b\ 1,~~x &gt;b\end{cases}$， 密度函数(PDF)为$\begin{cases}\dfrac{1}{b-a},a &lt;x &lt;b\ 0, {其他}\end{cases}$时，这个分布就是区间 $(0,a)$上的均匀分布，记为 $U(a,b)$ </p>
<h3 id="期望和方差"><a href="#期望和方差" class="headerlink" title="期望和方差"></a>期望和方差</h3><p>$E(X) = \int_a^b x \frac{1}{b-a}dx = \frac{a+b}{2}$</p>
<p>$Var(X) = E(X^2)-E(X)^2 = (b-a)^2/12$ </p>
<h2 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h2><p>若随机变量X的密度函数(PDF)为$p(x) = \begin{cases}\lambda e^{-\lambda x} <del>,</del> x \geq 0 \ 0, x<0 \end{cases}$ 则称 x 服从指数分布。记作 $x\sim exp(\lambda)$ ,其中参数 $\lambda>0 $ .</0></p>
<p>正则性的验证：$\int_0^{+\infty} p(x) dx = -e^{-\lambda x}|_0^{\infty} = 1$ </p>
<p>指数分布的分布函数为： $F(x)=p(X\leq x) =\begin{cases}1- e^{-\lambda x} <del>,</del> x \geq 0 \ 0, x&lt;0 \end{cases}$ </p>
<p>指数分布是一种偏态分布，由于指数分布随机变量值可能取非负实数，所以指数分布常用作各种“寿命” 分布。比如说电子元器件的寿命、动物的寿命、通话时间都可以假定服从指数分布。</p>
<p>指数分布的 PDF: </p>
<p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/6.png" style="zoom:67%;"></p>
<p>先来看 $\lambda = 1$ 这条曲线。曲线上横坐标为1的点，其意义是 1个单位时间该发生1次的概率。如果横坐标为2，其意义就是2个单位时间内发生1次的概率。抽象一点来说就是：第 k 次改时间发生后隔2个单位时间发生第 $k+1$ 次该事件的概率。</p>
<p>当 $\lambda = 1.5$ 的时候，变得更加抽象了，因为这时候横坐标为1的点其意义是1个单位的时间内发生1.5次的概率。换个说法就是第k次事件发生后1个单位时间内该事件发生1.5 次的概率。</p>
<p>指数分布的 CDF：</p>
<p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/10.png" style="zoom:67%;"></p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><h4 id="无记忆性"><a href="#无记忆性" class="headerlink" title="无记忆性"></a>无记忆性</h4><p>和几何分布一样，指数分布有着无记忆性。 也就是说,对任意的$s,t &gt;0$, 若$X\sim Exp(\lambda)$ ,则 $P(x&gt;s+t|x&gt;s)=P(x&gt;t)$  .</p>
<p>放到一个具体的例子中，可以理解为： 记X 为某种产品的使用寿命(h) 。若X服从指数分布，那么已知此产品使用了 s(h)没有发生故障，则再能使用 t(h) 而不发生故障的概率与已使用的 $s(h)$无关，只想到与重新开始使用 t(h) 的概率。</p>
<h4 id="和泊松分布的关系"><a href="#和泊松分布的关系" class="headerlink" title="和泊松分布的关系"></a>和泊松分布的关系</h4><p>如果某设备在长为t的时间 $[0,t]$ 内发生故障的次数 $N(t)$ (与时间长度t有关)服从参数为 $\lambda t$ 的泊松分布。则相继两次故障之间的时间间隔T服从参数为$\lambda $ 的指数分布。</p>
<p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/7.png" style="zoom:150%;"></p>
<h3 id="期望和方差-1"><a href="#期望和方差-1" class="headerlink" title="期望和方差"></a>期望和方差</h3><p>由指数分布和伽马分布的关系可以知道，指数分布的期望和方差即为当$\alpha = 1$ 的时候伽马分布的期望和方差。</p>
<p>所以 $E(X) = \frac{1}{\lambda},Var(X) = \frac{1}{\lambda^2}$ </p>
<p>泊松分布是针对随机事件发生次数的定义的<strong>离散随机变量</strong>，而指数分布是针对随机事件发生的间隔时间定义的<strong>连续随机变量</strong>，这是二者最大的区别。切莫因为参数λ把二者混淆了</p>
<h2 id="伽马分布"><a href="#伽马分布" class="headerlink" title="伽马分布"></a>伽马分布</h2><h3 id="伽马函数"><a href="#伽马函数" class="headerlink" title="伽马函数"></a>伽马函数</h3><p>首先我们来定义伽马函数</p>
<p>$\Gamma(\alpha) = \int_0^\infty x^{\alpha-1}e^{-x} dx$  是伽马函数。其中 $\alpha&gt;0 $ 。</p>
<h4 id="函数性质"><a href="#函数性质" class="headerlink" title="函数性质"></a>函数性质</h4><ul>
<li>$\Gamma(1)=1,\Gamma(\frac{1}{2}) = \sqrt{\pi}$</li>
</ul>
<p>当 $\alpha$ = 0.5 时， $\Gamma(\frac{1}{2} ) = \int_0^\infty\frac{e^{-x}}{\sqrt{x}}dx$ , 令 $t = \sqrt x$ 则 $x = t^2$ 原式等于 $2\int_0^\infty e^{-t^2}dt$ </p>
<p>根据正态分布的密度函数可以知道，当 $\mu = 0,\sigma^2= \frac{1}{2}$ 时， $1 = \int_{-\infty}^{\infty} \frac{1}{\sqrt{2\pi \frac{1}{2}}} <em>exp(\frac{-(t-0)^2}{2</em>\frac{1}{2}})dt$ </p>
<p>$\int_{-\infty}^{\infty}  \frac{1}{\sqrt\pi}*e^{-t^2}dt = 1 $ 又正态分布为偶函数，因此可得 $\Gamma(\frac{1}2)=\sqrt{\pi}$ </p>
<ul>
<li>$\Gamma(\alpha+1) = \alpha\Gamma(\alpha) $ (可用分布积分法证明得到)，当 $\alpha$为自然数 n的时候，有 $\Gamma(n+1) = n\Gamma (n)= n!$ </li>
</ul>
<h3 id="伽马分布-1"><a href="#伽马分布-1" class="headerlink" title="伽马分布"></a>伽马分布</h3><p>若随机变量X的密度函数为 $p(x) = \begin{cases}\frac{\lambda^\alpha}{\Gamma(\alpha)}x^{\alpha-1}e^{-\lambda x} <del>,</del> x \geq 0 \ 0, x<0 \end{cases}$ 则称 x 服从 伽马分布，记作 $x\sim ga(\alpha ,\lambda)$ 其中，$\alpha>0 $ 为形状参数，$\lambda&gt;0$ 是尺度参数。如下图所示</0></p>
<p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/12.png"></p>
<h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><ul>
<li><p>当伽马函数的 $\alpha = 1$ 的时候 ，伽马分布的PDF = 指数分布的PDF。这说明指数分布是特殊的伽马分布 </p>
<h3 id="期望-1"><a href="#期望-1" class="headerlink" title="期望"></a>期望</h3></li>
</ul>
<p>首先我们要牢记这条性质：$\Gamma(\alpha+1) = \alpha\Gamma(\alpha) $ </p>
<p>$E(X) = \int_0^\infty xp(x)dx = \int_0^\infty x\cdot\frac{\lambda^\alpha}{\Gamma{(\alpha)}}x^{\alpha-1}e^{-\lambda x}dx = \frac{\lambda^\alpha}{\Gamma(\alpha)}\int_0^\infty x^{(\alpha+1)-1} e^{-\lambda x}dx $  </p>
<p>$=\frac{\lambda^\alpha}{\Gamma(\alpha)}<em>\frac{\Gamma(\alpha+1)}{\lambda^{\alpha+1}}</em>1 = \frac{\alpha}{\lambda}$ </p>
<p>我们可以利用凑数的方法，强行把后面的积分配成一个 $Ga(\alpha+1,\lambda)$ ,根据 $\int_0^\infty Ga(\alpha+1,\lambda) = 1$可以消除积分。</p>
<h3 id="方差-1"><a href="#方差-1" class="headerlink" title="方差"></a>方差</h3><p>利用配方法，我们还可以求出伽马分布的方差</p>
<p>我们根据公式 $Var(X) = E(X^2)-E(X)^2$ 可以得到</p>
<p> $E(X^2) = \int_0^\infty x^2 \frac{\lambda^\alpha}{\Gamma(\alpha)}x^{\alpha-1}e^{-\lambda x}dx =\frac{\lambda^\alpha}{\Gamma(\alpha)} \frac{\Gamma({\alpha+2})}{\lambda^{\alpha+2}}\int_0^\infty Ga(\alpha+2,\lambda)dx = \frac{\alpha(\alpha+1)}{\lambda^2}$ </p>
<p>$Var(X) = E(X^2)-E(X)^2 = \frac{\alpha(\alpha+1)}{\lambda^2} - \frac{\alpha^2}{\lambda^2} = \frac{\alpha}{\lambda^2}$</p>
<h2 id="贝塔分布"><a href="#贝塔分布" class="headerlink" title="贝塔分布"></a>贝塔分布</h2><h3 id="贝塔函数"><a href="#贝塔函数" class="headerlink" title="贝塔函数"></a>贝塔函数</h3><p>称函数 $B(a,b)=\int_0^1 x^{a -1}(1-x)^{b-1}dx$ 为贝塔函数，其中参数$a&gt;0,b&gt;0$ </p>
<h4 id="贝塔函数性质"><a href="#贝塔函数性质" class="headerlink" title="贝塔函数性质"></a>贝塔函数性质</h4><ul>
<li>$B(a,b) = B(b,a)$ 通过换元法可以直接证明</li>
<li>贝塔函数和伽马函数之间有关系： $B(a,b) = \frac{\Gamma(a)\Gamma(b)}{\Gamma(a+b)}$ </li>
</ul>
<h3 id="贝塔分布-1"><a href="#贝塔分布-1" class="headerlink" title="贝塔分布"></a>贝塔分布</h3><p>若随机变量X的密度函数为  $p(x) = \begin{cases}\frac{\Gamma (a+b)}{\Gamma(a){\Gamma(b)}}x^{a-1}(1-x)^{b-1 } <del>,</del> 0<x <1\\ 0, 其他 \end{cases}$ ，则称其为 贝塔分布，记作 $x\sim be(a,b)$ 其中 $a>0,b&gt;0$ 都是形状参数，下图给出几种典型的贝塔分布密度函数曲线。</x></p>
<p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/13.png" style="zoom:150%;"></p>
<ul>
<li>当 a=b=1 时，$Be(1,1) = U(0,1)$ 即贝塔分布等于0-1上的均匀分布</li>
</ul>
<p>因为服从贝塔分布 $Be(a,b)$ 的随机变量是仅在区间$(0,1)$取值的所以可以描述一些不合格产品率、机器的维修率、市场的占有率、射击的命中率等各种比率。</p>
<h2 id="期望和方差-2"><a href="#期望和方差-2" class="headerlink" title="期望和方差"></a>期望和方差</h2><p>同样的，我们可以利用求 伽马分布的期望和方差的办法来求贝塔函数的期望和方差。</p>
<p>$P(X) =\frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)} x^{a-1}(1-x)^{b-1}$ </p>
<p>$E(X) = \frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)}\int_0^1  x^{(a+1)-1}(1-x)^{b-1} dx= \frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)}\frac{\Gamma(a+1)\Gamma(b)}{\Gamma(a+b+1)} = \frac{a}{a+b}$ </p>
<p>$Var(X) = E(X^2)-E(X)^2 = \frac{(a+1)a}{(a+b+1)(a+b)}- \frac{a^2}{(a+b)^2} = \frac{ab}{(a+b+1)(a+b)^2}$ </p>
<h1 id="常用概率分布表格"><a href="#常用概率分布表格" class="headerlink" title="常用概率分布表格"></a>常用概率分布表格</h1><p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/4.png"></p>
<p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/4.png"></p>
<h1 id="随机变量函数的分布"><a href="#随机变量函数的分布" class="headerlink" title="随机变量函数的分布"></a>随机变量函数的分布</h1><h2 id="离散随机变量函数的分布"><a href="#离散随机变量函数的分布" class="headerlink" title="离散随机变量函数的分布"></a>离散随机变量函数的分布</h2><p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/16.png"></p>
<p>这种情况比较简单，如果题目给出的是X的分布列，那么我们直接列出$g(x)$的分布列即可。</p>
<h2 id="连续随机变量函数的分布"><a href="#连续随机变量函数的分布" class="headerlink" title="连续随机变量函数的分布"></a>连续随机变量函数的分布</h2><h3 id="当-Y-g-X-为离散随机变量"><a href="#当-Y-g-X-为离散随机变量" class="headerlink" title="当 $Y=g(X)$ 为离散随机变量"></a>当 $Y=g(X)$ 为离散随机变量</h3><p>这种情况比较简单，只要将 Y 的值一一列出，再讲 Y 取各种可能值得概率求出来即可。例如：设 $X\sim N(\mu,\sigma^2)$ </p>
<p>$Y = \begin{cases}0 , X&lt;\mu \ 1, X\geq \mu \end{cases}$   这样计算很容易： Y 服从 $p=0.5$的0-1分布</p>
<p>因此，我们要注意一些 pdf 为对称函数的分布，会简化很多计算。</p>
<p>比如说 $X$的pdf为 $p(x)=\frac{2}{\pi}\cdot \frac{1}{e^x+e^{-x}} ,-\infty&lt;x&lt;\infty$ ,试求 $Y=g(X)$ 的分布， $g(X) = \begin{cases}-1 , x&lt;0 \ 1, x\geq 0 \end{cases}$  </p>
<p>p(x)就是一个很标准的偶函数，关于x=0对称。因此 Y = 1和-1 的概率相等，都是0.5</p>
<h3 id="当-g-x-在定义域内为严格单调函数时"><a href="#当-g-x-在定义域内为严格单调函数时" class="headerlink" title="当 $g(x)$ 在定义域内为严格单调函数时"></a>当 $g(x)$ 在定义域内为严格单调函数时</h3><h4 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h4><p>设 $X$ 是连续随机变量，其密度函数为 $p_X(x)$ $Y=g(x)$ 是另一个连续随机变量。若 $y=g(x)$ 严格单调，其反函数 $h(y)$ 有连续导函数，则$Y=g(X)$ 的密度函数为：</p>
<p>$p_Y(y)= \begin{cases} P_X(h(y))|h’(y)| ,~a&lt;y&lt;b \ 0, 其他 \end{cases}$  其中  $a=min{g(-\infty).g(\infty)}$  , $b=max{g(-\infty),g(\infty)}$</p>
<h5 id="例题：-1"><a href="#例题：-1" class="headerlink" title="例题："></a>例题：</h5><p>设随机变量X服从区间$(1,2)$上的均匀分布，试求 $Y=e^{2X}$ 的密度函数</p>
<p><strong>步骤1：写出 X 的 pdf </strong></p>
<p>$p_X(y)= \begin{cases} 1 ,~~1&lt;y&lt;2 \ 0, 其他 \end{cases}$</p>
<p><strong>步骤2：写出Y与X之间的关系Y=g(x)</strong></p>
<p>这里我们已经知道了 $y=e^{2x}$ </p>
<p><strong>步骤3： 判断g(x)是否在定义域内为单调递增函数</strong></p>
<p>$y=e^{2x}$在 $x\in(1,2)$ 内是严格的单调递增函数</p>
<p><strong>步骤4：计算g(x)的反函数h(x)以及 |h’(y)|</strong></p>
<p>求得 $x=\frac{1}{2}\ln y$</p>
<p><strong>步骤5：根据公式，计算</strong> $p_Y(y)=p_X(h(y))|h’|$</p>
<p>$p_Y(y) =\begin{cases} 1\cdot \frac{1}{2y}, e^2&lt;y&lt;e^4 \ \0 ~~其他 \end{cases}$ </p>
<p>根据以上定理，我们可以来证明几个很有用的结论，并用定理形式表示。</p>
<h4 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h4><p>设随机变量 X 服从正态分布 $N(\mu,\sigma^2)$ ，则当 $a\neq 0$ 时候，有 $Y=aX+b\sim N(a\mu+b,a^2\sigma^2)$ </p>
<p>我们可以通过分类讨论来证明 $p_Y(y)=\frac{1}{\sqrt{2\pi}(a\sigma)}{exp{-\frac{(y-a\mu-b)^2}{2a^2\sigma^2}}}$ ,也就是 $N(a\mu+b,a^2\sigma^2)$ 的密度函数。</p>
<p>我们可以直接用 期望和方差来计算 $\mu$值和$\sigma^2$值</p>
<h4 id="定理3：对数正态分布"><a href="#定理3：对数正态分布" class="headerlink" title="定理3：对数正态分布"></a>定理3：对数正态分布</h4><p>设随机变量 $X\sim N(\mu,\sigma^2)$ </p>
<p>令 $Y=e^X$ ，那么当$y&gt;0$ 时，Y 的密度函数为：</p>
<script type="math/tex; mode=display">
p_Y(y) = \frac{1}{\sqrt{2\pi}\sigma}\exp\{-\frac{(\ln y-\mu)^2}{2\sigma^2}\}\frac{1}{y} = \frac{1}{\sqrt{2\pi}y \sigma} \exp\{-\frac{(\ln y-\mu)^2}
{2\sigma^2}\}</script><p>$p_Y(y)= \begin{cases}\frac{1}{\sqrt{2\pi}y\sigma}exp{-\frac{(\ln y-\mu)^2}{2\sigma^2}} , y&gt;0 \ 0, y\leq 0  \end{cases}$ </p>
<p>这个分布被称为正态分布，记为 $LN(\mu,\sigma^2)$ ,其中 $\mu$ 称为对数均值，$\sigma^2$ 称为对数方差。 对数正态分布 $LN(\mu,\sigma^2)$ 是一个偏态分布，也是一个常用分布，实际种有不少随机变量服从对数正态分布。 </p>
<p>对数函数的证明：</p>
<ul>
<li>绝缘材料的寿命服从对数正态分布</li>
<li>设备故障的维修时间服从对数正态分布</li>
</ul>
<h5 id="对数正态分布的期望"><a href="#对数正态分布的期望" class="headerlink" title="对数正态分布的期望"></a>对数正态分布的期望</h5><script type="math/tex; mode=display">
E(Y)=E(\exp\{X\})=\int_{-\infty}^\infty\exp\{x\}\frac{1}{\sqrt {2\pi}\sigma} \exp\{-\frac{1}{2\sigma^2}(x-\mu)^2\}dx\\~\\
=\int_{-\infty}^\infty \frac{1}{\sqrt{2\pi}\sigma}\exp\{-\frac{1}{2\sigma^2}(x^2-2\mu x-2\sigma^2x+\mu^2)\}dx\\
~\\
=\int_{-\infty}^\infty\frac{1}{\sqrt{2\pi}\sigma}\exp\{-\frac{1}{2\sigma^2}(x-\mu-\sigma^2)^2+\frac{(\mu+\sigma^2)^2}{2\sigma^2}-\frac{\mu^2}{2\sigma^2}\}dx\\
=\exp\{\mu+\sigma^2/2\}</script><p><strong>给定$N(0,1)$的p分位数为$\mu_p$ ,求Y的p分位数 $y_p$</strong></p>
<p>已知</p>
<script type="math/tex; mode=display">
p=P(Y\leq y_p)=P(\exp\{X\}\leq y_p)=P(X\leq \ln(y_p))=P(\frac{X-\mu}{\sigma}\leq\frac{\ln(y_p)-\mu}{\sigma})\\</script><p>因为 $X\sim N(\mu,\sigma^2)$, 所以 $\frac{X-\mu}{\sigma}\sim N(0,1)$ ，于是：</p>
<script type="math/tex; mode=display">
\frac{ln(Y_p)-\mu}{\sigma}=\mu_p</script><p>因此，$y_p=\exp{\sigma\mu_p+\mu}$</p>
<h4 id="定理4"><a href="#定理4" class="headerlink" title="定理4"></a>定理4</h4><p>设随机变量 X 服从伽马分布 $Ga(\alpha,\lambda)$ ，则当 $k&gt;0$的时候，有 $Y=kX\sim Ga(\alpha,\lambda/k)$ </p>
<p>根据定理1可得， $p_Y(y)=p_x(\frac{y}k)\frac{1}{k} = \frac{\lambda^\alpha}{k\Gamma{(\alpha)}} (\frac{y}{k})^{\alpha-1} exp{-\lambda \frac{y}{k}}$ </p>
<p>=$\frac{(\lambda/k)^\alpha}{\Gamma(\alpha)}y^{\alpha-1} exp{-\frac{\lambda}{k}y}$  这也就是 $Ga(\alpha,\lambda/k)$ 的密度函数。</p>
<h4 id="定理5"><a href="#定理5" class="headerlink" title="定理5"></a>定理5</h4><p>若随机变量 X的分布 $F_X(x)$ 为严格单调增的连续函数，其反函数 $F_X^{-1} (y)$ 存在，那么 $Y=F_X(X)$服从(0,1)上的均匀分布 $U(0,1)$ </p>
<p>这个定理比较神奇，我们来看一下它的证明：</p>
<p>由于分布函数 $F_X(x)$ 仅在 $[0,1]$区间上取值，因此当 $y&lt;0$ 时，因为 ${F_X(X)\leq y}$ 是不可能事件，所以 $F_Y(y) = P(Y\leq y)=P(F_X(X)\leq y)=0$ </p>
<p>当 $0\leq y&lt;1$ 有 $F_Y(y) = P(Y\leq y) = P(F_X(X)\leq y)=P(X\leq F_X^{-1}(y))=F_X(F_X^{-1}(y))=y$ </p>
<p>当 $y\geq 1$ 时， 因为 ${F_Y(y) \leq y)}$是必然事件 所以 $F_Y(y)=1$ </p>
<p><strong>这个定理表明</strong>: 均匀分布在连续分布类中占有特殊地位，任一个连续随机变量 X 都可通过其分布$F(x)$ 与均匀分布随机变量 $U$ 发生关系，譬如 X 服从指数分布, 其分布函数 $F(x)= 1-e^{-\lambda X}$ .<strong>当 x 换为 X</strong> 后，有 $U=1-e^{-\lambda X}$ 或者 $X=\frac{1}{\lambda}\ln\frac{1}{1-U} $ </p>
<p>后一式表明： 由均匀分布 $U(0,1)$ 的随机数 $u_i$ 可得指数分布$Exp(\lambda)$ 的随机数 $x_i=\frac{1}{\lambda}ln(\frac{1}{1-u_i}),i=1,2,\cdots,n,\cdots$ 而均匀分布随机数在任何一个统计软件中都可以产生，从而指数分布的随机数也可以获得。</p>
<p>各种分布随机数的获得，就是进行蒙特卡洛法的基础</p>
<h3 id="g-x-为其他形式时"><a href="#g-x-为其他形式时" class="headerlink" title="$g(x)$ 为其他形式时"></a>$g(x)$ 为其他形式时</h3><p>如果g(x)不是严格单调的函数，那么可直接由 分布函数 $F_Y(y)=P(g(X)\leq y)$出发，按函数$g(x)$ 的特点作个案处理，比如：</p>
<p>设随机变量X 服从<strong>标准正态分布</strong>  $N(0,1)$，试求 $Y=X^2$ 的分布函数函数</p>
<p><strong>步骤1：求 Y 的取值范围</strong></p>
<p>首先 $Y=X^2$,x的取值范围为$(-\infty,+\infty)$ ,则 y的取值范围为 $[0,\infty)$</p>
<p>那么我们就可以先确定当 $y\leq 0$ 的时候，有 $F_Y(y)=0$ ，从而$P_Y(y)=0$ </p>
<p><strong>步骤2：根据定义求解。</strong> $F_Y(y)=p_X(Y\leq y)=p_X(g(x)\leq y)$</p>
<p>当 $y&gt;0$ 的时候，有 $F_Y(y)=p_X(Y\leq y)=p_X(X^2\leq y)=p(-\sqrt y\leq X\leq \sqrt  y)=2\Phi(\sqrt y)-1$ </p>
<p>因此 $Y$ 的分布函数为 $F_Y = \begin{cases}2\Phi(\sqrt y)-1 , y&gt;0 \ 0, y\leq 0 \end{cases}$ </p>
<h1 id="分布的其他特征数"><a href="#分布的其他特征数" class="headerlink" title="分布的其他特征数"></a>分布的其他特征数</h1><h2 id="k阶矩"><a href="#k阶矩" class="headerlink" title="k阶矩"></a>k阶矩</h2><p><strong>定义：</strong> 设 X 为随机变量，k为正整数。 若数学期望$E(X)$ 存在，则称 $\mu_k = E(X^k)$ 为X的 k阶原点矩。称 $v_k = E(X-E(X))^k$ 为X的k阶中心矩。</p>
<p>显然,<strong>一阶原点矩</strong>就是数学<strong>期望</strong>，<strong>二阶中心矩</strong>就是<strong>方差</strong>。由1于 $|X|^{k-1} \leq |X|^k+1$, 故 k 阶矩存在时，低于k的各阶矩都存在。</p>
<p>中心矩和原点矩之间有一个简单的关系： </p>
<script type="math/tex; mode=display">
v_k = E(X-E(X))^k - E(X-\mu_1)^k = \sum_{i=0}^k C_k^i \mu_i(-\mu_1)^{k-i}</script><h2 id="变异系数"><a href="#变异系数" class="headerlink" title="变异系数"></a>变异系数</h2><p>当在比较两个随机变量的波动大小的时候，如果仅仅看方差(标准差) 的大小有时会产生不合理的现象。这有两个原因</p>
<ul>
<li>随机变量的取值有量纲，不同量纲的随机变量用其方差(或标准差)去比较它们的波动大小就显得不合理</li>
<li>在取值的量纲相同的情况下，取值的大小有一个相对性问题，取值较大的随机变量的方差(或标准差)也允许大一些。</li>
</ul>
<p>因此，要比较两个随机变量的波动大小的时候，在有些场合使用<strong>变异系数</strong> 来进行比较更有可比性：</p>
<p>若随即变量 X 的二阶矩存在，则称比值：$G_v(X) = \frac{\sqrt{Var(X)}}{E(X)} = \frac{\sigma(X)}{E(X)}$  为 X 的变异系数。</p>
<h2 id="分位数"><a href="#分位数" class="headerlink" title="分位数"></a>分位数</h2><p>设连续随机变量X的分布函数为 $F(x)$ ,密度函数为$p(x)$,对任意 $p\in(0,1)$ </p>
<ol>
<li><p>满足条件 $F(x<em>p) = \int</em>{-\infty}^{x_p}p(x)dx=p$ 的   $x_p$ 为此分布的 p分位数，又称<strong>下侧p分位数</strong>；</p>
</li>
<li><p>同理我们称满足条件 $1-F(x<em>p’) = \int</em>{x_p’}^{\infty}p(x)dx=p $  的 $x_p’$ 为此分布的<strong>上侧p分位数</strong></p>
</li>
<li><p>分位数 $x_p$ 是把密度函数下的面积分为两块，左侧面积恰好为p  </p>
</li>
<li>我们通过标准正态分布p分位数表可以知晓 $\Phi(x)$ 的不同分位数的值$u_p$。然后，对于一般正态分布$N(\mu,\sigma^2)$的p分位数$x_p$ 是方程 $\Phi(\frac{x_p-\mu}{\sigma})= p$ 的解。因此 $x_p = \mu+\sigma u_p$</li>
</ol>
<h2 id="中位数"><a href="#中位数" class="headerlink" title="中位数"></a>中位数</h2><p>设连续随机变量 X 的随机分布为 $F(x)$ ,密度函数为 $p(x)$. 称 $p=0.5$ 时的p分位数$x_{0.5}$ 为此分布的中位数。</p>
<p>$F(x<em>{0.5}) =\int</em>{-\infty}^{x_{0.5}}p(x)dx = 0.5 $ </p>
<h2 id="偏度系数"><a href="#偏度系数" class="headerlink" title="偏度系数"></a>偏度系数</h2><p>设随机变量 $X$ 的<strong>前三阶矩</strong>存在，则比值</p>
<p>$\beta_S = \frac{v_3}{v_2^{3/2}} = \frac{E(X-E(X))^3}{[Var(X)]^{3/2}}$  称为 X (或分布) 的偏度系数，简称偏度。 当 $\beta_S&gt;0$  时，称该分布为右偏(正偏)，当 $\beta_S&lt;0$ 时，称该分布为左偏(负偏)。</p>
<p>简单来判断，尾巴偏哪(异常值在哪)就是往哪偏：</p>
<p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/15.png"></p>
<h2 id="峰度系数"><a href="#峰度系数" class="headerlink" title="峰度系数"></a>峰度系数</h2><ol>
<li>设随机变量 X 的<strong>前四阶矩</strong>存在，则 $\beta_k = \frac{v_4}{v_2^2}-3=\frac{E(X-E(X))^4}{[Var(X)]^2}-3$  称为X(或分布) 的峰度系数，简称峰度。</li>
<li>峰度时描述分布尖峭程度和尾部粗细的一个特征数</li>
<li>任一正态分布的峰度 $\beta_k =0$ 当 $\beta_k<0$时， 分布比正态分布平坦； 当$\beta_k>0$时，分布比正态分布更尖峭</0$时，></li>
<li><p>偏度与峰度都是描述分布(密度)形状的参数。</p>
<p>z</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/03/16/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%EF%BC%882-1-2-3%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/16/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%EF%BC%882-1-2-3%EF%BC%89/" class="post-title-link" itemprop="url">随机变量（2-1-2-3）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-16 13:14:02" itemprop="dateCreated datePublished" datetime="2021-03-16T13:14:02+08:00">2021-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-16 11:57:01" itemprop="dateModified" datetime="2023-01-16T11:57:01+08:00">2023-01-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="随机变量及其分布"><a href="#随机变量及其分布" class="headerlink" title="随机变量及其分布"></a>随机变量及其分布</h1><p>定义在样本空间$\Omega$上的实值函数 $X=X(\omega)$ 称为随机变量，通常用大写的字母 X，Y，Z等表示随机变量，其取值用小写字母 x,y,z 等表示。</p>
<p>假如一个随机变量尽可能取有现个或可列个值，则称其为离散随机变量；假如一个随机变量的可能取之充满数轴上的一个区间 $(a,b)$ ,则称其为连续随机变量，其中a或b可以是 $\infty$ </p>
<h3 id="随机变量的分布函数-CDF"><a href="#随机变量的分布函数-CDF" class="headerlink" title="随机变量的分布函数(CDF)"></a>随机变量的分布函数(CDF)</h3><p>设 X 是一个随机变量，对任意实数x，称 $F(x) =P(X\leq x)$ 为随机变量X的分布函数。 且<strong>称 $X$ 服从 $F(x)$ , 记为$X\sim F(x)$</strong> 。 </p>
<h4 id="三条基本性质："><a href="#三条基本性质：" class="headerlink" title="三条基本性质："></a>三条基本性质：</h4><ul>
<li><strong>单调性</strong>  $F(x)$ 是定义在整个实数轴上的<strong>单调非减函数</strong> ，即对任意的 $x_1&lt;x_2$ ,有 $F(x_1)\leq F(x_2)$</li>
<li><strong>有界性</strong> 对任意的x，都有 $0\leq F(x)\leq 1$ 且 $F(-\infty) = \lim\limits<em>{x\rightarrow-\infty}F(x) = 0$; $F(\infty) = \lim\limits</em>{x\rightarrow\infty}F(x)=1$ </li>
<li><strong>右连续性</strong> $F(x)$ 是 x 的右连续函数，即对任意的 $x<em>0$ ,有 $\lim\limits</em>{x\rightarrow x_0^{+0}}F(x)=F(x_0)$ ,即 $F(x_0+0)=F(x_0)$ </li>
</ul>
<p>右连续性在计算分布函数中的未知参数有很大的作用。</p>
<p>这三条基本性质也成为了判别某个函数是否能成为分布函数的<strong>充要条件</strong> </p>
<p> 接下来还会说CDF是<strong>概率密度函数</strong>(PDF)的积分</p>
<p>有了随机变量 X的分布函数，那么有关 X 的各种事件的概率都能方便的用分布函数来表示了。例如对任意的实数 a、b，有：</p>
<ol>
<li>$P(a&lt;X\leq b) = F(b)-F(a)$</li>
<li>$P(a&lt;X&lt;b)=F(b-0)-F(a)$</li>
<li>$P(a\leq X\leq b)=F(b)-F(a-0)$</li>
<li>$P(a\leq X&lt;b)=F(b-0)-F(a-0)$</li>
<li>$P(X=a)=F(a)-F(a-0)$</li>
<li>$P(X\geq b)=1-F(b-0)$</li>
<li>$P(X&gt;b)= 1-F(b)$</li>
<li>$P(X&lt;b)=F(b-0)$</li>
</ol>
<p>特别当 F(x) 在 a与b 处连续时，有 $F(a-0)=F(a), F(b-0)=F(b)$ </p>
<p>上面这几个 公式非常重要，我们要牢牢基础。</p>
<h3 id="离散随机变量的概率分布列"><a href="#离散随机变量的概率分布列" class="headerlink" title="离散随机变量的概率分布列"></a>离散随机变量的概率分布列</h3><p>设 X 是一个离散随机变量，如果 X 的所有可能取值是 $x_1,x_2,\cdots,x_n,\cdots$ ,则称 X 取 $x_i$ 的概率。则称 X 取 $x_i$ 的概率 $p_i = p(x_i)=P(X=x_i),i=1,2,\cdots,n,\cdots$  为 X 的概率分布列或简称分布列，记为 $X\sim {p_i}$ </p>
<h4 id="分布列的基本性质"><a href="#分布列的基本性质" class="headerlink" title="分布列的基本性质"></a>分布列的基本性质</h4><ul>
<li>非负性  $p(x_i)\geq 0,i=1,2\cdots$</li>
<li>正则性 $\sum_{i=1}^\infty p(x_i)=1$ </li>
</ul>
<p>由离散随机变量 X 的分布列很容易写出 X的分布函数</p>
<h3 id="连续随机变量的概率密度函数-PDF"><a href="#连续随机变量的概率密度函数-PDF" class="headerlink" title="连续随机变量的概率密度函数(PDF)"></a>连续随机变量的概率密度函数(PDF)</h3><p>设随机变量X 的分布函数为 $F(x)$ ,如果存在实数轴上的一个非负可积函数$p(x)$,使得对任意函数x有 $F(x) = \int_{-\infty}^x p(t)dt$ ,则称 $p(x)$ 为 X 的<strong>概率密度函数</strong>，简称<strong>密度函数</strong> ，同时称 X 为连续随机变量，称 $F(x)$ 为<strong>连续分布函数</strong>  </p>
<p>简单的来说就是PDF是CDF的一阶导数。</p>
<h4 id="密度函数的基本性质"><a href="#密度函数的基本性质" class="headerlink" title="密度函数的基本性质"></a>密度函数的基本性质</h4><ul>
<li>非负性 $p(x)\geq 0$</li>
<li>正则性 $\int_{-\infty}^{\infty} p(x)dx = 1$</li>
</ul>
<p>譬如已知某个函数 $p(x)$ 为密度函数，若$p(x)$ 中有一个待定常数，那么我们就可以利用正则性 $\int_{-\infty}^{\infty} p(x)dx = 1$ 来确定该常数的值。</p>
<h4 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h4><p>当分布函数(CDF)为：$F\left( x\right) =\begin{cases}0,<del>x &lt;a\ \dfrac{x-a}{b-a},</del>a\leq x\leq b\ 1,~~x &gt;b\end{cases}$， 密度函数(PDF)为$\begin{cases}\dfrac{1}{b-a},a &lt;x &lt;b\ 0, {其他}\end{cases}$时，这个分布就是区间 $(0,a)$上的均匀分布，记为 $U(a,b)$ </p>
<h1 id="随机变量的数学期望"><a href="#随机变量的数学期望" class="headerlink" title="随机变量的数学期望"></a>随机变量的数学期望</h1><p>设<strong>离散随机变量 </strong>X 的分部列为 $p(x_i) = P(X=x_i),i = 1,2,…,n…$</p>
<p>如果 $\sum<em>{i=1}^\infty |x_i|p(x_i)&lt;\infty$ ，则称 $E(X) = \sum</em>{i=1}^\infty x_ip(x_i)$  为随机变量的<strong>期望</strong>或均值。注意，期望一定要收敛，否则期望便不复存在。</p>
<p>同样的，对于<strong>连续随机变量</strong> X 的密度函数为 $p(x)$ ,如果 $\int<em>{-\infty}^{\infty}|x|p(x)dx&lt;\infty$ ,则称 $E(X) = \int</em>{-\infty}^{\infty} xp(x)dx$ 为X的数学期望。</p>
<h3 id="期望的一些性质"><a href="#期望的一些性质" class="headerlink" title="期望的一些性质"></a>期望的一些性质</h3><p><strong>定理</strong>： 若随机变量 X 的分布用分布列 $p(x<em>i)$ 或用密度函数 $p(x)$ 表示，则 X 的某一函数$g(X)$ 的数学期望为 $E[g(X)]=\begin{cases}\sum</em>{i}g(x<em>i)p(x_i) ,在离散场合 \ \int</em>{-\infty}^{\infty}g(x)p(x)dx, {在连续场合}\end{cases} $</p>
<ul>
<li>性质1：设c是常数，则 $E(c) = c$</li>
<li>性质2：对任意常数 a 有 $E(aX)=aE(X)$ </li>
<li>性质3：对任意的两个函数 $g_1(x)$和 $g_2(x)$ 有： $E[g_1(x)\pm g_2(x)] = E[g_1(x)]\pm E[g_2(x)]$ </li>
</ul>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>设连续随机变量 X 的分布函数为 $F(x)$ ，且数学期望存在，证明：</p>
<p>$E(X) = \int<em>0^{+\infty} [1-F(x)]dx-\int</em>{-\infty}^0F(x)dx$ </p>
<p>解：</p>
<script type="math/tex; mode=display">
E(X) = \int_{-\infty}^{\infty} xp(x) dx =\int_{-\infty}^0 xp(x) dx+\int_{0}^\infty xp(x)dx\\~\\</script><p>将第一个积分改写为二次积分，然后改变积分次序，得到：</p>
<script type="math/tex; mode=display">
\int_{-\infty}^0 xp(x) dx =-\int_{-\infty}^0(\int_{x}^0 dy)p(x) dx\\~\\
=-\int_{-\infty}^0\int_{-\infty}^y p(x)dxdy\\~\\
=-\int_{-\infty}^0 F(y)dy</script><p>第二个积分也可以写成二次积分并改变积分次序：</p>
<script type="math/tex; mode=display">
\int_{0}^\infty xp(x)dx=\int_{0}^\infty (\int_{0}^x dy) p(x)dx =\int_{0}^\infty(\int_{y}^\infty p(x)dx)dy</script><p>因此当X 为非负的连续随机变量,且 $E(X^n)$ 存在，则可证明：</p>
<ul>
<li>$E(X) = \int<em>{0}^{+\infty} [1-F(x)]dx =\int</em>{0}^\infty P(X&gt;x)dx$  </li>
<li>$E(X^n) =\int_0^\infty n x^{n-1} P(X&gt;x)dx$  证明： $E(X^n)=\int_0^\infty P(X^n&gt;y)dy$ ， 那么当 $y=x^n$ 的时候，实际上我们可以得到 $E(X^n)=\int_0^\infty P(X^n&gt;x^n)nx^{n-1}dx$  ， 即$E(X^n)=\int_0^\infty P(X&gt;x)nx^{n-1}dx$</li>
</ul>
<h1 id="随机变量的方差与标准差"><a href="#随机变量的方差与标准差" class="headerlink" title="随机变量的方差与标准差"></a>随机变量的方差与标准差</h1><p>若随机变量 $X^2$ 的数学期望 $E(X^2)$ 存在，则称偏差平方 $(X-E(X))^2$ 的数学期望 $E(X-E(X))^2$ 为随机变量$X$ 为随机变量 $X$ 的方差，记为 $Var(X) = E(X-E(X))^2 = \begin{cases}\sum<em>i(x_i-E(X))^2p(x_i),在离散场合\ \int</em>{-\infty}^\infty (x-E(X))^2p(x)dx, {在连续场合}\end{cases}$  </p>
<p>并称方差的正平方根 $\sqrt{Var(X)}$为随机变量(或相应分布) 的标准差，记为 $\sigma(X)$或$\sigma_X$</p>
<p><strong>当随机变量X的数学期望存在时，方差不一定存在；而当X的方差存在时，则E(X)必定存在</strong></p>
<h3 id="方差的性质"><a href="#方差的性质" class="headerlink" title="方差的性质"></a>方差的性质</h3><h4 id="性质1："><a href="#性质1：" class="headerlink" title="性质1："></a>性质1：</h4><p>$Var(X) = E(X^2)-[E(X)]^2$ </p>
<p>在实际计算方差的时候，这个性质往往比定义 $Var(X) = E(X-E(X))^2$ 更加常用</p>
<p><strong>证明</strong>：$Var(X) = E(X^2)-2E(X)*E(X)+(E(X))^2 = E(X^2)-(E(X))^2$</p>
<h4 id="性质2："><a href="#性质2：" class="headerlink" title="性质2："></a>性质2：</h4><p>常数的方差为0，即 $Var(c) = 0$</p>
<p>若c是常数，则 $Var(c) = E(c-E(c))^2 = E(c-c)^2 = 0$ </p>
<h4 id="性质3："><a href="#性质3：" class="headerlink" title="性质3："></a>性质3：</h4><p>若a，b是常数，则 $Var(aX+b) = a^2Var(X)$</p>
<h3 id="切比雪夫不等式"><a href="#切比雪夫不等式" class="headerlink" title="切比雪夫不等式"></a>切比雪夫不等式</h3><p>设随机变量X 的数学<strong>期望和方差都存在</strong>则对任意常数$\epsilon&gt;0$  ,有 $P(|X-E(X)|\geq \epsilon)\leq \frac{Var(X)}{\epsilon^2}$ </p>
<p>通过二次放缩的方法可以证明：记 $E(X)=a$</p>
<p><img src="/2021/03/16/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%EF%BC%882-1-2-3%EF%BC%89/1.png" style="zoom:150%;"></p>
<p>因为  $|x-a|\geq \epsilon$, 所以 $\frac{|x-a|^2}{\epsilon^2}\geq 1$ </p>
<p>然后进行第二次缩放，将原来的积分范围修改成整个实数域</p>
<script type="math/tex; mode=display">
\int_{\{x:|x-a|\geq\epsilon\}}\frac{(x-a)^2}{\epsilon^2} p(x)dx\leq \frac{1}{\epsilon^2}\int_{-\infty}^{\infty}(x-a)^2p(x)dx</script><p>积分部分的值就是方差的定义，因此积分等于$Var(X)$ </p>
<p>在概率论中，时间 $||X-E(X)|\geq \epsilon|$称为大偏差，其概率 $P(|X-E(X)|)\geq \epsilon$称为大偏差发生概率。切比雪夫不等书给出大偏差发生概率的上界，这个上界与方差成正比,方差越大、上界也就越大。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/03/05/%E5%BE%B7%E5%B7%9E%E6%89%91%E5%85%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/05/%E5%BE%B7%E5%B7%9E%E6%89%91%E5%85%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/" class="post-title-link" itemprop="url">德州扑克学习笔记1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-05 19:12:32" itemprop="dateCreated datePublished" datetime="2021-03-05T19:12:32+08:00">2021-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-07 12:42:28" itemprop="dateModified" datetime="2021-03-07T12:42:28+08:00">2021-03-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="德州扑克学习笔记1"><a href="#德州扑克学习笔记1" class="headerlink" title="德州扑克学习笔记1"></a>德州扑克学习笔记1</h1><h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><h3 id="牌型大小"><a href="#牌型大小" class="headerlink" title="牌型大小"></a>牌型大小</h3><p>每个人手里先发两张牌。公共牌一共五张，先发三张，叫做翻牌(flop)，第四张叫做转牌(turn)，第五张叫做河牌(river)。</p>
<p>下面是牌型大小的梳理：</p>
<p>皇家同花顺，比如说 ♠10 ♠J ♠Q ♠K ♠A</p>
<p>同花顺，比如说 ♠3 ♠4 ♠5 ♠6 ♠7</p>
<p>四条，比如说 四个2，四个3</p>
<p>葫芦(满堂红)： 三带二</p>
<p>同花: 五张牌都是一种花色</p>
<p>顺子: 不一定同花</p>
<p>三条：有三张同一点数的牌</p>
<p>两对：两个对子</p>
<p>一对：两个对子</p>
<p>一共7张牌，选出5张最大的组合。</p>
<h3 id="翻牌前发牌"><a href="#翻牌前发牌" class="headerlink" title="翻牌前发牌"></a>翻牌前发牌</h3><p>在发牌前，小盲位和大盲位分别需要下小盲注和大盲注，大盲是小盲的两倍。</p>
<p>发牌从小盲开始，以六人桌为例，分别是： 小盲、大盲、枪口(UTG)、后置位的两个人、按钮位(庄家，button)</p>
<p>因为小盲和大盲已经下过盲注了，因此从枪口位置开始行动。每个人轮到的时候，都可以有三到四种可以选择的行动：弃牌、跟注、加注、过牌。当前面的选手加注以后，你就不能过牌了，必须选择跟注或弃牌。每一轮加注结束的标志是所有决定参与的玩家最终投入了一样多的筹码，如果不想再投入，就要弃牌。</p>
<h3 id="翻牌后发牌"><a href="#翻牌后发牌" class="headerlink" title="翻牌后发牌"></a>翻牌后发牌</h3><p>发公共的时候，要先切掉一张牌，然后再发三张；再切掉一张牌，发转牌；最后切掉一张牌，发河牌</p>
<p>庄家是每一轮最后发言的人，正常的顺序是从小盲这里开始按顺时针发牌。</p>
<h3 id="筹码选择"><a href="#筹码选择" class="headerlink" title="筹码选择"></a>筹码选择</h3><p>一般情况下，我们只需要筹码之间是五倍的关系：1，5，25，100.  玩家一般会从100个大盲开始买入。比如说我们规定盲注分别是1/2，那么每个人的初始筹码一般是200.也就是 10个1，8个5，6个25</p>
<h3 id="新手建议"><a href="#新手建议" class="headerlink" title="新手建议"></a>新手建议</h3><ol>
<li>加入一张桌子的时候，要收悉其他人的打法。</li>
<li>要分清楚哪些是应该尽量避免交手的高手，哪些是送财童子，那些比较激进，哪些比较保守，哪些喜欢 bluff，哪些人容易上头</li>
<li><strong>不要流露自己的情绪</strong>。</li>
</ol>
<h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><p>首先要明白一个基本概念： 越靠后的位置越好。因为翻拍后，行动顺序是从小盲开始，之后是大盲、枪口、枪口+1，枪口+2，这几个算是前置位。之后是中间的几个人，比如HIJACK 、CUTOFF，最后的位置是 Button位，也就是庄家。因此Button是最有优势的位置。</p>
<p><img src="/2021/03/05/%E5%BE%B7%E5%B7%9E%E6%89%91%E5%85%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/1.png" style="zoom:120%;"></p>
<p>Button位置的优势：</p>
<ol>
<li>可以看完前面所有人的决定后再做决定</li>
<li>前面牌力不强的时候，后置位更容易诈唬</li>
<li>后位强牌加注，看起来会更像诈唬</li>
<li>前位是强牌，后位是更强牌，能赢更多。</li>
</ol>
<p>由于位置优劣的影响，直接决定了该位置玩家该玩的手牌、范围、策略都是不一样的。</p>
<p>首先我们要科普一个概念： 3-bet。如果翻拍前有一个人起raise入池，后面的人在这个基础上再加注，就叫 3-bet。 我们可以理解成：大盲是第一个bet，起raise的人是第二个bet，那么再加注的人就叫3-bet。很多人不知道该玩什么牌，简单来说就是如果我们的位置好，就可以打地更激进一点，可以多玩一些牌。如果位置差，就保守一点，少玩一些牌 </p>
<p>下面是一个表格，里面讲两张手牌分为了六个等级。</p>
<p><img src="/2021/03/05/%E5%BE%B7%E5%B7%9E%E6%89%91%E5%85%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/2.png" style="zoom:120%;"></p>
<p>两张手牌后面带o的是不同花色，带s的是同一花色。</p>
<h3 id="一等牌力"><a href="#一等牌力" class="headerlink" title="一等牌力"></a>一等牌力</h3><p>左上角的 AA， AKs，AKo, KK, QQ都是最强的牌力。在任何位置上的都建议主动加注，也可以3-bet其他人</p>
<h3 id="二等牌力"><a href="#二等牌力" class="headerlink" title="二等牌力"></a>二等牌力</h3><p>AQs,AJs,KQs,AQo,KQo ，JJ，TT是二等牌力，则也是很好的牌，足以在任何位置起raise。面对3-bet，可以跟注，有时候也可以主动3-bet别人</p>
<h3 id="三等牌力"><a href="#三等牌力" class="headerlink" title="三等牌力"></a>三等牌力</h3><p>淡红色的三等牌力，已经落入了中等牌力的范围。主要是 AT以下的同花色牌以及 AJ，KQ等牌。三等牌力的牌依然可以在所有的位置上起raise，包括在后位偶尔3-bet形象不好的玩家。但是如果自己起raise入池，被后家 3-bet了，那就基本很难再领先对手了。</p>
<p>拿到了这些牌，现金局又不可能直接弃掉。所以还是建议自己起raise，如果被3-bet了，可以根据对手的风格，有时跟注有时弃牌，甚至偶尔可以4-bet回击。</p>
<h4 id="A小"><a href="#A小" class="headerlink" title="A小"></a>A小</h4><p>注意到A小同花是三等牌力，而A小不同花则放到了四五等牌力去了。他们的主要区别：</p>
<p>A小同花和A小不同花的策略是很不一样的。如果 我拿了A小同花，一旦翻牌三张后两张是我想要的花色，那么我们就是在听A同花，大部分情况下我都有30%以上的概率能够赢对方。所以拿两张同花色牌的时候，第一目标就是为了等同花。而听同花破产之后，即使中了对子，A小的价值也小了很多。</p>
<h3 id="四等牌力"><a href="#四等牌力" class="headerlink" title="四等牌力"></a>四等牌力</h3><p>四等牌力覆盖了很大的范围，基本属于在前位，可以玩也可以弃牌，在后位是可以玩的牌。</p>
<h4 id="A小不同花"><a href="#A小不同花" class="headerlink" title="A小不同花"></a>A小不同花</h4><p>注意到 ATs是三等牌力，ATo是四等牌力，因为ATs有听同花的可能，打牌很多时候是要看信心的，如果我们即有对子，又能听同花，表现出来的信心是远远大于只中了对子而不能听同花的牌的。</p>
<p>此外我们看ATo和A5o虽然差了不少，但仍然是属于四等牌力，建议在前位直接弃掉，在中后位看情况入池。这些牌的主要问题是，A5如果我中了A，很可能其他玩家也有A，但是踢脚(Kicker)比我的大，这时候我们已经被压制了但是我们中了AA不可能轻易弃牌。再比如说我是A8,翻牌 J87, 中了一个对子但也不知道自己的牌有多大。</p>
<p>很多新手看到手牌中的A就弃不动牌，中了A就丢不到，最终输了很多。</p>
<h4 id="KTo-到-JTo"><a href="#KTo-到-JTo" class="headerlink" title="KTo 到 JTo"></a>KTo 到 JTo</h4><p>这几副牌如果在前位，你又比较保守，建议直接弃牌。比如说我拿了 KTo,翻牌中了K但踢脚比10大。</p>
<h4 id="小口袋对"><a href="#小口袋对" class="headerlink" title="小口袋对"></a>小口袋对</h4><p>其他一些小的口袋对和同花连张也是四等牌力。比如对4，现金局一般是多人入池，拿了对4、发出5张牌之后，很难还是领先对手的。所以玩小对子目标就是中3条。中了3条基本就是坚果牌(必赢牌)，而且非常隐蔽。可以直接加注，也就可以在别人加注后再加注，或者根据牌面的潮湿度选择快打慢打。</p>
<h4 id="潮湿度"><a href="#潮湿度" class="headerlink" title="潮湿度"></a>潮湿度</h4><p>比如说翻出的3张牌是  ♠7 ♠6 ♠4，有三张黑桃，这个牌面是非常非常湿的。这时候如果我们中了3条，最好加注直接把别人赶走，因为如果再发出一张黑桃牌，或这者3，8，就为别人多了很多中听同花、买顺的组合。所以3张4在这种情况是非常不稳的，因此建议快打。</p>
<p>如果牌面是 ♦4，♥9，♠K，三张不同花，且分割很大，这个牌面就很干。因为不可有人会去听同花。如果要听顺子的人，也只能卡一张牌。比如说有人有 J T，对于公共牌他需要听 Q，只有四张牌的可能性。成功率就会小很多。所以这种时候可以慢打。</p>
<h4 id="同花连张"><a href="#同花连张" class="headerlink" title="同花连张"></a>同花连张</h4><p>同花连张既可以听同花也可以听顺子。当然小的同花连张是更倾向于听顺的。比如说我手牌是 56♣s，翻牌三张为 ♥K，♣4，♣8.这时候我们可以听9张梅花牌还有4张7，减去一张♣7，共有12张牌能让我们成牌。并且后面还需要发两张牌，因此我们有50%的几率获得坚果牌。为什么更倾向于听顺子呢? 因为如果真来了一张梅花，而其他人刚好也在听梅花，有很大概率她的手牌是比♣6更大的，因此我们更加期待来一张不同花色7. 这个顺子就非常隐蔽了。</p>
<p>而如果我手上是 ♣A 和♣2， 我们就不用怕任何听同花。</p>
<h3 id="五等牌力"><a href="#五等牌力" class="headerlink" title="五等牌力"></a>五等牌力</h3><p>五等牌力是黄色的，这边建议不要玩或者尽量少玩。比如说79s这种牌，如果一直玩的话是非常危险的。可以在后位偶尔玩一下，或者只需要很少的筹码就能入池看牌的时候。</p>
<p>这里我们要了解一个术语： Limp(跛入)： 即只跟注大盲而没有加注。比如我在小盲为，我可以只跟到大盲位的数量就可以入池。或者有一个人起raise而很多人跟进，那么我们也可以玩一下，因为这时候赔率很好。但这时候如果我们拿的是一等或者二等的牌力，我是希望用加注来赶人的，因为如果拿了大牌不赶人，很多其他的小牌就会进来，而如果自己拿的大牌中了 A对，而小牌的人中了两对或者顺子的时候，那么这时候自己很难弃牌，</p>
<h3 id="六等牌力"><a href="#六等牌力" class="headerlink" title="六等牌力"></a>六等牌力</h3><p>六等牌力建议再任何情况下都不要玩的牌</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>拿一等二等牌力，要主动出击，拿中等牌力主要看位置，拿低等牌力要看赔率非常好的时候才能入池。</p>
<p>A小同花等同花，同花连张等顺子。不要贪恋As小，牌力容易被压制；小对目标听三条，不中被打则弃牌。</p>
<p>现在我们以8人现金桌为例。翻牌前枪口的人先行动。他拿KT不同花先起raise，后面7个人有非常大的概率拿 AQ,AK以及10以上的口袋对，即使没有拿到很强牌力的牌，也可能选择 3-bet 回去。拿中等牌力的人遇到3-bet常常会遇到一个困境：自己牌力不够，不足4-bet回去，于是跟注了别人的3-bet。发出翻牌之后没有中牌，只能过牌。这时候位置靠后的人因为在翻牌前就显示了自己的牌力，因此翻牌后不管有牌没牌都会3-bet回去。很多时候，位置靠前的人，没有中牌就会弃牌。如果前置位的人经常遇到这种牌，这其实会输掉不少筹码。</p>
<p>在锦标赛中，如果是枪口或枪口+1位置的人起raise，每一个其他人几乎一定会认为这个人手牌很强，但是如果 button起raise，那么他的手牌范围就很广。</p>
<p>一般情况下，新手若在前位，只建议玩中强牌力以上的牌，比如 6以上的对子，AK， AQ这样的大牌。新手常常犯的一个错误就是自己不敢raise，只敢跟别人的raise，导致自己中牌之后，可能会输掉更多。所以新手在位置靠前的时候拿大牌，要入池就一定要加注入池，比如打一个3-4的大盲。</p>
<h4 id="间距理论"><a href="#间距理论" class="headerlink" title="间距理论"></a>间距理论</h4><p>相比于自己加注，你需要更强的牌来跟别人的加注。比如说我拿着 KJ同花，前面的人起raise，那么这时候我可以3-bet回去，这样是没问题的。但是如果前面第一个人起raise，后面的人已经3-bet他了，这时候拿着KJ同花是不该跟注别人的</p>
<h2 id="概率和赔率"><a href="#概率和赔率" class="headerlink" title="概率和赔率"></a>概率和赔率</h2><p>概率和赔率就是帮助我们做正确决定的工具。概率是自己击中公共牌之后能赢的概率。赔率是投入筹码和赢回筹码的比率</p>
<p>比如说： 翻拍后，有33%的概率能赢，67%的概率会输，比例是1：2</p>
<p>如果底池是100，只需要跟注20，赔率是1：5</p>
<p>$1:5&lt;1:2$ ，因此我们该跟注</p>
<h3 id="数outs"><a href="#数outs" class="headerlink" title="数outs"></a>数outs</h3><p>比如说现在是这个情况：</p>
<p><img src="/2021/03/05/%E5%BE%B7%E5%B7%9E%E6%89%91%E5%85%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/3.png" style="zoom:120%;"></p>
<p>首先我们要数能赢的牌：</p>
<p>首先转牌河牌翻出一张黑桃就能赢，因此一共有 13-4 = 9张牌。此外，所有的3都能让我们凑成顺子。不过黑桃3已经算到黑桃中了。因此这时候一共有12张牌能让我赢。</p>
<h3 id="算概率"><a href="#算概率" class="headerlink" title="算概率"></a>算概率</h3><p>我们可以用 <strong>四二定律</strong> 来计算概率</p>
<p>在发出翻牌之后，我们可以通过 能赢的牌(outs)*4 来计算概率。 比如说现在我有12张牌能赢，那么我获胜的概率大概就在48%。 </p>
<p>在转牌发出之后，我们可以通过能赢的牌*2 来简单计算能赢得概率</p>
<p>这个数字是怎么来的呢? 如果在转牌有12张outs，那么一副牌52张，4张公共牌已知，2张手牌已知，那么还有46张牌是未知的。46约等于50，一个数字除以50，换算成百分比，就是乘以2，比如 2/50 = 4%；</p>
<p>同理，翻牌上假设有12张outs，3张公共牌已知，2张手牌已知，3+2 = 5张已知，那么剩下47张牌是未知的。 我们赢得概率是12/47=26%。 那么 转牌上发出12张outs的机会是 26%，河牌发出的机会还是 26%，所以在翻牌上有12张outs能赢的概率是26+26=52%</p>
<p>我们依然按刚才的牌来算，假设我现在认为对手手里是一对10，那么如果转牌河牌发出一张A我也能赢，这时候我们的outs来到了 15张，根据四二定律，我们的胜率是60%</p>
<h3 id="算赔率"><a href="#算赔率" class="headerlink" title="算赔率"></a>算赔率</h3><p>比如说下图这个情况，底池是100，对手打了50，那么我只要跟注50，如果赢了，就能赢回来150，赔率是 25%</p>
<p><img src="/2021/03/05/%E5%BE%B7%E5%B7%9E%E6%89%91%E5%85%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/4.png" style="zoom:120%;"></p>
<h3 id="对比概率和赔率"><a href="#对比概率和赔率" class="headerlink" title="对比概率和赔率"></a>对比概率和赔率</h3><p>如果赢的概率 &gt; 赔率  : 我们应该选择 跟注</p>
<p>如果赢的概率 &lt; 赔率 : 我们应该选择 弃牌</p>
<h3 id="隐含赔率"><a href="#隐含赔率" class="headerlink" title="隐含赔率"></a>隐含赔率</h3><p>但是德州的信息并不是公开透明的，我永远不知道对手拿的是什么牌。所以隐含信息增加了游戏的不确定性。</p>
<p>有的时候，单算赔率其实是不够跟注的，因为赔率是基于在底池中的筹码而跟注的，而隐含赔率则要将对手的后手筹码考虑在内。</p>
<p>举个例子</p>
<p><img src="/2021/03/05/%E5%BE%B7%E5%B7%9E%E6%89%91%E5%85%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/5.png" style="zoom:120%;"></p>
<p>我的手里是88，对手是对A，底池是100，对手下注80，那么这时候总底池就是180。 如果我们跟注80 ，计算得到的赔率是  31%。而如果我们算概率，那么可以听三条和听顺子。一共有两张8和四张7能让我们成牌。这时候概率就是 6*4 = 24% 。 概率小于赔率，按照公式我们是不应该跟注的。</p>
<p>但是这时候大部分人都会跟注。如果选择跟注，总底池就是260，假设对手后手只有100个筹码了，如果我中牌了，那么对手在只有100个筹码的情况下是很难弃牌的 。因此我们可以认为如果中牌了，对手后手的筹码也能加入到底池当中来。那么这时候隐含赔率就是 80/(180+80+100) = 22%。 22%&lt;24%, 于是我们应该跟注。</p>
<p>另外一种情况。如果自己是88而对面是9,10 那么对手中了顶对。这时候就不应该用隐含赔率来计算。因为这时候如果我打All-in ,对手可能认为其手牌不够大，那么就会弃牌了。</p>
<h3 id="弃牌率"><a href="#弃牌率" class="headerlink" title="弃牌率"></a>弃牌率</h3><p>打弃牌率是对玩家读牌能力有一定的要求的。建议新手不要一直打弃牌率，隐含赔率倒是可以算一算</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1/" class="post-title-link" itemprop="url">计算机网络实验报告1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-04 21:24:23" itemprop="dateCreated datePublished" datetime="2021-03-04T21:24:23+08:00">2021-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-25 04:31:52" itemprop="dateModified" datetime="2022-08-25T04:31:52+08:00">2022-08-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络实验报告1"><a href="#计算机网络实验报告1" class="headerlink" title="计算机网络实验报告1"></a>计算机网络实验报告1</h1><h2 id="任务1"><a href="#任务1" class="headerlink" title="任务1"></a>任务1</h2><p>目标： 创建一个以自己姓名命名的java项目，编写java代码，将自己的学号和姓名打印出来，将操作过程中的关键步骤和实验结果截图</p>
<h3 id="实验代码："><a href="#实验代码：" class="headerlink" title="实验代码："></a>实验代码：</h3><p><img src="/2021/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1/2.png" style="zoom:100%;"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">"请输入你的名字: "</span>);</span><br><span class="line">        String name = scanner.nextLine();</span><br><span class="line">        System.out.print(<span class="string">"请输入你的学号: "</span>);</span><br><span class="line">        <span class="keyword">long</span> ID = scanner.nextLong();</span><br><span class="line">        System.out.println(<span class="string">"您好,"</span>+name+<span class="string">"! 你的学号是: "</span>+ID);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1/1.png" style="zoom:100%;"></p>
<h2 id="任务2"><a href="#任务2" class="headerlink" title="任务2"></a>任务2</h2><p><strong>目的：</strong>访问自己经常访问的网站，并将访问过程中的网络包抓取下来并截图；另外根据不同的过滤规则抓取网络包，并截图，书写实验报告</p>
<p>首先我们打开 Wireshark 软件，找到有流量的网卡，这里是无线网卡 WLAN</p>
<p><img src="/2021/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1/4.png" style="zoom:100%;"></p>
<p>结果如下，这个软件会将所有的包都抓取下来，且实时更新：</p>
<p><img src="/2021/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1/5.png" style="zoom:100%;"></p>
<h3 id="设置过滤规则"><a href="#设置过滤规则" class="headerlink" title="设置过滤规则"></a>设置过滤规则</h3><p>学习博客： <a href="https://www.cnblogs.com/mq0036/p/11187138.html" target="_blank" rel="noopener">https://www.cnblogs.com/mq0036/p/11187138.html</a></p>
<h4 id="利用地址过滤"><a href="#利用地址过滤" class="headerlink" title="利用地址过滤"></a>利用地址过滤</h4><p>我们首先在 cmd 中ping一下目标网站的域名，这里我以一个著名的学习网站：<a href="https://codewithmosh.com/" target="_blank" rel="noopener">https://codewithmosh.com/</a> 为例。</p>
<p><img src="/2021/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1/6.png" style="zoom:100%;"></p>
<p>然后我打开这个网页，并在 Wireshark里面设置过滤词: ip.addr == 104.193.88.77</p>
<p>addr 这个过滤类型是对所有 Source address和Destination address 进行筛选，因此这里一共显示了8条数据。</p>
<p><img src="/2021/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1/8.png" style="zoom:100%;"></p>
<p>如果我只对 Source address进行筛选，那么我们可以这样写：<code>ip.src == 104.193.88.77</code> </p>
<p><img src="/2021/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1/9.png" style="zoom:100%;"></p>
<p>或者对 Destination address进行筛选, 那么我们就这样写：<code>ip.dst == 104.193.88.77</code> </p>
<p><img src="/2021/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1/9.png" style="zoom:100%;"></p>
<h4 id="利用协议过滤"><a href="#利用协议过滤" class="headerlink" title="利用协议过滤"></a>利用协议过滤</h4><p>因为我们有个下载可见的 ftp，所以这里我直接在搜索框中搜 ftp 就能抓取所有协议是ftp的网络包了</p>
<p><img src="/2021/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1/11.png" style="zoom:100%;"></p>
<h2 id="进阶任务1"><a href="#进阶任务1" class="headerlink" title="进阶任务1"></a>进阶任务1</h2><p>Java项目：任意构造两个类，两个类分别具有不同的属性和操作，并分别实例化一个对象，完成任意操作。</p>
<p>Main class:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner =<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">"请输入要加法还是减法,加法输入1,减法输入0: "</span>);</span><br><span class="line">        <span class="keyword">byte</span> flag = scanner.nextByte();</span><br><span class="line">        Plus pluscal = <span class="keyword">new</span> Plus();</span><br><span class="line">        Minus minuscal = <span class="keyword">new</span> Minus();</span><br><span class="line">        System.out.print(<span class="string">"请输入两个待操作的数: "</span>);</span><br><span class="line">        <span class="keyword">double</span> number1 = scanner.nextDouble();</span><br><span class="line">        <span class="keyword">double</span> number2 = scanner.nextDouble();</span><br><span class="line">        <span class="keyword">double</span> result;</span><br><span class="line">        <span class="keyword">switch</span> (flag)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                result = pluscal.plus(number1,number2);</span><br><span class="line">                System.out.println(<span class="string">"结果为: "</span>+result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                result = minuscal.minus(number1,number2);</span><br><span class="line">                System.out.println(<span class="string">"结果为: "</span>+result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">"输入错误，程序结束！"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>class1： Plus calculator</p>
<p>这个类实现的功能很简单，就是返回两个数字相加</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plus</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> number1=<span class="number">0</span>,number2=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">plus</span><span class="params">(<span class="keyword">double</span> number1,<span class="keyword">double</span> number2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number1+number2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>class2:  Minor calculator</p>
<p>同理，这个类就是返回两个数字相减</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minus</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> number1=<span class="number">0</span>,number2=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">minus</span><span class="params">(<span class="keyword">double</span> number1,<span class="keyword">double</span> number2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number1-number2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实验结果："><a href="#实验结果：" class="headerlink" title="实验结果："></a>实验结果：</h3><p><img src="/2021/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1/3.png" style="zoom:100%;"></p>
<h3 id="实验感悟"><a href="#实验感悟" class="headerlink" title="实验感悟"></a>实验感悟</h3><p>这几个类设计的非常简单，但是却让我了解了Java文件的运行模式：它是一门面向对象的语言。因此我们可以通过实现一系列操作降低代码的耦合度。 Idea提供了很方便的快捷指令将写在 Main函数当中的方法独立抽象出来生成一个类。这一方法在我的博客中有详细说明。<a href="https://jasonxqh.github.io/2020/07/05/Java基础2/#Extracting-the-Console-Class">Extracting the Class</a></p>
<h2 id="进阶任务2"><a href="#进阶任务2" class="headerlink" title="进阶任务2"></a>进阶任务2</h2><p>安装发包软件（自己寻找），发送不同协议的网络包，并用 <strong>wireshark</strong> 抓取。 </p>
<p>这里我使用 Xcap 软件来作为发包工具。下载地址： <a href="http://xcap.weebly.com/" target="_blank" rel="noopener">http://xcap.weebly.com/</a></p>
<p><img src="/2021/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1/15.png" style="zoom: 67%;"></p>
<p>首先我们要选择打开的接口，然后往这个接口发送数据包。因为Wireshark中若选择 WLAN，会有很多干扰。很难找到xcap发出的数据包。因此这里我选择 本地连接10做为接口。</p>
<p>紧接着，我们在 Packet group中新建一个报文组。</p>
<p><img src="/2021/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1/16.png" style="zoom: 100%;"></p>
<p>这里，我已经将一些数据包保存为一个 .pcap 文件，我们只需要点击 Read from .pcap file 这个选项，从里面选择我们要发送的不同协议的数据包即可。</p>
<p><img src="/2021/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1/17.png" style="zoom:120%;"></p>
<p><img src="/2021/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1/18.png" style="zoom:120%;"></p>
<p>紧接着，我们将接口选择刚才已经打开的 Interface2，结果如下：</p>
<p><img src="/2021/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1/19.png" style="zoom:120%;"></p>
<p>然后我们打开 Wireshark, 选择本地连接10，并选中我们要发送的几种数据包：</p>
<p><img src="/2021/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1/20.png"></p>
<p>然后，我们在本地连接10 成功收到了 xcap发出的五种不同协议的数据包。实验结果让人满意</p>
<p><img src="/2021/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1/21.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/03/03/%E6%A6%82%E7%8E%87%E8%AE%BA-%E6%A0%B7%E6%9C%AC%E7%A9%BA%E9%97%B4%E5%92%8C%E6%A6%82%E7%8E%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/03/%E6%A6%82%E7%8E%87%E8%AE%BA-%E6%A0%B7%E6%9C%AC%E7%A9%BA%E9%97%B4%E5%92%8C%E6%A6%82%E7%8E%87/" class="post-title-link" itemprop="url">概率论-样本空间和概率</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-03 16:22:25" itemprop="dateCreated datePublished" datetime="2021-03-03T16:22:25+08:00">2021-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-05 23:45:12" itemprop="dateModified" datetime="2021-04-05T23:45:12+08:00">2021-04-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="样本空间和概率"><a href="#样本空间和概率" class="headerlink" title="样本空间和概率"></a>样本空间和概率</h1><p>参考书本：</p>
<ul>
<li>概率导论  第二版 Bertsekas 著</li>
<li>概率论与数理统计教程 第三版 峁时松 等著</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="可数集与不可数集"><a href="#可数集与不可数集" class="headerlink" title="可数集与不可数集"></a>可数集与不可数集</h3><p>集合按照可不可数可以分成两大类： 可数集与不可数集</p>
<p>如果 S 中的元素有限且可数，那么我们可以这样写： $S={x_1,x_2,\cdots,x_n}$</p>
<p>如果 S中的元素是无限的，但是它们是可以被枚举的(每个元素都能与然数集N的每个元素之间能建立一一对应的) ，我们可以将其写成：</p>
<p>$S={x_1,x_2,\cdots}$ 我们称其为 <strong>countably infinite</strong> (无限可数集). 比如说 ${0,2,-2,4,-4,\cdots}$</p>
<p>如果集合是这样被标示的： ${x|0\leq x \leq 1}$ ，那么 x 是连续的，不能被一一列举。因此我们称这样的集合为 uncountable (不可数集)</p>
<h3 id="集合的操作"><a href="#集合的操作" class="headerlink" title="集合的操作"></a>集合的操作</h3><p>有一个集合S， 全集为 $\Omega$ , 那么称集合 S 的补集为 $S^c$ </p>
<p>集合的交 : $S \cup T ={x|x\in S <del>or</del> x\in T}$</p>
<p>集合的并：$S\cap T = {x\in S <del>and</del> S\in T}$</p>
<h3 id="集合的代数"><a href="#集合的代数" class="headerlink" title="集合的代数"></a>集合的代数</h3><p>详见： <a href="https://jasonxqh.github.io/2020/09/03/离散数学之集合与函数/#Logical-equivalence"> Logical equivalence</a></p>
<p>德摩根律的一般形式需要牢记： </p>
<p><img src="/2021/03/03/%E6%A6%82%E7%8E%87%E8%AE%BA-%E6%A0%B7%E6%9C%AC%E7%A9%BA%E9%97%B4%E5%92%8C%E6%A6%82%E7%8E%87/1.png"></p>
<h2 id="概率模型"><a href="#概率模型" class="headerlink" title="概率模型"></a>概率模型</h2><h3 id="基本构成"><a href="#基本构成" class="headerlink" title="基本构成"></a>基本构成</h3><ul>
<li><strong>样本空间 </strong> $\Omega$ ,这是一个试验的所有可能结果的集合</li>
<li><strong>概率律</strong> ， 概率律为试验结果的集合A(称之为事件) 确定一个非负数 $P(A)$ </li>
</ul>
<h3 id="样本空间"><a href="#样本空间" class="headerlink" title="样本空间"></a>样本空间</h3><p>每一个<strong>概率模型</strong> 都关联着一个 <strong>试验</strong> ，这个试验将产生<strong>一个试验结果</strong>。 该实验的所有可能结果就形成了 <strong>样本空间</strong>。 需要注意：我们所讨论的概率模型的问题中，只设计一个试验，所以连续抛掷三次硬币只能作为一次试验，而不能认为是三次试验。其样本空间就是 {HHH,HHT,…, TTT} </p>
<p>样本空间可由若干个实验结果组成(如上面的硬币试验) ，也可以由无限多个试验结果组成。 例如：往一个方形目标上投掷飞镖，可将每个可能的弹着点作为试验的结果。</p>
<p>选择适当的样本空间在研究概率时十分重要。不同的实验结果必须是相互排斥的，这样在试验过程中只可能产生唯一的一个结果。 比如说：当试验是投掷一枚骰子的时候，不能把 “1 或者 3” 、“1或者4” 同时定义成一个结果，否则当骰子为1的时候，就不知道得到的是什么结果了</p>
<p>我们可以看两个游戏，并分别确定其样本空间：</p>
<p><strong>游戏1</strong> ： 每次抛掷硬币的时候，子要出现正面向上，我们就可以赢得1元钱</p>
<p><strong>游戏2：</strong>  在抛掷硬币的过程当中，直到出现第一次正面向上(含正面向上的那一次)，以前的每次抛掷我们都可以赢1元钱(若10次抛掷都是正面向下，我们赢得10元)。若出现第一次正面向上以后还有机会抛掷硬币，则以后每次抛掷硬币的时候我们都可以赢2元钱，一直到第二次出现正面向上为止。 每次抛掷的到正面向上的时候，就翻倍。1，2，4…</p>
<p>那么在游戏1中，我们赢的钱数只与10次抛掷中正面向上的次数有关，因此，样本空间可由 11个(即0,1,2,…10) 试验结果组成，而在游戏2中，我们赢得的钱数不仅与正面出现的次数有关，也和正反面出现的顺序有关。因此，可能出现 $2^{10}$ 种可能，样本空间由所有长度为10的正反序列组成。</p>
<h3 id="随机事件"><a href="#随机事件" class="headerlink" title="随机事件"></a>随机事件</h3><p>随机现象的某些样本点组成的集合称为<strong>随机事件</strong>，简称<strong>事件</strong>。如在掷一颗骰子中， A=“出现奇数点” 是一个事件，即 $A={1,3,5}$ ,它是相应样本空间 $\Omega = {1,2,3,4,5,6}$ </p>
<ol>
<li>任一事件A是相应样本空间的一个子集。 在概率论中常常用韦恩图来表示</li>
<li>当子集中某个样本点出现了，就说事件A发生了。这是充分必要条件</li>
<li>事件可以用集合表示，也可以用明白无误的语言描述</li>
<li>由样本空间 $\Omega$ 中的<strong>单个</strong>元素组成的子集称为 <strong>基本事件</strong> 。 而样本空间 $\Omega$ 的<strong>最大子集(即$\Omega$本身)</strong> 称为<strong>必然事件</strong>。样本空间 $\Omega$ 的<strong>最小子集(即空集$\empty$) </strong> 称为<strong>不可能事件</strong></li>
</ol>
<h3 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h3><p>用来表示随机现象结果的变量称为<strong>随机变量</strong> ，常用X，Y，Z 表示。很多事件都可以用随机变量表示，表示时应该写明随机变量的含义。</p>
<p>比如说投掷一颗骰子，可能出现1，2，3，4，5，6；若设置 $X=$ “掷一颗骰子出现的点数”， 则1，2，3，4，5，6就是随机变量X的可能取值。这时：</p>
<ul>
<li>事件”出现3点”可用 “X=3” 表示</li>
<li>“$X\leq$6” 是必然事件$\Omega$ </li>
</ul>
<p>现在我再设 $Y=$”掷一颗骰子6点出现的次数”，则 Y 是仅取0或者1 两个值的随机变量。这时</p>
<ul>
<li>“$Y=0$” 表示事件 “没有出现6点”</li>
<li>“$Y\geq2$” 是不可能事件</li>
</ul>
<p>因此，在同一个随机现象当中，不同的设置可以获得不同的随机变量。</p>
<h3 id="事件间的关系"><a href="#事件间的关系" class="headerlink" title="事件间的关系"></a>事件间的关系</h3><h4 id="包含关系"><a href="#包含关系" class="headerlink" title="包含关系"></a>包含关系</h4><p>如果属于A的样本点必属于B，则称A被包含在B中，或称B包含A. 记为 $A\subset B$  <strong>事件A发生必然导致事件B发生</strong></p>
<p>比如说掷一个骰子，事件 $A=$ “出现4点” 的发生必然导致事件 $B=$ “出现偶数点”的发生。</p>
<h4 id="相等关系"><a href="#相等关系" class="headerlink" title="相等关系"></a>相等关系</h4><p>如果属于A的样本点必属于B，且属于B的样本点必属于A，即 $A\subset B$ 且$B\subset A$ ,则称 事件A与B，记为 $A=B$ </p>
<p>掷两颗骰子，以A记事件 ”两颗骰子的点数之和为奇数“，以B记事件”两颗骰子的点数为一奇一偶“ </p>
<h3 id="互不相容"><a href="#互不相容" class="headerlink" title="互不相容"></a>互不相容</h3><p>如果A与B没有相同的样本点，则称A与B互不相容。<strong>A与B互不相容就是事件A与事件B不可能同时发生</strong> </p>
<h3 id="事件间的运算"><a href="#事件间的运算" class="headerlink" title="事件间的运算"></a>事件间的运算</h3><h4 id="事件A与B的并"><a href="#事件A与B的并" class="headerlink" title="事件A与B的并"></a>事件A与B的并</h4><h4 id="事件A与B的交"><a href="#事件A与B的交" class="headerlink" title="事件A与B的交"></a>事件A与B的交</h4><h4 id="事件A与B的差"><a href="#事件A与B的差" class="headerlink" title="事件A与B的差"></a>事件A与B的差</h4><h3 id="离散模型"><a href="#离散模型" class="headerlink" title="离散模型"></a>离散模型</h3><p><strong>离散概率律</strong>： 设样本空间由有限个可能的结果组成，则事件的概率可由组成这个事件的试验结果的概所决定，事件$P{s_1,s_2,\dots,s_n}=P(s_1)+P(s_2)+\cdots+P(s_n)$ </p>
<p>现在假设样本空间 $\Omega={s_1,s_2,\cdots,s_n}$ ，并且每个实验结果都是等概率的。 利用归一化公理可知  $P(s_i) = 1/n,i = 1,2,\cdots , n$ ,我们得到：</p>
<p>离散均匀概率律(古典概型)：设样本空间由n个等可能性的实验结果组成，因此每个实验结果组成的事件(被称为基本事件)的概率是相等的，由此得到：</p>
<p>$P(A)=\frac{含于事件A的试验结果数}n$ </p>
<p>例子：考虑<strong>连续两次</strong>转动一个有 4 个边的骰子(放在桌子上转动)。 那么一共有16种可能的实验结果。这16种 每种出现的概率为 1/16 .<br>这是一个古典概型，在计算一个事件的概率的时候必须清楚这个事件所包含的试验结果数(基本事件数)， 将这个结果除以16便得到这个事件的概率。<br>比如说: $P({两次点数总和为偶数}) = 8/16 = 1/2$</p>
<p>$P({第一次点数和第二次点数相同}) = 4/16 = 1/4$</p>
<p>$P({至少有一次转动的点数等于4}) = 7/16$</p>
<h3 id="连续模型"><a href="#连续模型" class="headerlink" title="连续模型"></a>连续模型</h3><p>A和B约定在某个时刻见面，而每个人到达约会地点的事件都会有延迟，延迟事件在0~1 小时。 第一个到达约会地点的人在哪儿等待15分钟，等了15分钟后若对方还没有到达约会地点，先到的人会离开约会地点。请问它们能够相会的概率有多大？</p>
<p>我们可以把这个问题抽象成一个单位正方形 $\Omega = [0,1]\times[0,1]$ 正方形中的每个点的两个坐标分别代表它们可能的延迟时间。 每个点都可以是他们的延迟时间且是等可能的。因此，我们可以将 $\Omega$ 的子集出现的概率定义为这个子集 的面积。 这个概率律满足概率的3条公里。 罗密欧和朱丽叶能够相会的时间可用这张图表示：</p>
<p><img src="/2021/03/03/%E6%A6%82%E7%8E%87%E8%AE%BA-%E6%A0%B7%E6%9C%AC%E7%A9%BA%E9%97%B4%E5%92%8C%E6%A6%82%E7%8E%87/2.png"></p>
<p>答案为： $\frac{7}{16}$ </p>
<h3 id="事件域"><a href="#事件域" class="headerlink" title="事件域"></a>事件域</h3><p>首先我们定义一下事件域：</p>
<p>设 $\Omega$ 为一样本空格键， $\mathcal F$ 为  $\Omega$ 的某些子集所组成的集合类。如果 $\mathcal F$  满足：</p>
<ol>
<li>$\Omega \in\mathcal F$</li>
<li>若 $A\in \mathcal F$, 则 $\overline A\in \mathcal F$ </li>
<li>若 $A<em>1,A_2\cdots A_n\cdots \in \mathcal F$ ,   $\bigcup</em>{i=1}^\infty A_i \in \mathcal F$ </li>
</ol>
<p>则称 $\mathcal F$ 为一个事件域，或者 $\sigma$ 域</p>
<p>例：</p>
<ol>
<li>若样本空间只含两个样本点 $\Omega={\omega_1,\omega_2}$ ,记 $A={\omega_1},\overline A = {w_2}$ ,其事件域为 $\mathcal F = {\emptyset,A,\overline A,\Omega}$</li>
<li>若样本空间含有n个样本点$\Omega={\omega_1,\omega_2\cdots,\omega_n}$ 其事件域 $\mathcal F$ 是由空集 $\emptyset$ 、n个单元素集， $\begin{pmatrix} n \ 2 \end{pmatrix}$ 个双元素集、$\begin{pmatrix} n \ 3 \end{pmatrix}$ 个三元素集……和$\Omega$组成的集合类，这时 $\mathcal F$ 中共有 $\begin{pmatrix} n \ 0 \end{pmatrix}+\begin{pmatrix} n \ 1 \end{pmatrix}+\cdots+\begin{pmatrix} n \ n \end{pmatrix}=2^n$ 个事件。 </li>
</ol>
<h1 id="概率的定义及其性质"><a href="#概率的定义及其性质" class="headerlink" title="概率的定义及其性质"></a>概率的定义及其性质</h1><h3 id="概率的定义："><a href="#概率的定义：" class="headerlink" title="概率的定义："></a>概率的定义：</h3><p>设 $\Omega$ 是一个样本空间，$\mathcal F$ 为 $\Omega$ 的某些子集组成的一个事件域。如果对任意事件 $A\in\mathcal F$ 定义在 $\mathcal F$ 上的一个实质函数 $P(A)$ 满足：</p>
<p>1） 非负性公理： 若 $A\in \mathcal F$ ,则 $P(A)\geq 0$ ;</p>
<p>2） 正则性公理：$P(\Omega)=1$</p>
<p>3） 可列可加性公理： 若 $A<em>1,A_2,\cdots, A_n,\cdots$互不相容，则： $P(\bigcup</em>{i=1}^\infty A<em>i) = \sum</em>{i=1}^{\infty} P(A_i)$  </p>
<p>则称 P(A) 为事件 A的概率， 称三元素  $(\Omega ,\mathcal F,P)$ 为概率空间。</p>
<h2 id="概率的性质："><a href="#概率的性质：" class="headerlink" title="概率的性质："></a>概率的性质：</h2><h3 id="概率的可加性"><a href="#概率的可加性" class="headerlink" title="概率的可加性"></a>概率的可加性</h3><h4 id="有限可加性"><a href="#有限可加性" class="headerlink" title="有限可加性"></a>有限可加性</h4><p>若有限个事件 $A<em>1,A_2,\cdots,A_n$ 互不相容，则有 $P(\bigcup</em>{i=1}^n A<em>i) = \sum</em>{i=1}^{n}P(A_1)$  注意了，可列可加性和有限可加性是不同的。</p>
<p>由于有限可加性，我们就可以得到以下求对立事件概率的公式：对任一事件 A, $P(\overline A) =1-P(A)$ </p>
<h3 id="概率的单调性"><a href="#概率的单调性" class="headerlink" title="概率的单调性"></a>概率的单调性</h3><h4 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h4><p>若 $A\supset B$ ,则 $P(A-B)=P(A)-P(B)$</p>
<p>进而可以推出： 若$A\supset B$， 则 $P(A)\geq P(B)$ </p>
<h4 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h4><p>对任意两个事件 A,B, 有 $P(A-B)=P(A)-P(AB)$ </p>
<h3 id="概率的加法公式"><a href="#概率的加法公式" class="headerlink" title="概率的加法公式"></a>概率的加法公式</h3><h4 id="性质1-1"><a href="#性质1-1" class="headerlink" title="性质1"></a>性质1</h4><p>对任意的两个事件A，B 有 $P(A\cup B)=P(A)+P(B)-P(AB)$ </p>
<p>对任意n个事件 $A<em>1,A_2,\cdots,A_n$ ，有 $P(\bigcup</em>{i=1}^n A<em>i)= \sum</em>{i=1}^n P(A<em>i)-\sum</em>{1\leq i&lt;j\leq n} P(A<em>iA_j)+\sum</em>{1\leq i&lt;j&lt;k\leq n}P(A_iA_jA_k)+\cdots+(-1)^{n-1}P(A_1A_2\cdots A_n)$</p>
<p>据此，可以推出 半可加性, 对任意两个事件 A,B 有</p>
<p>$P(A\cup B)\leq P(A)+P(B)$ </p>
<p>对任意n个事件  $A<em>1\cdots A_n$ ,有 $P(\cup</em>{i=1}^n)\leq \sum_{i=1}^n P(A_i)$ </p>
<h3 id="概率的连续性"><a href="#概率的连续性" class="headerlink" title="概率的连续性"></a>概率的连续性</h3><p>首先我们给出两个定义： 极限事件和上下连续</p>
<h4 id="极限事件"><a href="#极限事件" class="headerlink" title="极限事件"></a>极限事件</h4><ol>
<li>对 $\mathcal F$ 中任一<strong>单调不减</strong>的事件序列 $F<em>1\subset F_2\subset \cdots \subset F_n\subset \cdots$ ，称<strong>可列并</strong>  $\bigcup</em>{n=1}^\infty F<em>n$  为 ${F_n}$ 的极限事件，记为   $\lim\limits</em>{n\rightarrow \infty} F<em>n= \bigcup</em>{n=1}^\infty F_n$ </li>
<li>对 $\mathcal F$ 中任一<strong>单调不增</strong> 的事件序列 $E<em>1\supset E_2\supset \cdots\supset E_n\supset \cdots$ ,称<strong>可列交</strong> $\bigcap</em>{n=1}^\infty E<em>n$ 为 ${E_n}$ 的极限事件，记为 $\lim\limits</em>{n\rightarrow \infty} E<em>n=\bigcap</em>{n=1}^\infty E_n$</li>
</ol>
<h4 id="上下连续"><a href="#上下连续" class="headerlink" title="上下连续"></a>上下连续</h4><p>对 $\mathcal F$ 上的一个概率 P</p>
<ol>
<li>若它对$\mathcal F$ 中任一单调不减的时间序列 ${F<em>n}$  均成立 $\lim\limits</em>{n\rightarrow \infty}P(F<em>n)=P(\lim\limits</em>{n\rightarrow \infty } F_n)$ 则称概率P是<strong>下连续</strong>的</li>
<li>若它对$\mathcal F$ 中任一单调不增的时间序列 ${E<em>n}$  均成立 $\lim\limits</em>{n\rightarrow \infty}P(E<em>n)=P(\lim\limits</em>{n\rightarrow \infty } E_n)$ 则称概率P是<strong>上连续</strong>的</li>
</ol>
<h4 id="概率的连续性定义："><a href="#概率的连续性定义：" class="headerlink" title="概率的连续性定义："></a>概率的连续性定义：</h4><p>若 P 为 事件域 $\mathcal F$ 上的概率，则 P 既是下连续的，又是上连续的。(证明见书本 Prob&amp;Stat P34)</p>
<h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><h3 id="条件概率的定义"><a href="#条件概率的定义" class="headerlink" title="条件概率的定义"></a>条件概率的定义</h3><p>设 A与B 是严格不能空间 $\Omega$ 中的两事件，若 $P(B)&gt;0$, 则称 $P(A|B)=\frac{P(AB)}{P(B)}$ 为 “<strong>在B发生下A的条件概率</strong>“，简称<strong>条件概率</strong></p>
<p>要注意，条件概率也是概率，也满足概率的三个定义：</p>
<ol>
<li>非负性：  $A\in \mathcal F$ ,则 $P(A|B)\geq 0$ ;</li>
<li>归一性： $P(\Omega|B)=1$</li>
<li>可列可加性：$A<em>1,A_2,\cdots,A_n,\cdots$互不相容， 则 $P(\bigcup</em>{n=1}^\infty A<em>n|B)=\sum</em>{n=1}^\infty P(A_n|B)$ </li>
</ol>
<h3 id="乘法公式"><a href="#乘法公式" class="headerlink" title="乘法公式"></a>乘法公式</h3><p><strong>公式</strong></p>
<ol>
<li>如果 $P(B)&gt;0$ 则 $P(AB)=P(B)P(A|B)$ </li>
<li>进而可推出 若 $P(A<em>1A_2\cdots A</em>{n-1})&gt;0$ ,则 $P(A<em>1A_2\cdots A_n)=P(A_1)P(A_2|A_1)P(A_3|A_1A_2)\cdots P(A_n|A_1A_2\cdots A</em>{n-1})$</li>
</ol>
<h4 id="罐子模型"><a href="#罐子模型" class="headerlink" title="罐子模型"></a>罐子模型</h4><h3 id="全概率公式"><a href="#全概率公式" class="headerlink" title="全概率公式"></a>全概率公式</h3><p><strong>公式</strong>：设 $B<em>1,B_2,\cdots ,B_n$ 为样本空间$\Omega$ 的一个分割，,如果 $P(B_i)&gt;0,i=1,2,\cdots ,n$ 则对事件 A有 : $P(A)=\sum</em>{i=1}^n P(B_i)P(A|B_i)$ </p>
<p>对于全概率公式，我们要注意：</p>
<ol>
<li>全概率公式的最简单形式 假如 $0&lt;P(B)&lt;1$ 则 $P(A)=P(B)P(A|B)+P(\overline B)P(A|\overline B)$ </li>
<li>将条件从分割改为 $B_1,B_2,\cdots,B_n$ 互不相容， 全概率公式仍然成立</li>
<li>对可列个事件 $B<em>1,B_2,\cdots,B_n\cdots $互不相容，且 $A\subset \bigcup</em>{i=1}^n B_i$ 则全概率公式仍成立，只要将右边改成可列向项之和即可。</li>
</ol>
<h3 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h3><p>贝叶斯公式是在乘法公式和全概率公式的基础上推导而来</p>
<p><strong>公式</strong>： 设 $B_1,B_2\cdots ,B_n$是样本空间 $\Omega$ 的一个分割，如果 $P(A)&gt;0,P(B_i)&gt;0, ~i =1,2,\cdots,n$   则：</p>
<p>$P(B<em>i|A)=\frac{P(B_i)P(A|B_i)}{\sum</em>{j=1}^n P(B_j)P(A|B_j)}$ </p>
<h2 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h2><h3 id="两个事件的独立性"><a href="#两个事件的独立性" class="headerlink" title="两个事件的独立性"></a>两个事件的独立性</h3><p>若 $P(AB)=P(A)P(B)$  成立，最称事件 A与 B相互独立，简称 A与B 独立。否则称A与B不独立或相依</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>若事件 $A$与$B$ 独立，则$ A$与 $\overline B$ 独立 ,$\overline A$与 $B$ 独立， $\overline A$与 $\overline B$ 独立。注意：<strong>相互独立事件又不是互斥事件，本来就可以同时发生的</strong></p>
<p>两个事件不可能既互斥又相互独立。</p>
<p>相互独立的事件之间没有影响，事件A的发生当然不会影响事件B的发生，两个事情是否同时发生都是有可能的。</p>
<p>互斥的事件当然不是独立的，因为一件事情的发生已经影响到了另外一件事的发生了。</p>
<h3 id="多个事件的相互独立性"><a href="#多个事件的相互独立性" class="headerlink" title="多个事件的相互独立性"></a>多个事件的相互独立性</h3><h4 id="两两独立"><a href="#两两独立" class="headerlink" title="两两独立"></a>两两独立</h4><p>设 A,B,C 是三个事件， 如果有：</p>
<p>$\begin{cases}P\left( AB\right) =P\left( A\right) P\left( B\right) \ P\left( AC\right) =P(A)P\left( C\right) \ P\left( BC\right) =P(B)P\left( C\right) \end{cases}$</p>
<p>则称 $A,B,C$ 两两独立。</p>
<h4 id="相互独立"><a href="#相互独立" class="headerlink" title="相互独立"></a>相互独立</h4><p><strong>若还有：</strong> $P(ABC)=P(A)P(B)P(C)$ 则称 A,B,C 相互独立。</p>
<p>要注意，两两独立不一定推出相互独立，相互独立也不一定能推出两两独立。</p>
<p>化简到一般形式：$\begin{cases}P\left( A<em>{i}Aj\right) =P\left( A</em>{i}\right) P\left( Ai\right) \ P\left( A<em>{i}A</em>{j}A<em>{k}\right) =P\left( A</em>{i}\right) P(A<em>j)P\left( A_n\right) \ \ldots \ldots \ P\left( A_1A</em>{2}\ldots A<em>{n}\right) =P(A_1)\cdot P\left( A</em>{2}\right) \ldots P(A_{n}) \end{cases}$</p>
<p>则称此 n个事件 $A_1,A_2,\cdots, A_n$ 相互独立。</p>
<h1 id="实战注意点："><a href="#实战注意点：" class="headerlink" title="实战注意点："></a>实战注意点：</h1><ol>
<li>互不相容 可以简化<strong>事件并的概率</strong>计算，相互独立 可以简化<strong>事件交的概率计算</strong>。 主要表现为：若事件 A、B、C互不相容，那么$P(A\cup B\cup C)=P(A)+P(B)+P(C)$ ； 若事件A、B、C 相互独立，那么 <code>P(ABC)=P(A)P(B)P(C)</code> </li>
<li>运用对偶法，可以把事件并转化成事件交。</li>
</ol>
<p>对偶律： $(A\cup B)^c = A^c\cap B^c$ , $(A\cap B)^c = A^c\cup B^c$ </p>
<p><strong>右上角C表示此集合的补集</strong></p>
<p>语言描述：<br>①A并B的补集 = A的补集交B的补集<br>②A交B的补集 = A的补集并B的补集</p>
<p>例题： 三个人独立地破译一个密码，它们能单独破译密码的概率分别是 $1/5,1/3,1/4$ 求密码被破译的概率</p>
<p>$P(B)=P(A_1\cup A_2\cup A_3)= P(A_1^c)\cap$ </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2-shell%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2-shell%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">os实验报告2-shell的实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-02 21:09:03" itemprop="dateCreated datePublished" datetime="2021-03-02T21:09:03+08:00">2021-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 13:41:44" itemprop="dateModified" datetime="2021-03-25T13:41:44+08:00">2021-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Shell-在-Minix3中的实现"><a href="#Shell-在-Minix3中的实现" class="headerlink" title="Shell 在 Minix3中的实现"></a>Shell 在 Minix3中的实现</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>Shell主体结构是一个while循环，不断地接受用户键盘输入行并给出反馈。Shell 将输入行分解成单词序列，根据命令名称分为<strong>二类分别处理 </strong>，即<strong>shell内置命令</strong>（例如cd，history，exit）和 <strong>program 命令</strong> (例如/bin/目录下的ls，grep 等) 。识别为shell内置命令后，执行对应操作。接受program命令后，利用minix自带的程序创建一个或多个新进程，并等待进程结束。如果末尾<strong>包含&amp;参数</strong>，Shell可以不等待进程结束，直接返回。</p>
<h3 id="Program命令"><a href="#Program命令" class="headerlink" title="Program命令"></a>Program命令</h3><p>运行程序：利用fork调用创建进行子进程，利用execvp调用将minix程序装载到该进程，并赋予运行参数，最后Shell利用wait/waitpid调用等待子进程结束。（参见UNIX高级编程8.3，8.7和8.10节）</p>
<p>参考资料：</p>
<ol>
<li>Shell主要是为用户提供一个命令解释器，接收用户命令（如ls等)，然后调用相应的应用程序。实现的Shell支持后台进程的运行。</li>
<li>在计算内存和CPU总体使用情况时，可参考top命令实现 <a href="https://github.com/0xffea/MINIX3/blob/master/usr.bin/top/top.c" target="_blank" rel="noopener">https://github.com/0xffea/MINIX3/blob/master/usr.bin/top/top.c</a></li>
<li>推荐《UNIX环境高级编程》查找详细的系统调用使用方法。</li>
</ol>
<h4 id="1-实现带参数的程序运行功能"><a href="#1-实现带参数的程序运行功能" class="headerlink" title="1.实现带参数的程序运行功能"></a>1.实现带参数的程序运行功能</h4><p><code>program arg1 arg2 ... argN</code></p>
<h4 id="2-重定向功能，-将文件作为程序的输入-输出"><a href="#2-重定向功能，-将文件作为程序的输入-输出" class="headerlink" title="2. 重定向功能， 将文件作为程序的输入/输出"></a>2. 重定向功能， 将文件作为程序的输入/输出</h4><ul>
<li>“&gt;” 表示覆盖写 <code>program arg1 arg2 … argN &gt; output-file</code></li>
<li>“&gt;&gt;” 表示追加写 <code>program arg1 arg2 … argN &gt;&gt; output-file</code></li>
<li>“&lt;” 表示文件的输入 <code>program arg1 arg2 … argN &lt; input-file</code></li>
</ul>
<p>重定向：minix为每个进程赋予键盘输入和控制台输出的文件描述符默认为0和1。子进程装载程序前，利用close(0 or 1)将默认输入或者输出关闭，再调用dup(fd)将某个打开文件的文件描述fd映射到标准输入或输出。（参见UNIX高级编程3.12节）</p>
<h4 id="3-管道符号-“-”"><a href="#3-管道符号-“-”" class="headerlink" title="3. 管道符号 “|”"></a>3. 管道符号 “|”</h4><p>在程序间传递数据  <code>programA arg1 … argN | programB arg1 … argN</code></p>
<p>若有n个子进程组成管道流，Shell在fork前先用pipe调用创建n-1对管道描述符，关闭不需要的读写端。Shell运行fork后，每个子进程利用dup将前一个管道的读端映射到标准输入，后一个管道的写端映射到标准输出。（参见UNIX高级编程15.2节）</p>
<p><strong>在实现管道时，需要用到pipe和dup系统调用等，重定向标准向输入输出(参见教材1.4.3节)。</strong></p>
<h4 id="4-后台符号-amp"><a href="#4-后台符号-amp" class="headerlink" title="4. 后台符号&amp;"></a>4. 后台符号&amp;</h4><p>表示此命令将以后台运行的方式执行 <code>program arg1 arg2 … argN &amp;</code></p>
<p>后台运行：为了屏蔽键盘和控制台，子进程的标准输入、输出映射成/dev/null。子进程调用signal(SIGCHLD,SIG_IGN)，使得minix接管此进程。因此Shell可以避免调用wait/waitpid直接运行下一条命令。</p>
<h3 id="Shell-内置命令"><a href="#Shell-内置命令" class="headerlink" title="Shell 内置命令"></a>Shell 内置命令</h3><h4 id="1-工作路劲移动命令-cd"><a href="#1-工作路劲移动命令-cd" class="headerlink" title="1. 工作路劲移动命令 cd"></a>1. 工作路劲移动命令 cd</h4><p>提示： 因为Shell也是一个程序，启动时minix会分配一个当前工作目录，利用chdir系统调用可以移动Shell的工作目录。</p>
<h4 id="2-程序运行统计mytop"><a href="#2-程序运行统计mytop" class="headerlink" title="2. 程序运行统计mytop"></a>2. 程序运行统计mytop</h4><p>提示：参考minix终端输入top命令的输出信息，在minix系统/proc文件夹中通过open/read系统调用输出进程信息。</p>
<ul>
<li>/proc/meminfo中，查看<strong>内存信息</strong>，每个参数对应含义依次是<strong>页面大小pagesize</strong>，<strong>总页数量total </strong>，<strong>空闲页数量free</strong> ，<strong>最大页数量largest</strong> ，<strong>缓存页数量cached</strong>。可计算内存大小：$(pagesize ~*~total)/1024$，同理算出其他页内存大小。</li>
<li>/proc/kinfo中，查看<strong>进程和任务数量</strong>。</li>
<li>/proc/pid/psinfo中，例如/proc/107/psinfo文件中，查看pid为107的进程信息。每个参数对应含义依次是：<strong>版本version</strong>，<strong>类型type</strong>，<strong>端点endpt</strong>，<strong>名字name</strong>，<strong>状态state</strong>，<strong>阻塞状态blocked</strong>，<strong>动态优先级priority，滴答ticks，高周期highcycle，低周期lowcycle，内存memory，有效用户ID effuid，静态优先级nice等</strong>。其中会用到的参数有：类型，状态，滴答。进程时间$time=\frac{ticks}{(u32_t)60}$。</li>
</ul>
<p>输出内容：</p>
<ul>
<li><strong>总体内存大小，空闲内存大小，缓存大小</strong>。</li>
<li><strong>总体CPU使用占比</strong>。计算方法：得到进程和任务总数量total_proc，对每一个proc的ticks累加得到总体ticks，再计算空闲的ticks，最终可得到CPU使用百分比。</li>
</ul>
<h4 id="3-shell-退出命令-exit"><a href="#3-shell-退出命令-exit" class="headerlink" title="3. shell 退出命令 exit"></a>3. shell 退出命令 exit</h4><p>提示:  退出Shell的while循环，结束Shell的main函数。</p>
<h4 id="4-history-n-显示最近执行的n条指令"><a href="#4-history-n-显示最近执行的n条指令" class="headerlink" title="4. history n 显示最近执行的n条指令"></a>4. history n 显示最近执行的n条指令</h4><p>提示： 保存Shell每次的输入行，打印所需字符串即可</p>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;your&#x2F;path</span><br><span class="line">ls -a -l</span><br><span class="line">ls -a -l &gt; result.txt</span><br><span class="line">vi result.txt</span><br><span class="line">grep a &lt; result.txt</span><br><span class="line">ls -a -l | grep a</span><br><span class="line">vi result.txt &amp;</span><br><span class="line">mytop</span><br><span class="line">history n</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<h2 id="内容与设计思想"><a href="#内容与设计思想" class="headerlink" title="内容与设计思想"></a>内容与设计思想</h2><p>这个实验主要是在Minix里面自己实现一个简单的shell，并实现一些基本的命令。</p>
<p>我会将整个project分割成很多小片段来一一实现。</p>
<h2 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h2><p>虚拟机： Guest OS</p>
<p>虚拟机软件： Oracle VirtualBox</p>
<p>物理机： Windows10</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>首先我们先介绍一下 main函数的实现思路，然后再详细分析main函数中调用的各种函数</p>
<h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PATH_PROC <span class="meta-string">"/proc/"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSINFO_VERSION	0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_TASK	<span class="meta-string">'T'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_SYSTEM	<span class="meta-string">'S'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_USER	<span class="meta-string">'U'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATE_RUN	<span class="meta-string">'R'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMECYCLEKEY <span class="meta-string">'t'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ORDERKEY <span class="meta-string">'o'</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  USED		0x1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  IS_TASK	0x2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  IS_SYSTEM	0x4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  BLOCKED	0x8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ORDER_CPU	0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ORDER_MEMORY	1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ORDER_HIGHEST	ORDER_MEMORY</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  TC_BUFFER  1024        <span class="comment">/* Size of termcap(3) buffer    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  TC_STRINGS  200        <span class="comment">/* Enough room for cm,cl,so,se  */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* name of cpu cycle types, in the order they appear in /psinfo. */</span></span><br><span class="line"><span class="comment">//cpu 周期的种类，</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cputimenames[] = &#123; <span class="string">"user"</span>, <span class="string">"ipc"</span>, <span class="string">"kernelcall"</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPUTIMENAMES (sizeof(cputimenames)/sizeof(cputimenames[0]))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPUTIME(m, i) (m &amp; (1L &lt;&lt; (i)))</span></span><br></pre></td></tr></table></figure>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *message;  <span class="comment">//用于输出当前的路径</span></span><br><span class="line"><span class="keyword">int</span> whilecnt=<span class="number">0</span>;	<span class="comment">//用于记载已输入的命令条数，为history n做准备</span></span><br><span class="line"><span class="keyword">char</span> msg[<span class="number">40</span>][<span class="number">256</span>];<span class="comment">//用于记载已输入的命令信息，为history n做准备</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nr_procs, nr_tasks;<span class="comment">//进程数和任务数</span></span><br><span class="line"><span class="keyword">int</span> nr_total;<span class="comment">//进程和任务总数</span></span><br><span class="line"><span class="keyword">int</span> order = ORDER_CPU;<span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span> blockedverbose = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *Tclr_all;</span><br><span class="line"><span class="keyword">int</span> slot=<span class="number">1</span>;	<span class="comment">//这个变量是进程结构体在数组中的位置</span></span><br></pre></td></tr></table></figure>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>在main函数中，主要是实现一个循环。</p>
<p>首先我们要定义一些参数：</p>
<p><code>wordcount</code> 即输入命令中的单词的个数</p>
<p><code>wordmatrix</code> 即一个单词数组，每一行存储一个单词，每一列头字符为<code>\0</code></p>
<p><code>buf</code> 即存放我们命令的缓冲数组。</p>
<p>首先我们需要判断系统中还有没有足够的空间来存放下我们的语句。当空间不足的时候，malloc函数会返回NULL指针，然后我们就返回 <code>malloc failed</code> 并推出shell。这里，<code>perror</code> 是C语言标准库 <code>&lt;stdio.h&gt;</code> 的一个函数，它会将一个描述性错误消息输出到<code>stderr</code> .</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> wordcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> wordmatrix[<span class="number">100</span>][<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">char</span> **arg = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="literal">NULL</span>; <span class="comment">//用户输入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">256</span>))== <span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror(<span class="string">"malloc failed"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是循环的主体。 首先我们利用<code>memset</code>函数将buf 数组初始化清零。</p>
<p>然后我们要给 <code>message</code>申请一段空间。这里，<code>message</code>是全局变量</p>
<p>，通过 <code>getcwd</code>这个函数来获取当前所在的路径并通过printf打印出来。比如说，当前我正在 <code>proj1_shell</code> 文件夹当中启动 我们的shell，如下图所示：</p>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2-shell%E7%9A%84%E5%AE%9E%E7%8E%B0/1.png"></p>
<p>然后我们需要将 message 释放掉，因为每次循环我们都会重新申请message数组，如果不将其释放会产生很多垃圾、占用我们的虚拟机空间。</p>
<p>既然下来我们就要利用<code>getOrder()</code>函数从命令行中读取命令，并将其存储在我们刚刚声明的 buf数组当中。还需要将buf数组拷贝到msg二维数组中做一个备份，当收到history n的命令后，会从这个数组中查看之前输入过的命令。</p>
<p>如果输入的是exit命令，那么就直接跳出循环。</p>
<p>然后我们对 wordmatrix 二维数组的每一行的开头都设置为<code>\0</code> (头插法),为接下来解析命令做准备。 <code>anaOrder()</code>即 analyze order的缩写，其目的就是解析buf中的命令，并将结果存入到wordmatrix数组当中去。</p>
<p>将命令全部解析完成之后，我们调用 execommand函数，也就是执行我们解析完的命令。这也是我们待会要着重分析的函数。因为所有的 内置命令、Program 命令都在这个函数中实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">256</span>);    <span class="comment">//将buf所指的空间清零</span></span><br><span class="line">        message = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">        getcwd(message, <span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"os_shell:%s # "</span>, message);</span><br><span class="line">        <span class="built_in">free</span>(message);</span><br><span class="line">        getOrder(buf);</span><br><span class="line">        <span class="built_in">strcpy</span>(msg[whilecnt],buf);<span class="comment">//whilecnt一开始默认为0</span></span><br><span class="line">        whilecnt++;</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">strcmp</span>(buf, <span class="string">"exit\n"</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            wordmatrix[i][<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        wordcount = <span class="number">0</span>;</span><br><span class="line">        anaOrder(buf, &amp;wordcount, wordmatrix);</span><br><span class="line">        exeCommand(wordcount, wordmatrix);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，当循环结束的时候，我们对buf数组进行回收。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">	<span class="keyword">if</span>(buf != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(buf);</span><br><span class="line">        buf = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="getOrder函数"><a href="#getOrder函数" class="headerlink" title="getOrder函数"></a>getOrder函数</h4><p><code>getOrder</code>函数是从命令行窗口读取我们输入的命令、并将命令存放在buf数组当中。</p>
<p>首先我们要了解我们输入的命令长什么样： 有一些单词、符号，中间用空格隔开，然后以<code>\n</code>换行符号结尾。</p>
<p>我们使用 <code>getchar()</code>函数来单字符读取命令依次存储到buf数组，buf数组最后两个符号分别是<code>\0</code>(结束符)和<code>\n</code> (换行符)。</p>
<p>如果输入的命令过长，导致计数器已经到达256了，那么就会报错并退出函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getOrder</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(cnt &lt; <span class="number">256</span> &amp;&amp; c != <span class="string">'\n'</span>)&#123;</span><br><span class="line">        buf[cnt++] = c;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    buf[cnt++]=<span class="string">'\n'</span>;</span><br><span class="line">    buf[cnt]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">256</span>)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="anaOrder函数"><a href="#anaOrder函数" class="headerlink" title="anaOrder函数"></a>anaOrder函数</h4><p>这个函数会解析buf中的命令，所谓解析，就是利用空格符，将buf中的命令一个单词一个单词的拆开，然后存放到wordmatrix当中去。</p>
<p>这个函数的整体架构是由一个双重循环组成的。大循环解析整个命令，小循环提取出命令中每一个word。</p>
<p>首先我们令 数组p和数组q都等于buf数组。</p>
<p>如果p数组一开始就是回车，说明我们什么命令都没输入或者命令已经解析完成，那么就直接跳出循环；如果命令前面字符都是空格，那么我们就从非空格字符的地方开始解析。</p>
<p>当排除了空白输入以及空格符号之后，我们令<code>q=p</code> ，计数器number等于0。然后一直读取到一个单词结束，这时候 number就等于这个单词的长度。接下来我们利用 <code>strncpy</code> 函数将p中的前number+1个字节复制到wordmatrix中属于这个单词的位置当中(*wordcount从0开始)——为什么要number+1呢？因为这时候第number+1个字符要么是<code>&#39;&#39;</code>要么是<code>&#39;\n&#39;</code> 因此也要复制进去，方便之后将最后一个字符改成<code>\0</code>结束符。</p>
<p>最后，将单词计数器wordcount加上1，然后令p等于q，相当于<strong>砍掉</strong>了一个单词。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">anaOrder</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">int</span>* wordcount, <span class="keyword">char</span> (*wordmatrix)[<span class="number">256</span>])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = buf;</span><br><span class="line">    <span class="keyword">char</span> *q = buf;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[<span class="number">0</span>] == <span class="string">'\n'</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p[<span class="number">0</span>] == <span class="string">' '</span>)&#123;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            q = p;</span><br><span class="line">            number = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((q[<span class="number">0</span>] != <span class="string">' '</span>) &amp;&amp; (q[<span class="number">0</span>] != <span class="string">'\n'</span>))&#123;</span><br><span class="line">                number++;</span><br><span class="line">                q++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">strncpy</span>(wordmatrix[*wordcount], p, number + <span class="number">1</span>);</span><br><span class="line">            wordmatrix[*wordcount][number] = <span class="string">'\0'</span>;</span><br><span class="line">            *wordcount = *wordcount + <span class="number">1</span>;</span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exeCommand函数"><a href="#exeCommand函数" class="headerlink" title="exeCommand函数"></a>exeCommand函数</h3><p>exeCommand函数是整个shell中最关键也是最复杂的函数。因代码过长，我们将其拆分成数个小部分一一分析。</p>
<h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><p>这一部分我们定义了一些变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exeCommand</span><span class="params">(<span class="keyword">int</span> wordcount, <span class="keyword">char</span> (*wordmatrix)[<span class="number">256</span>])</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;		<span class="comment">// 进程号</span></span><br><span class="line">    <span class="keyword">char</span> *file;		<span class="comment">// 文件名称</span></span><br><span class="line">    <span class="keyword">int</span> correct = <span class="number">1</span>;<span class="comment">// 格式判断标志</span></span><br><span class="line">    <span class="keyword">int</span> way = <span class="number">0</span>;	<span class="comment">// 符号分类器</span></span><br><span class="line">    <span class="keyword">int</span> status;		<span class="comment">// 程序</span></span><br><span class="line">    <span class="keyword">int</span> i;				</span><br><span class="line">    <span class="keyword">int</span> fd;				</span><br><span class="line">    <span class="keyword">char</span> *<span class="keyword">word</span>[wordcount + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">char</span> *wordnext[wordcount + <span class="number">1</span>];<span class="comment">//存放管道运算符后面的命令</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将命令取出</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; wordcount; i++)&#123;</span><br><span class="line">        <span class="keyword">word</span>[i] = (<span class="keyword">char</span> *)wordmatrix[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">word</span>[wordcount] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们通过一个循环将wordmatrix中的每个单词都复制到word指针数组当中去。并将最后一个指针设置为NULL</p>
<h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><p>如果我们命令的第一个单词为<code>cd</code> ,那么我们就看第二个word是什么。如果第二个word是NULL，说明我们的命令就是<code>cd\n</code>那就直接返回；否则我们就利用 <code>chdir</code>这个函数改变当前的目录、转到新的目录，如果返回-1就说明该目录不存在，于是我们调用perror抛出一个错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exeCommand</span><span class="params">(<span class="keyword">int</span> wordcount, <span class="keyword">char</span> (*wordmatrix)[<span class="number">256</span>])</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="keyword">word</span>[<span class="number">0</span>], <span class="string">"cd"</span>) == <span class="number">0</span>)&#123;<span class="comment">//返回0代表word[0] = "cd"</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">word</span>[<span class="number">1</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(chdir(<span class="keyword">word</span>[<span class="number">1</span>]) ==  <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">"cd"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="history-n"><a href="#history-n" class="headerlink" title="history n"></a>history n</h4><p>如果我们命令的第一个word 是 <code>history</code> ，那么我们就要显示最近执行的n条指令。 这n条命令在main函数的时候已经被存到<code>msg</code>数组当中去了，我们现在要做的就是个打印的操作。</p>
<p>比如说我输入的命令是<code>history 15</code>,那么这时候 <code>word[1]</code> 就是 <code>(char*)15</code> ,然后我们就需要将字符数组转换为整数——这里我们使用atoi函数。我们在main函数中用<code>whilecnt</code>来作为 命令的计数器, <code>whilecnt</code>的值就是当前<code>msg</code> 数组中存放的命令数量+1， 所以我们输出的5条是从 <code>whilecnt-1</code>开始计算，一直到 <code>whilecnt-6</code>结束，然后将命令依次打印输出。</p>
<p>注意，history和mytop 既可以创建一个子进程让其运行，也可以直接在父进程中运行。 但是因为我将program命令和shell内置命令放在一个 execommand函数中实现了。 如果这里不创建一个子进程，直接在父进程中运行，那么后面会出现奇奇怪怪的打印问题，因此为了安全和方便起见，我们这里也将其放到一个子进程当中去运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="keyword">word</span>[<span class="number">0</span>],<span class="string">"history"</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">char</span> *cnum = <span class="keyword">word</span>[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> num = atoi(cnum);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, num);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = whilecnt - <span class="number">1</span>; i &gt; whilecnt - num - <span class="number">1</span>; i--) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"command %d:"</span>, i);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>, msg[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2-shell%E7%9A%84%E5%AE%9E%E7%8E%B0/5.png"></p>
<h4 id="mytop"><a href="#mytop" class="headerlink" title="mytop"></a>mytop</h4><p>这个函数需要输出的东西异常的多：</p>
<ul>
<li><strong>总体内存大小、空闲内存大小、缓存大小、总体CPU使用占比</strong></li>
</ul>
<p>我们用不同的函数来实现这些信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="keyword">word</span>[<span class="number">0</span>], <span class="string">"mytop"</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> cputimemode = <span class="number">1</span>;</span><br><span class="line">        getkinfo();</span><br><span class="line">        print_memory();</span><br><span class="line">        get_procs();</span><br><span class="line">        <span class="keyword">if</span> (prev_proc == <span class="literal">NULL</span>)</span><br><span class="line">            get_procs();</span><br><span class="line">        print_procs(prev_proc, proc, cputimemode);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="print-memory"><a href="#print-memory" class="headerlink" title="print_memory();"></a>print_memory();</h5><p>这个函数就是打印出当前主存的使用情况。</p>
<p>首先我们打开 meminfo这个文件：</p>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2-shell%E7%9A%84%E5%AE%9E%E7%8E%B0/3.png"></p>
<p>我们发现这里有5个数据，依次是：页面大小、总的页数、空闲页数、最大连续页、缓存页数量</p>
<p>那么这里我们就可以以此计算总的内存、空闲内存、最大页的内存、缓存。计算公式为：$(PAGESIZE * TOTAL)/1024$</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_memory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> pagesize;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> total, <span class="built_in">free</span>, largest, cached;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">"/proc/meminfo"</span>, <span class="string">"r"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fscanf</span>(fp, <span class="string">"%u %lu %lu %lu %lu"</span>, &amp;pagesize, &amp;total, &amp;<span class="built_in">free</span>,</span><br><span class="line">               &amp;largest, &amp;cached) != <span class="number">5</span>) &#123;<span class="comment">//如果不是五个参数就说明读取失败</span></span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main memory: %ldK total, %ldK free, %ldK contig free, "</span></span><br><span class="line">           <span class="string">"%ldK cached\n"</span>,</span><br><span class="line">           (pagesize * total)/<span class="number">1024</span>, (pagesize * <span class="built_in">free</span>)/<span class="number">1024</span>,</span><br><span class="line">           (pagesize * largest)/<span class="number">1024</span>, (pagesize * cached)/<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这一步，我们可以试试看效果如何：</p>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2-shell%E7%9A%84%E5%AE%9E%E7%8E%B0/4.png"></p>
<h5 id="getkinfo"><a href="#getkinfo" class="headerlink" title="getkinfo();"></a>getkinfo();</h5><p>这个函数就是读取/proc/kinfo得到总的进程和任务数。首先我们来看看 <code>/proc/kinfo</code> 中的记载的记录：</p>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2-shell%E7%9A%84%E5%AE%9E%E7%8E%B0/2.png"></p>
<p>其中，256就代表进程数，5代表任务数量</p>
<p>然后我们将这两个数字读入。并返回  进程数与任务数量 之和。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">getkinfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">"/proc/kinfo"</span>, <span class="string">"r"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"opening "</span> _PATH_PROC <span class="string">"kinfo failed\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fscanf</span>(fp, <span class="string">"%u %u"</span>, &amp;nr_procs, &amp;nr_tasks) != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"reading from "</span> _PATH_PROC <span class="string">"kinfo failed\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    nr_total<span class="comment">/*进程和任务总数*/</span> = (<span class="keyword">int</span>) (nr_procs + nr_tasks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="get-procs"><a href="#get-procs" class="headerlink" title="get_procs();"></a>get_procs();</h5><p>这个函数的作用是将所有需要的信息放在结构数组<code>proc[]</code> 中，每个元素都是一个<strong>进程结构体</strong>。</p>
<p>首先我们在文件一开始已经定义了一个 proc 结构： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> p_flags; 										<span class="comment">//proc的类型：系统/用户</span></span><br><span class="line">    <span class="keyword">endpoint_t</span> p_endpoint;					<span class="comment">//端点，可以看做是ID</span></span><br><span class="line">    <span class="keyword">char</span> p_name[PROC_NAME_LEN+<span class="number">1</span>]; 	<span class="comment">//名字</span></span><br><span class="line">    <span class="keyword">pid_t</span> p_pid;										<span class="comment">//进程号</span></span><br><span class="line">    <span class="keyword">u64_t</span> p_cpucycles[CPUTIMENAMES];<span class="comment">//cpu周期</span></span><br><span class="line">    <span class="keyword">endpoint_t</span> p_blocked; 					<span class="comment">//阻塞状态</span></span><br><span class="line">    <span class="keyword">int</span> p_priority; 								<span class="comment">//动态优先级</span></span><br><span class="line">    <span class="keyword">time_t</span> p_user_time; 						<span class="comment">//用户时间</span></span><br><span class="line">    vir_bytes p_memory; 						<span class="comment">//内存</span></span><br><span class="line">    <span class="keyword">uid_t</span> p_effuid;									<span class="comment">//有效用户ID</span></span><br><span class="line">    <span class="keyword">int</span> p_nice; 										<span class="comment">//静态优先级</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span> = <span class="title">NULL</span>,*<span class="title">prev_proc</span> = <span class="title">NULL</span>;</span><span class="comment">//申请两个 结构数组</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_procs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">		<span class="comment">//总之，这部分就是要将两个数组proc和prev_proc 都“装满”进程</span></span><br><span class="line">    p = prev_proc;</span><br><span class="line">    prev_proc = proc;</span><br><span class="line">    proc = p;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">if</span> (proc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      	<span class="comment">//分配内存</span></span><br><span class="line">        <span class="comment">//每个进程分配一个结构体</span></span><br><span class="line">        <span class="comment">//分配nr_total个单位proc结构体内存空间,并把指针赋予proc</span></span><br><span class="line">        proc = <span class="built_in">malloc</span>(nr_total * <span class="keyword">sizeof</span>(proc[<span class="number">0</span>]));</span><br><span class="line">				<span class="comment">//如果内存申请失败，就报错</span></span><br><span class="line">        <span class="keyword">if</span> (proc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Out of memory!\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//首先将所有的proc的flag置0</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_total; i++)</span><br><span class="line">        proc[i].p_flags = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">    parse_dir();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="parse-dir"><a href="#parse-dir" class="headerlink" title="parse_dir()"></a>parse_dir()</h6><p>这个函数的作用是获取到/proc/  下的<strong>所有进程pid</strong></p>
<p>也就是获取这些文件夹的名字：</p>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2-shell%E7%9A%84%E5%AE%9E%E7%8E%B0/6.png" style="zoom: 50%;"></p>
<p>打开<code>/proc</code>文件夹之后，我们用一个循环来遍历目录及其子目录。</p>
<p>首先我们看一下 dirent结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>&#123;</span></span><br><span class="line">   	<span class="keyword">ino_t</span>          d_ino;       <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="keyword">off_t</span>          d_off;       <span class="comment">/* offset to the next dirent */</span></span><br><span class="line">    <span class="keyword">unsigned</span> short d_reclen;    <span class="comment">/* length of this record */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">char</span>  d_type;<span class="comment">/* type of file; not supported by all file system types */</span></span><br><span class="line">    <span class="keyword">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* filename */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后通过一个for循环，依次读取<code>/proc</code>目录下的子目录项，并将目录的名字转换成十进制整数。然后执行<code>parse_file()</code>操作以获取这个目录中的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_dir</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DIR *p_dir;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">p_ent</span>;</span><span class="comment">//目录项</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">end</span>;<span class="comment">//end是指向第一个不可转换的字符位置的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p_dir = opendir(<span class="string">"/proc"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"opendir on "</span> _PATH_PROC);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p_ent = readdir(p_dir); p_ent != <span class="literal">NULL</span>; p_ent = readdir(p_dir)) &#123;</span><br><span class="line">        pid = strtol(p_ent-&gt;d_name, &amp;<span class="built_in">end</span>, <span class="number">10</span>);<span class="comment">//strtol函数将字符串转换为十进制长整数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">end</span>[<span class="number">0</span>] &amp;&amp; pid != <span class="number">0</span>)</span><br><span class="line">            parse_file(pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closedir(p_dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="parse-file"><a href="#parse-file" class="headerlink" title="parse_file()"></a>parse_file()</h6><p>这个函数的作用是获取每一个进程信息，并判断信息是否可用。传入的参数是这个进程的进程号码。将有用的信息传入到一个结构数组中去，这个结构数组就是 之前声明的 *p，里面每一个元素就是每一个进程/任务。</p>
<p>这里我们要分清楚任务和进程的区别，才能在接下来中更清楚得区分他们。 首先，一个进程可能涉及到多个任务，一个任务也可对应多个进程。他们的一些信息都存放在 <code>psinfo</code>文件当中。但是，进程是表示资源分配的基本单位，又是调度运行的基本单位。为了避免重复运算，我们这里计算所有的进程，但是不计算任务。</p>
<p>首先我们设置一些变量。这些变量就是我们接下来要从进程的 <code>/psinfo</code> 读取的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_file</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> path[PATH_MAX], name[<span class="number">256</span>], type, state;<span class="comment">//路径、名字、种类、状态</span></span><br><span class="line">    <span class="keyword">int</span> version, endpt, effuid; <span class="comment">//版本、端点、有效用户ID</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> cycles_hi, cycles_lo; <span class="comment">//高周期、低周期</span></span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">sprintf</span>(path, <span class="string">"/proc/%d/psinfo"</span>, pid);<span class="comment">//将path设置为 "/proc/(pid)/psinfo"的格式</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们通过<code>fopen()</code>函数来读取(<code>&quot;r&quot;</code>)该进程的<code>/psinfo</code>文件 </p>
<p>下面两张图片分别是任务的 <code>psinfo</code> 以及 进程的 <code>psinfo</code></p>
<p> <img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2-shell%E7%9A%84%E5%AE%9E%E7%8E%B0/8.png" style="zoom: 70%;"></p>
<p>上图是一个任务，版本是0，类型为T(TASK), 端点是-5，任务名叫做 asyncm，状态是 W(WORK),我们发现在任务下面，动态优先级、嘀嗒、周期、ID都为0，  </p>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2-shell%E7%9A%84%E5%AE%9E%E7%8E%B0/7.png" style="zoom: 70%;"></p>
<p>在这个编号为107的进程中：</p>
<p>版本是 0，(第一次读取)</p>
<p>类型为U（即USER），端点是32859 (第二次读取)</p>
<p>名字叫devmand , 状态是 ‘S’, 阻塞状态为 1，动态优先级为7，滴答为 25，高周期1186，低周期4 (第三次读取)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_file</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(path, <span class="string">"r"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, &amp;version) != <span class="number">1</span>) &#123;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//判断version是否为0，如果不为0就会报错</span></span><br><span class="line">    <span class="keyword">if</span> (version != PSINFO_VERSION) &#123; <span class="comment">//0</span></span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">"procfs version mismatch!\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//读取文件中的第二个、第三个参数，分别是文件类型和端点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fscanf</span>(fp, <span class="string">" %c %d"</span>, &amp;type, &amp;endpt) != <span class="number">2</span>) &#123;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//每当读取了一个合法的任务/进程，slot就会加1</span></span><br><span class="line">    slot++;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//判断endpoint的值是否合理 在0到nr_total的范围内</span></span><br><span class="line">    <span class="keyword">if</span>(slot &lt; <span class="number">0</span> || slot &gt;= nr_total) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"top: unreasonable endpoint number %d\n"</span>, endpt);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//slot为该进程结构体在数组中的位置</span></span><br><span class="line">    p = &amp;proc[slot];<span class="comment">//把slot地址赋值给p</span></span><br><span class="line"></span><br><span class="line">  	<span class="comment">//判断这个进程的类型到底是 TASK类型还是SYSTEM类型</span></span><br><span class="line">    <span class="keyword">if</span> (type == TYPE_TASK)<span class="comment">//如果是TASK类型，数值为 'T'</span></span><br><span class="line">        p-&gt;p_flags |= IS_TASK;<span class="comment">//0b0010</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (type == TYPE_SYSTEM)<span class="comment">//如果是SYSTEM类型，数值为'S'</span></span><br><span class="line">        p-&gt;p_flags |= IS_SYSTEM;<span class="comment">//0b0100</span></span><br><span class="line">  	<span class="comment">//除了这两者之外，就是 User 类型的进程了</span></span><br><span class="line">		<span class="comment">//将endpt和pid存入结构体</span></span><br><span class="line">    p-&gt;p_endpoint = endpt;</span><br><span class="line">    p-&gt;p_pid = pid;</span><br><span class="line">		<span class="comment">//读取名字 状态 阻塞状态 动态优先级 进程时间 高周期 低周期</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fscanf</span>(fp, <span class="string">" %255s %c %d %d %lu %*u %lu %lu"</span>,</span><br><span class="line">               name, &amp;state, &amp;p-&gt;p_blocked, &amp;p-&gt;p_priority,</span><br><span class="line">               &amp;p-&gt;p_user_time, &amp;cycles_hi, &amp;cycles_lo) != <span class="number">7</span>) &#123;</span><br><span class="line"></span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//将读取到的name复制给p-&gt;name ,最多复制 sizeof(p-&gt;p_name)-1 位</span></span><br><span class="line">    <span class="built_in">strncpy</span>(p-&gt;p_name, name, <span class="keyword">sizeof</span>(p-&gt;p_name)<span class="number">-1</span>);</span><br><span class="line">  	<span class="comment">//然后将名字的最后一个字符改成0</span></span><br><span class="line">    p-&gt;p_name[<span class="keyword">sizeof</span>(p-&gt;p_name)<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//如果不是正在运行的进程，那就打一个阻塞的标志</span></span><br><span class="line">    <span class="keyword">if</span> (state != STATE_RUN)<span class="comment">//如果数值为'R',就说明这个程序在运行</span></span><br><span class="line">        p-&gt;p_flags |= BLOCKED;</span><br><span class="line">		<span class="comment">//通过和 0x1 按位或，表明已经处理完毕。</span></span><br><span class="line">    p-&gt;p_flags |= USED;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们简单查看一下 各个 task 的名字以及他们的内存，我们发现他们的端点都是负的，原因我还没搞清楚。</p>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2-shell%E7%9A%84%E5%AE%9E%E7%8E%B0/9.png"></p>
<p>我们再打印一部分的进程的信息：</p>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2-shell%E7%9A%84%E5%AE%9E%E7%8E%B0/10.png"></p>
<h5 id="print-procs"><a href="#print-procs" class="headerlink" title="print_procs()"></a>print_procs()</h5><p>首先我们在一开始定义一个结构体tp，用来存放进程结构体数组和它的嘀嗒</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tp</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">u64_t</span> ticks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数输出CPU使用时间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_procs</span><span class="params">(struct proc *proc1, struct proc *proc2, <span class="keyword">int</span> cputimemode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p, nprocs;</span><br><span class="line">    <span class="keyword">u64_t</span> systemticks = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">u64_t</span> userticks = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">u64_t</span> total_ticks = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> blockedseen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tp</span> *<span class="title">tick_procs</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="comment">//tp结构体的数组tick_procs,对所有的进程和任务(即上面读出来的nr_total)计算ticks</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tick_procs == <span class="literal">NULL</span>) &#123;<span class="comment">//如果这个数组是空的话，就要给其分配内存</span></span><br><span class="line">        tick_procs = <span class="built_in">malloc</span>(nr_total * <span class="keyword">sizeof</span>(tick_procs[<span class="number">0</span>]));</span><br><span class="line">				<span class="comment">//申请内存下不来，就报错</span></span><br><span class="line">        <span class="keyword">if</span> (tick_procs == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Out of memory!\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//总数是nr_total,对所有的进程/任务进行遍历</span></span><br><span class="line">    <span class="keyword">for</span>(p = nprocs = <span class="number">0</span>; p &lt; nr_total; p++) &#123;</span><br><span class="line">        <span class="keyword">u64_t</span> uticks;</span><br><span class="line">      <span class="comment">//如果当前进程标志不是used(代表没在parse_file中”备案“) 就continue 看下一个进程。</span></span><br><span class="line">        <span class="keyword">if</span>(!(proc2[p].p_flags &amp; USED))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//每次proc2数组都向前加一个proc单位</span></span><br><span class="line">        tick_procs[nprocs].p = proc2 + p;</span><br><span class="line">      <span class="comment">//更新实时的嘀嗒 嘀嗒=</span></span><br><span class="line">        tick_procs[nprocs].ticks = cputicks(&amp;proc1[p], &amp;proc2[p], cputimemode);</span><br><span class="line">  		total_ticks = total_ticks + cputicks(&amp;proc1[p], &amp;proc2[p], cputimemode);</span><br><span class="line"> 			<span class="comment">//判断是否为 systemtick 和 usertick</span></span><br><span class="line">        <span class="keyword">if</span>(!(proc2[p].p_flags &amp; IS_TASK)) &#123;<span class="comment">//首先排除改对象是一个任务</span></span><br><span class="line">            <span class="keyword">if</span>(proc2[p].p_flags &amp; IS_SYSTEM)</span><br><span class="line">              <span class="comment">//如果是系统进程，那么就加到 systemticks 上去</span></span><br><span class="line">                systemticks = systemticks + tick_procs[nprocs].ticks;</span><br><span class="line">          		<span class="comment">//否则就是用户进程，那么就加到 userticks 上去</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                userticks = userticks + tick_procs[nprocs].ticks;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//计数器自增1</span></span><br><span class="line">        nprocs++;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//如果所有的嘀嗒等于0，那么就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (total_ticks == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//打印user system和总占用情况</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"CPU states: %6.2f%% user, "</span>, <span class="number">100.0</span> * userticks / total_ticks);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%6.2f%% system"</span>, <span class="number">100.0</span> * systemticks / total_ticks);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%6.2f%% in total\n"</span>, <span class="number">100.0</span> * (systemticks+userticks) / total_ticks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="cputicks"><a href="#cputicks" class="headerlink" title="cputicks"></a>cputicks</h6><p>这个函数计算每个进程的运行周期</p>
<p>滴答并不是简单的结构体中的滴答，因为在写文件的时候需要更新。需要通过当前进程来和该进程一起计算</p>
<p>endp</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">u64_t</span> <span class="title">cputicks</span><span class="params">(struct proc *p1, struct proc *p2, <span class="keyword">int</span> timemode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">u64_t</span> t = <span class="number">0</span>;</span><br><span class="line">  	<span class="comment">//计算每个进程proc的滴答，通过proc和当前进程prev_proc做比较</span></span><br><span class="line">     <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; CPUTIMENAMES; i++) &#123;</span><br><span class="line">       	<span class="comment">//如果endpoint相等，则在循环中分别计算</span></span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;p_endpoint == p2-&gt;p_endpoint)</span><br><span class="line">            t = t + p2-&gt;p_cpucycles[i] - p1-&gt;p_cpucycles[i];</span><br><span class="line"> 				<span class="keyword">else</span></span><br><span class="line">            t = t + p2-&gt;p_cpucycles[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="后台、重定向、管道"><a href="#后台、重定向、管道" class="headerlink" title="后台、重定向、管道"></a>后台、重定向、管道</h4><h5 id="查看是否有-gt-gt-gt-lt-amp-符号"><a href="#查看是否有-gt-gt-gt-lt-amp-符号" class="headerlink" title="查看是否有 | ,&gt;, &gt;&gt;, &lt; , &amp; 符号"></a>查看是否有 | ,&gt;, &gt;&gt;, &lt; , &amp; 符号</h5><p>首先我们要给不同的符号打上标签：</p>
<ul>
<li>&amp; 后台符号， way = 5</li>
<li>> 输出重定向 覆盖写 ，way = 1</li>
<li>&lt; 输入重定向，way=2</li>
<li>|  管道符号， way = 3</li>
<li>>> 追加写，way=4</li>
</ul>
<h5 id="预处理1-分类"><a href="#预处理1-分类" class="headerlink" title="预处理1-分类"></a>预处理1-分类</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exeCommand</span><span class="params">(<span class="keyword">int</span> wordcount, <span class="keyword">char</span> (*wordmatrix)[<span class="number">256</span>])</span></span>&#123;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; wordcount; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncmp</span>(<span class="keyword">word</span>[i], <span class="string">"&amp;"</span>, <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            way=<span class="number">5</span>;</span><br><span class="line">            <span class="keyword">word</span>[wordcount - <span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; <span class="keyword">word</span>[i] != <span class="literal">NULL</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="keyword">word</span>[i], <span class="string">"&gt;"</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            way = <span class="number">1</span>;</span><br><span class="line">          <span class="comment">// 如果重定向符号后面没有单词了，说明重定向了个空气，那么我们将correct置0，表明格式错误</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">word</span>[i + <span class="number">1</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                correct=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="keyword">word</span>[i], <span class="string">"&gt;&gt;"</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            way = <span class="number">4</span>;</span><br><span class="line">          <span class="comment">// 如果重定向符号后面没有单词了，说明重定向了个空气，那么我们将correct置0，表明格式错误</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">word</span>[i + <span class="number">1</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                correct=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="keyword">word</span>[i], <span class="string">"&lt;"</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            way = <span class="number">2</span>;</span><br><span class="line">          	<span class="comment">// 如果第一个字符就是输入重定向，说明也重定向了个空气，置correct = 0</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                correct=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="keyword">word</span>[i], <span class="string">"|"</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            way = <span class="number">3</span>;</span><br><span class="line">          <span class="comment">// 对于管道符号，前后必须都非空，否则就管道了个空气，置correct = 0 </span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">word</span>[i+<span class="number">1</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                correct=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                correct=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//correct=0,说明命令格式不对</span></span><br><span class="line">    <span class="keyword">if</span>(correct==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"wrong format\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>格式错误时，例子如下：</p>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2-shell%E7%9A%84%E5%AE%9E%E7%8E%B0/11.png"></p>
<h5 id="预处理2-进一步"><a href="#预处理2-进一步" class="headerlink" title="预处理2-进一步"></a>预处理2-进一步</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exeCommand</span><span class="params">(<span class="keyword">int</span> wordcount, <span class="keyword">char</span> (*wordmatrix)[<span class="number">256</span>])</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	<span class="keyword">if</span>(way == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//输出重定向，这里我们将file设置成 &gt;符号 后面一个单词。也就是我们的目的地(destination)</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; <span class="keyword">word</span>[i] != <span class="literal">NULL</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="keyword">word</span>[i], <span class="string">"&gt;"</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                file = <span class="keyword">word</span>[i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">word</span>[i] = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(way == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">//输入重定向，同上，设置来源地(source)</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; <span class="keyword">word</span>[i] != <span class="literal">NULL</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="keyword">word</span>[i], <span class="string">"&lt;"</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                file = <span class="keyword">word</span>[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">word</span>[i] = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(way == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="comment">//把管道符后面的部分存入wordnext中，管道后面的部分是一个可执行的shell命令</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; <span class="keyword">word</span>[i] != <span class="literal">NULL</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="keyword">word</span>[i], <span class="string">"|"</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">word</span>[i] = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">              <span class="comment">// 将管道符号后面的命令存放到 wordnext 数组中去</span></span><br><span class="line">                <span class="keyword">for</span>(j = i + <span class="number">1</span>; <span class="keyword">word</span>[j] != <span class="literal">NULL</span>; j++)&#123;</span><br><span class="line">                    wordnext[j-i<span class="number">-1</span>] = <span class="keyword">word</span>[j];</span><br><span class="line">                &#125;</span><br><span class="line">                wordnext[j-i<span class="number">-1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">if</span>(way == <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="comment">//输出重定向的追加写，操作方式和覆盖写一样</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; <span class="keyword">word</span>[i] != <span class="literal">NULL</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="keyword">word</span>[i], <span class="string">"&gt;&gt;"</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                file = <span class="keyword">word</span>[i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">word</span>[i] = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h5><p>这里我们直接使用了 <code>execvp()</code>来执行一些  <code>ls -a -l</code> 之类的命令</p>
<h6 id="execvp"><a href="#execvp" class="headerlink" title="execvp()"></a>execvp()</h6><p>定义函数：<code>int execvp(const char *file, char * const argv []);</code></p>
<p>函数说明：execvp()会从PATH 环境变量所指的目录中查找符合参数file 的文件名, 找到后便执行该文件, 然后将第二个参数argv 传给该欲执行的文件。</p>
<h6 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h6><p>此外我们还要学习一下 open函数的使用方法: open的第一个参数是要打开的文件路径名称；第二个参数是 flag，就是以何种方式打开文件；最后一个参数是 mode，也就是说文件被新建的话，我们要为其指定权限(8进制)</p>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2-shell%E7%9A%84%E5%AE%9E%E7%8E%B0/12.png"></p>
<h6 id="dup2"><a href="#dup2" class="headerlink" title="dup2()"></a>dup2()</h6><p>dup2也是一个很有用的函数，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个函数的功能就是讲原本要打印在屏幕上的一些信息，写入到指定的文件当中去。 文件描述符的 0 1 2 分别对应着标准输入、标准输出、标准错误。</p>
<p>所以当我 <code>dup2(fd, 1)</code> 实际上是在说我将本来要输出在terminal中的信息重定向输入到fd所指向的文件当中去，在重定向输出中非常有用； 同理 <code>dup2(fd,0)</code> 就代表着本来从terminal中输入的信息重定向到 fd文件当中读入，这对重定向输入非常有用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span>(way)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="comment">//当 way=0 的时候，说明输入的命令中不含&gt; &lt; | &amp;,说明是一些 ls 之类的命令</span></span><br><span class="line">            <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!(checkCommand(<span class="keyword">word</span>[<span class="number">0</span>])))&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%s : command not found\n"</span>, <span class="keyword">word</span>[<span class="number">0</span>]);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                execvp(<span class="keyword">word</span>[<span class="number">0</span>], <span class="keyword">word</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="comment">//输入的命令中含有输出重定向符</span></span><br><span class="line">            <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>( !(checkCommand(<span class="keyword">word</span>[<span class="number">0</span>])) )&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%s : command not found\n"</span>, <span class="keyword">word</span>[<span class="number">0</span>]);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 0644 代表文件权限时 rw-r--r--, 也就是用户可读可写</span></span><br><span class="line">              <span class="comment">/*这里的操作就是：以读写的方式打开文件;</span></span><br><span class="line"><span class="comment">              如果文件已经存在就删除原有的数据;如果文件不存在就创建一个新的文件*/</span></span><br><span class="line">                fd = <span class="built_in">open</span>(file, O_RDWR|O_CREAT|O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">              <span class="comment">//打开后，我们利用dup2将输出的东西重定向到fd文件当中去</span></span><br><span class="line">                dup2(fd, <span class="number">1</span>);</span><br><span class="line">                execvp(<span class="keyword">word</span>[<span class="number">0</span>], <span class="keyword">word</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="comment">//输入的命令中含有输入重定向&lt;</span></span><br><span class="line">            <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>( !(checkCommand (<span class="keyword">word</span>[<span class="number">0</span>])) )&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%s : command not found\n"</span>, <span class="keyword">word</span>[<span class="number">0</span>]);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//用只读的方式打开文件</span></span><br><span class="line">                fd = <span class="built_in">open</span>(file, O_RDONLY);</span><br><span class="line">              <span class="comment">//重定向输入</span></span><br><span class="line">                dup2(fd, <span class="number">0</span>);</span><br><span class="line">                execvp(<span class="keyword">word</span>[<span class="number">0</span>], <span class="keyword">word</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="comment">//输入的命令中含有管道符|</span></span><br><span class="line">            <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> pid2;</span><br><span class="line">                <span class="keyword">int</span> status2;</span><br><span class="line">                <span class="keyword">int</span> fd[<span class="number">2</span>];<span class="comment">//创建一个文件索引数组，分别对应管道前后的两个文件</span></span><br><span class="line">								<span class="comment">//创建一个管道</span></span><br><span class="line">                <span class="keyword">if</span>(pipe(fd)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"pipe error\n"</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">								<span class="comment">//需要创建另外一个子进程</span></span><br><span class="line">                <span class="keyword">if</span>( (pid2 = fork()) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"fork2 error\n"</span>);</span><br><span class="line">                    <span class="keyword">return</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">              在另一个子进程中，我们将重定位输入改为管道的后面那个文件。</span></span><br><span class="line"><span class="comment">              然后我们执行管道前面那条指令，并将结果输入到后面那个文件当中去</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid2 == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>( !(checkCommand(<span class="keyword">word</span>[<span class="number">0</span>])) )&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"%s : command not found\n"</span>, <span class="keyword">word</span>[<span class="number">0</span>]);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    dup2(fd[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">                    execvp(<span class="keyword">word</span>[<span class="number">0</span>], <span class="keyword">word</span>);</span><br><span class="line">                  	<span class="comment">//不用管道之后要关闭管道文件</span></span><br><span class="line">              			<span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 父进程需要等待子进程结束</span></span><br><span class="line">                <span class="keyword">if</span>(waitpid(pid2, &amp;status2, <span class="number">0</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"wait for child process error\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//查找管道后面的指令是否可执行</span></span><br><span class="line">                <span class="keyword">if</span>( !(checkCommand(wordnext[<span class="number">0</span>])) )&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%s : command not found\n"</span>, wordnext[<span class="number">0</span>]);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//若可执行， 则将管道后面的标准输入改成前面执行的结果。</span></span><br><span class="line">                dup2(fd[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">              <span class="comment">//然后执行管道后面的指令，并在前端输出结果。</span></span><br><span class="line">                execvp (wordnext[<span class="number">0</span>], wordnext);</span><br><span class="line">              <span class="comment">//不用管道之后要关闭管道文件，否则无法回到父进程中。</span></span><br><span class="line">              	<span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">             <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>( !(checkCommand(<span class="keyword">word</span>[<span class="number">0</span>])) )&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%s : command not found\n"</span>, <span class="keyword">word</span>[<span class="number">0</span>]);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="comment">//如果是追加写符号，我们只需要将 O_TRUNC改为O_APPEND 即可，其他保持不变</span></span><br><span class="line">                fd = <span class="built_in">open</span>(file, O_RDWR|O_CREAT|O_APPEND, <span class="number">0644</span>);</span><br><span class="line">                dup2(fd, <span class="number">1</span>);</span><br><span class="line">                execvp(<span class="keyword">word</span>[<span class="number">0</span>], <span class="keyword">word</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            signal(SIGCHLD,SIG_IGN);<span class="comment">//若命令中有&amp;，表示后台执行，父进程直接返回，不等待子进程结束</span></span><br><span class="line">            <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">	              <span class="built_in">printf</span>(<span class="string">"[process id: %d]\n"</span>,pid);</span><br><span class="line">              <span class="comment">// dev/null 相当于一个垃圾桶，我们将输入和输出都移动到这个"垃圾桶"当中去</span></span><br><span class="line">                <span class="keyword">int</span> trash = <span class="built_in">open</span>(<span class="string">"/dev/null"</span>,O_RDONLY);</span><br><span class="line">                dup2(trash,<span class="number">0</span>);</span><br><span class="line">                dup2(trash,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>( !(checkCommand(<span class="keyword">word</span>[<span class="number">0</span>])) )&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%s : command not found\n"</span>, <span class="keyword">word</span>[<span class="number">0</span>]);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//然后交给后台去执行该命令</span></span><br><span class="line">                execvp(<span class="keyword">word</span>[<span class="number">0</span>],<span class="keyword">word</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//父进程等待子进程结束</span></span><br><span class="line">    <span class="keyword">if</span>(waitpid(pid, &amp;status, <span class="number">0</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"wait for child process error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="checkCommand函数"><a href="#checkCommand函数" class="headerlink" title="checkCommand函数"></a><code>checkCommand</code>函数</h5><p>这个函数的目的就是在 <code>./ ;/bin;/usr/bin</code> 这三个文件夹下查找可执行的命令文件。比如说在bin文件夹下有很多shell本来就有的命令：</p>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2-shell%E7%9A%84%E5%AE%9E%E7%8E%B0/13.png"></p>
<p>这么多的可执行的命令文件，如 ls，cat,我们的目的就是判断我们输入的命令是否是其中之一，是的话返回1，否的话返回0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkCommand</span><span class="params">(<span class="keyword">char</span> *command)</span></span>&#123;</span><br><span class="line">    DIR *dp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirp</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *path[] = &#123;<span class="string">"./"</span>, <span class="string">"/bin"</span>, <span class="string">"/usr/bin"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">		<span class="comment">//如果我输入的命令是 ./可执行文件, 那么我们就要跳过 './' 这两个字符，然后查找可执行文件</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">strncmp</span>(command, <span class="string">"./"</span>, <span class="number">2</span>) == <span class="number">0</span> )</span><br><span class="line">        command = command + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(path[i] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( (dp= opendir(path[i])) ==<span class="literal">NULL</span> )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"can not open /bin \n"</span>);</span><br><span class="line">        <span class="keyword">while</span>( (dirp = readdir(dp)) != <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 找到了就返回 1，然后交给  execvp() 函数去执行。</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dirp-&gt;d_name, command) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                closedir(dp);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        closedir(dp);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h3><p>将所有的函数、声明都放在一个文件中不易维护代码，找起来也比较麻烦。因此我们将 main.c 文件拆分成几个头文件：</p>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2-shell%E7%9A%84%E5%AE%9E%E7%8E%B0/14.png"></p>
<p>我们将一些头文件引用、宏和函数定义放到 <code>main.h</code>头文件中，把mytop中要调用的函数放到<code>mytop.h</code> 头文件中，将检查命令函数 放到<code>checkcommand.h</code> 头文件。</p>
<p>最后main.c文件只留下一个while循环，比较简洁直观。</p>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><ul>
<li><code>cd /your/path</code></li>
</ul>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2-shell%E7%9A%84%E5%AE%9E%E7%8E%B0/15.png"></p>
<ul>
<li><code>ls -a -l &gt; result.txt</code>  + <code>vi result.txt</code></li>
</ul>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2-shell%E7%9A%84%E5%AE%9E%E7%8E%B0/16.png"></p>
<ul>
<li><code>grep a &lt; result.txt</code></li>
</ul>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2-shell%E7%9A%84%E5%AE%9E%E7%8E%B0/17.png"></p>
<ul>
<li><code>ls -a -l | grep a</code></li>
</ul>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2-shell%E7%9A%84%E5%AE%9E%E7%8E%B0/18.png"></p>
<ul>
<li><code>vi result.txt &amp;</code></li>
</ul>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2-shell%E7%9A%84%E5%AE%9E%E7%8E%B0/19.png"></p>
<p>这边，对 vi 指令进行后台操作，会报错。这是因为 vim 的标准输入和输出必须在一个终端当中。将其丢到后台去执行是不对的。</p>
<ul>
<li><code>mytop</code></li>
</ul>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2-shell%E7%9A%84%E5%AE%9E%E7%8E%B0/20.png"></p>
<ul>
<li><code>history n</code></li>
</ul>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2-shell%E7%9A%84%E5%AE%9E%E7%8E%B0/21.png"></p>
<ul>
<li><code>exit</code></li>
</ul>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2-shell%E7%9A%84%E5%AE%9E%E7%8E%B0/22.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个project 的工程量很大。而且实现起来是比较困难的。因此，如何将整个project拆分成一个一个小任务就显得尤其重要。我先实现了 cd、mytop、history n 这类shell内置命令。然后再实现了 | ,\&amp; ,> ，>> 等 Program命令。</p>
<p>此外，如何调试文件也显得十分重要。为此我尝试了很多工作流，最后选择了 mac中的Terminus、Transmit软件 远程连接 windows上开的Minix虚拟机，并通过clion修改、编写代码。这样虽然比在windows上直接连接繁琐一点。但是在mac下各种安装不了虚拟机的情况下，这已经不失为一种高效的解决方法了。</p>
<h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><p>没有实现 mytop 的实时更新</p>
<p>没有实现 多重管道</p>
<p>在未来需要继续完善。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">os实验报告1-环境搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-02 21:08:24" itemprop="dateCreated datePublished" datetime="2021-03-02T21:08:24+08:00">2021-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-05-03 14:48:54" itemprop="dateModified" datetime="2021-05-03T14:48:54+08:00">2021-05-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MINIX系统的安装和环境配置"><a href="#MINIX系统的安装和环境配置" class="headerlink" title="MINIX系统的安装和环境配置"></a>MINIX系统的安装和环境配置</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>为了配置操作系统实验环境</p>
<h2 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h2><p>物理机： Windows10</p>
<p>虚拟机软件： Oracle VirtualBox</p>
<p>虚拟机： Minix 3.3</p>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="新建虚拟机"><a href="#新建虚拟机" class="headerlink" title="新建虚拟机"></a>新建虚拟机</h3><p>首先我们在VirtualBox中创建一个虚拟机</p>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1.png" style="zoom:80%;"></p>
<p>内存可以选择 512MB，磁盘选择动态分配，共10GB</p>
<p>我们在内存中将下载的Minix镜像文件添加到路劲，并点击启动。</p>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/3.png" style="zoom:80%;"></p>
<p>在login处使用  root 登录，并输入 setup 开始安装。然后我们只需要一直按enter或者输入yes就可以完成初始安装了。</p>
<p>接下来，我们使用 reboot 进行重启，并将原来的Minix镜像文件删除以防止再次安装。再次重启之后，我们就可以输入一些简单的指令，如 ls，ps来测试是否安装成功。</p>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/4.png" style="zoom:80%;"></p>
<h3 id="虚拟机环境配置"><a href="#虚拟机环境配置" class="headerlink" title="虚拟机环境配置"></a>虚拟机环境配置</h3><p>但是现在我们的虚拟机的功能显然是很少的，因为我们没有安装任何文件。因此，我们需要安装一些开发环境。</p>
<p><code>pkgin update</code>  可以在线更新仓库元数据。其中  pkgin是 Minix中下载软件的指令</p>
<p><code>pkgin install git-base</code> 在线安装git版本控制器 </p>
<p><code>pkgin install openssh</code> 在线安装SSH远程访问</p>
<p> <code>pkgin install vim</code> 在线安装VIM编辑器</p>
<p><code>pkgin install clang</code> 在线安装 clang 编译器 ， clang和gcc一样，也是一个C语言的编译器</p>
<p>GCC特性：除支持C/C++/ Objective-C/Objective-C++语言外，还是支持Java/Ada/Fortran/Go等；当前的Clang的C++支持落后于GCC；支持更多平台；更流行，广泛使用，支持完备。</p>
<p>Clang特性：编译速度快；内存占用小；兼容GCC；设计清晰简单、容易理解，易于扩展增强；基于库的模块化设计，易于IDE集成；出错提示更友好。</p>
<p><code>pkgin install binutils</code> 在线安装运行链接库，里面是一些开发、调试工具。</p>
<p>在下载开发环境的时候，我发现连接学校的无线网的速度远远高于寝室无线网的速度，具体原因我也还没搞清楚。 </p>
<h3 id="连接SSH"><a href="#连接SSH" class="headerlink" title="连接SSH"></a>连接SSH</h3><p>在关闭虚拟机后，我们在设置中将网络改成桥接网络，如下图：</p>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/5.png" style="zoom:80%;"></p>
<p>然后我们在虚拟中输入 <code>passwd</code> 来设置密码，并通过 ifconfig 来查询当前虚拟机的ip地址。</p>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/6.png"></p>
<p>然后，我们就可以在物理机上通过cmd或者其他软件用ssh来连接我们的虚拟机了。比如我用的是terminus这款软件</p>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/7.png" style="zoom:80%;"></p>
<p>在进行简单的配置之后，就完成了</p>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/8.png" style="zoom:80%;"></p>
<h3 id="编译简单的文件"><a href="#编译简单的文件" class="headerlink" title="编译简单的文件"></a>编译简单的文件</h3><p>这里我写了一个简单的 hello world ，并通过 clang 对其进行编译。运行结果如下：</p>
<p><img src="/2021/03/02/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/9.png" style="zoom:80%;"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然下载、安装虚拟机、配置虚拟机环境的思路很清晰，难度也不大。但是我还是遇到了一些困难。比如说clang软件在寝室无线网环境下下载速度非常慢。以及在学校网络下，选择桥接网络模式会导致虚拟机无法启动等。 最后我通过多次重装Minix系统解决了这个问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/" class="post-title-link" itemprop="url">HTMLandCSS基础3-印刷与图片</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-02-03 15:43:44" itemprop="dateCreated datePublished" datetime="2021-02-03T15:43:44+08:00">2021-02-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-08-21 23:00:52" itemprop="dateModified" datetime="2021-08-21T23:00:52+08:00">2021-08-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="文字与图片"><a href="#文字与图片" class="headerlink" title="文字与图片"></a>文字与图片</h1><p>$sss^y$</p>
<h2 id="Typography"><a href="#Typography" class="headerlink" title="Typography"></a>Typography</h2><h3 id="Styling-Fonts"><a href="#Styling-Fonts" class="headerlink" title="Styling Fonts"></a>Styling Fonts</h3><p>网页上的字体大体可以分成三类：<code>Serif</code>, <code>Sans-serif</code>, <code>Monospace</code></p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/1.png" style="zoom:80%;"></p>
<h4 id="Serif-衬线字体族"><a href="#Serif-衬线字体族" class="headerlink" title="Serif 衬线字体族"></a>Serif 衬线字体族</h4><ul>
<li>具有修饰过的笔画，向外展开的或者尖细的末端，或者是带有实际衬线的末端</li>
<li>一笔一划末端（两头）都带点变化装饰，比如宋体笔画末端有毛笔字的感觉</li>
<li>文字末端有差异，在小字号下仍然容易辨认。但在大字号下笔画装饰部分可能会显得模糊或带有锯齿</li>
</ul>
<h4 id="Sans-serif-无衬线字体族"><a href="#Sans-serif-无衬线字体族" class="headerlink" title="Sans-serif 无衬线字体族"></a>Sans-serif 无衬线字体族</h4><ul>
<li>具有笔画清晰的末端–带有一点或者没有向外展开的，交错笔画，或者其它装饰</li>
<li>与“衬线字体”相比，如果字号比较小，看起来就会有些难以分辨，尤其段落阅读时容易串行</li>
</ul>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/1.jpg" style="zoom:80%;"></p>
<blockquote>
<p>左侧是 Sans-serif,    右侧是serif</p>
</blockquote>
<h4 id="monospace-等宽字体族"><a href="#monospace-等宽字体族" class="headerlink" title="monospace 等宽字体族"></a>monospace 等宽字体族</h4><ul>
<li>每个字形都等宽，主要用于英文，中文方块字本来就等宽</li>
</ul>
<h4 id="font-family"><a href="#font-family" class="headerlink" title="font-family"></a>font-family</h4><p>我们可以通过设置 font-family来设置段落的字体。比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: Arial, Helvetica, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Georgia, <span class="string">"Times New Roman"</span>, Times, serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/2.png" style="zoom:80%;"></p>
<p>这里我只设置了 body的字体，<code>&lt;p&gt;</code>元素和 <code>&lt;a&gt;</code>元素都会继承其父元素也就是 body 中的字体。 然后我又特别定义了 <code>h1</code> 的字体。</p>
<h4 id="font-weight-font-style"><a href="#font-weight-font-style" class="headerlink" title="font-weight font-style"></a>font-weight font-style</h4><p>这个属性是设置字体的粗细的，可以选100-900，必须以百为单位。 默认为100也就如同第一张图。最高位900，如下图：</p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/3.png" style="zoom:80%;"></p>
<p>除了数字之外，还可以选 <code>bold</code>(大概是700), <code>bolder</code> ,<code>lighter</code> ,<code>normal</code>(大概是400)</p>
<p><code>font-style</code>属性可选 italic (也就是斜体) 或者normal</p>
<p><code>font-size</code>属性是字体的大小，可以选绝对单位或者是自动单位</p>
<p><code>color</code>属性设置字体的颜色</p>
<h3 id="Embedding-Web-Fonts"><a href="#Embedding-Web-Fonts" class="headerlink" title="Embedding Web Fonts"></a>Embedding Web Fonts</h3><p>我们可以从这些网站上下载字体，有些字体是免费的，有些字体是收费的</p>
<p><a href="https://www.fontsquirrel.com/" target="_blank" rel="noopener">https://www.fontsquirrel.com/</a></p>
<p><a href="https://www.fonts.com/" target="_blank" rel="noopener">https://www.fonts.com/</a></p>
<p><a href="http://myfonts.com/" target="_blank" rel="noopener">http://myfonts.com/</a></p>
<p>下载的字体文件有好几种格式： TTF OTF EOT WOFF WOFF2.0 。在网页上使用的时候，我们主要使用WOFF和WOFF2.0这两种格式。</p>
<p>我们下载一个免费的字体Open Sans来作为例子，下载的格式是tff。我们可以到</p>
<p><a href="https://www.fontke.com/tool/convfont/" target="_blank" rel="noopener">https://www.fontke.com/tool/convfont/</a> 这里将其转换为 WOFF/WOFF2格式。接下来我们要将这些字体应用于我们的网页。我们用下面这套模板来注册字体。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span>&#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">"opensans"</span>;</span><br><span class="line">  <span class="attribute">src</span>: 	<span class="built_in">url</span>(<span class="string">"fonts/open-sans/OpenSans-Bold.woff2"</span>) <span class="built_in">format</span>(<span class="string">"woff2"</span>)</span><br><span class="line">  		<span class="built_in">url</span>(<span class="string">"fonts/open-sans/OpenSans-Bold.woff"</span>) <span class="built_in">format</span>(<span class="string">"woff"</span>)<span class="comment">/*url中放引用地址*/</span></span><br><span class="line">  font-weight: bold;</span><br><span class="line">  <span class="attribute">font-style</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用的时候,我们需要在字体前面加上family name即可</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">font-family</span>:<span class="string">"opensans"</span>, Arial, Helvetica, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/4.png" style="zoom:80%;"></p>
<h3 id="Flash-of-Unstyled-Text"><a href="#Flash-of-Unstyled-Text" class="headerlink" title="Flash of Unstyled Text"></a>Flash of Unstyled Text</h3><p>当我们使用自己下载的字体的时候，如果浏览器的渲染速度非常慢，它可能先渲染出原来的字体，然后再渲染我们下载来的字体。这叫做 <code>Flash of Unstyled Text</code>  这对用户的体验不是很友好。</p>
<p>为了解决这个问题，我们可以设置 <code>font-display</code>属性， 默认情况下这个属性为被设置为auto，chrome的渲染模式就是先渲染一个备用字体，然后再渲染我们定制的字体。但是不同浏览器的策略也是不同的。</p>
<p>我们可以将其设置为fallback，也就是说，当经过很长时间我们的定制字体还没有被下载好的话，那么就可以使用备用字体。以免在阅读途中遭遇切换字体的烦恼。</p>
<p>如果我们将 <code>font-display</code>设置成block的话，那么在我们的定制字体没有被下载好之前，文字是没有办法显现的。但这个操作十分危险，如果字体未下载成功，那么我们将看不见这些文字。</p>
<p>最后一个 <code>font-display</code>的值未 <code>optional</code>，这是一个较好的选择。当定制的字体还没有被下载好的时候，浏览器一开始会使用备用字体，并将其保存在浏览器的缓存当中。 当我们打开子网页的时候，浏览器就会从缓存中取出字体并使用。这能让用户在未察觉的时候切换字体。</p>
<h3 id="Font-Services"><a href="#Font-Services" class="headerlink" title="Font Services"></a>Font Services</h3><p>很多字体的使用权限非常贵。因此我们可以使用一些字体库，我们只需要按月订阅就能使用很多字体。</p>
<p><a href="https://fonts.google.com/" target="_blank" rel="noopener">https://fonts.google.com/</a></p>
<p><a href="https://fonts.adobe.com/" target="_blank" rel="noopener">https://fonts.adobe.com/</a></p>
<p><a href="http://fontdeck.com/" target="_blank" rel="noopener">http://fontdeck.com/</a></p>
<p>我们以google fonts为例，讲一下怎么使用 谷歌的字体服务</p>
<p>在我们选择好字体之后，谷歌提供了 link和 @import两种方法来将字体导入到网页当中。</p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/5.png" style="zoom:80%;"></p>
<p>我们复制其提供的链接，然后在html的header中插入。链接一共有两个 <code>&lt;link&gt;</code>元素，第一个是告诉浏览器，我们的网页存在一个与<code>https://fonts.gstatic.com</code>的链接，目的是让我们尽快从字体服务网站上下载字体。</p>
<p>第二个网站是一张 stylesheet的链接。stylesheet是由谷歌生成的，里面是各种 <code>@font-face</code> 我们只管引用即可.</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preconnect"</span> <span class="attr">href</span>=<span class="string">"https://fonts.gstatic.com"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&amp;family=Roboto:wght@700&amp;display=swap"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同样的，我们只要在font-family后面写上”Open Sans” ，就能使用这个字体了</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">"Open Sans"</span>, Arial, Helvetica, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">"Roboto"</span>, Arial, Helvetica, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="System-Font-Stack"><a href="#System-Font-Stack" class="headerlink" title="System Font Stack"></a>System Font Stack</h3><p>有了这个栈，我们就能告诉浏览器对用户的电脑使用操作系统中的默认字体</p>
<p>有了这个栈有几点好处：</p>
<ol>
<li>Can boost performance，因为电脑没必要去网上下载字体了</li>
<li>避免了Flash of unstyled text</li>
<li>Native Look</li>
</ol>
<p>总之，它能带给用户更好的体验。不过不同系统的 字体栈是不一样的。如果我们要强行定义网页系统的字体栈，我们可以在<code>font-family</code>中打一个 <code>-</code>  </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: -apple-system, BlinkMacSystemFont, <span class="string">"Segoe UI"</span>, Roboto, Oxygen,</span><br><span class="line">    Ubuntu, Cantarell, <span class="string">"Open Sans"</span>, <span class="string">"Helvetica Neue"</span>, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Sizing-Fonts"><a href="#Sizing-Fonts" class="headerlink" title="Sizing Fonts"></a>Sizing Fonts</h3><p>现在我们再来谈谈 字体的大小。一般我们使用px也就是 pixel来定义字体大小。但是在不同分辨率不同机器上，对pixel的大小的定义也是不同的。如果我们在Windows机器上定义字体为20px，那在mac电脑上看起来会更小一点</p>
<p>所以我们可以使用 相对单位。使用 rem 作为单位会更好一点。也方便我们做  media queiries:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">62.5%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: -apple-system, BlinkMacSystemFont, <span class="string">"Segoe UI"</span>, Roboto, Oxygen,</span><br><span class="line">    Ubuntu, Cantarell, <span class="string">"Open Sans"</span>, <span class="string">"Helvetica Neue"</span>, sans-serif;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Georgia, <span class="string">'Times New Roman'</span>, Times, serif;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2rem</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">100%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们窗口宽度小于 768px的时候， body元素采用1.5倍的当前html字体的大小。也就是 1.5X10px =  15px；当窗口宽度大于768px的时候，只需要把 html字体放大到100% 即可，这时候，body元素中的字体大小就是 1.5X16px = 24px</p>
<p>对于不同的heading应该取多少 rem，我们可以上这个网站查询：<a href="https://type-scale.com/" target="_blank" rel="noopener">https://type-scale.com/</a></p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/6.png" style="zoom:80%;"></p>
<h3 id="Vertical-Fonts"><a href="#Vertical-Fonts" class="headerlink" title="Vertical Fonts"></a>Vertical Fonts</h3><p>我们现在有两段文字，我希望 <code>&lt;h1&gt;</code>元素的上边距长一些，离<code>&lt;p&gt;</code>元素近一些，怎么实现？</p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/7.png" style="zoom:80%;"></p>
<p>我们可以使用 <code>margin</code>这个属性</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">3rem</span> <span class="number">0</span> <span class="number">1rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四个位置不用写，因为会自动认为和第二个值一样。效果如下：</p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/8.png" style="zoom:80%;"></p>
<p>此外，还可以设置<code>line-height</code> 属性来设置行距。 但是要注意，如果同时设置 <code>font-size</code>和 <code>line-height</code> 的话，要注意 <code>font-size</code>不能设置的比 <code>line-height</code> 还要大，因为这样行和行之间就挤在一起了，非常不美观。为了解决这个问题我们可以这样写：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>去掉 <code>line-height</code> 的单位，他就表示当前字体的倍数，因此不管字体设置为多大，行距始终是1.5倍的字体大小。</p>
<h3 id="Horizontal-Spacing"><a href="#Horizontal-Spacing" class="headerlink" title="Horizontal Spacing"></a>Horizontal Spacing</h3><h4 id="letter-spacing"><a href="#letter-spacing" class="headerlink" title="letter-spacing"></a>letter-spacing</h4><p>这个属性是设置字母与字母之间的距离，比如将其设置为 1rem会发生这样的结果：</p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/9.png" style="zoom:80%;"></p>
<p>因此使用px而不是rem才是正确的选择，根据字体的不同我们可以对其进行调节。</p>
<h4 id="word-spacing"><a href="#word-spacing" class="headerlink" title="word-spacing"></a>word-spacing</h4><p>为了阅读方便，每一行所容纳的数字大概在50-70左右。 我们可以通过设置 <code>width</code>函数，用 <code>ch</code>作为单位，ch就是一行中可以写几个0。然后根据这个自动计算 单词之间的距离。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">50ch</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Formatting-Text"><a href="#Formatting-Text" class="headerlink" title="Formatting Text"></a>Formatting Text</h3><h4 id="text-align"><a href="#text-align" class="headerlink" title="text-align"></a>text-align</h4><p>这个属性规定元素中的文本的<strong>水平</strong>对齐方式。</p>
<ul>
<li>left, right,center : 把文本排列到左边(默认)/右边/中间</li>
<li>justify： 可以使文本的两端都对齐。但是这样就会导致每一行中词与词之间的间距是不同的。</li>
<li>inherit：从父元素继承 text-align的属性值</li>
</ul>
<h4 id="text-indent"><a href="#text-indent" class="headerlink" title="text-indent"></a>text-indent</h4><p>这个属性规定文本块中首行文本的缩进。常用于建立一个“标签页”效果。允许指定负值，这会产生一种“悬挂缩进”的效果，比如说</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">text-indent</span>: <span class="number">1rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/10.png" style="zoom:80%;"></p>
<h4 id="text-decoration"><a href="#text-decoration" class="headerlink" title="text-decoration"></a>text-decoration</h4><p>顾名思义，是给文本加装饰的</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">none</td>
<td style="text-align:left">默认。定义标准的文本。</td>
</tr>
<tr>
<td style="text-align:left">underline</td>
<td style="text-align:left">定义文本下的一条线。</td>
</tr>
<tr>
<td style="text-align:left">overline</td>
<td style="text-align:left">定义文本上的一条线。</td>
</tr>
<tr>
<td style="text-align:left">line-through</td>
<td style="text-align:left">定义穿过文本下的一条线。</td>
</tr>
<tr>
<td style="text-align:left">blink</td>
<td style="text-align:left">定义闪烁的文本。</td>
</tr>
<tr>
<td style="text-align:left">inherit</td>
<td style="text-align:left">规定应该从父元素继承 text-decoration 属性的值。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="text-transform"><a href="#text-transform" class="headerlink" title="text-transform"></a>text-transform</h4><p>这个属性可以调整元素中文本的大小写。如果将值设置为Capitalize，那么每个单词的第一个字母都将是大写的。</p>
<h4 id="white-space"><a href="#white-space" class="headerlink" title="white-space"></a>white-space</h4><p>规定段落中的文本不进行换行</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">normal</td>
<td style="text-align:left">默认。空白会被浏览器忽略。</td>
</tr>
<tr>
<td style="text-align:left">pre</td>
<td style="text-align:left">空白会被浏览器保留。其行为方式类似 HTML 中的<code>&lt;pre&gt;</code>标签。</td>
</tr>
<tr>
<td style="text-align:left">nowrap</td>
<td style="text-align:left">文本不会换行，文本会在在同一行上继续，直到遇到 <code>&lt;br&gt;</code> 标签为止。</td>
</tr>
<tr>
<td style="text-align:left">pre-wrap</td>
<td style="text-align:left">保留空白符序列，但是正常地进行换行。</td>
</tr>
<tr>
<td style="text-align:left">pre-line</td>
<td style="text-align:left">合并空白符序列，但是保留换行符。</td>
</tr>
<tr>
<td style="text-align:left">inherit</td>
<td style="text-align:left">规定应该从父元素继承 white-space 属性的值</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50ch</span>;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">3px</span> solid gold;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/11.png" style="zoom:80%;"></p>
<h4 id="column"><a href="#column" class="headerlink" title="column-*"></a>column-*</h4><p>如果我们要实现分栏，可以这样写：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50ch</span>;</span><br><span class="line">  <span class="attribute">column-count</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">column-gap</span>: <span class="number">1rem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/12.png" style="zoom:80%;"></p>
<p>如果我们愿意，还可以在栏和栏之间加上分割线：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">column-rule</span>: 3<span class="selector-tag">px</span> <span class="selector-tag">dotted</span> <span class="selector-id">#999</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/13.png" style="zoom:80%;"></p>
<h4 id="direction"><a href="#direction" class="headerlink" title="direction"></a>direction</h4><p>如果把这个元素设置为 rtl，那么文字就是这样的：比较符合阿拉伯人的书写习惯</p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/14.png" style="zoom:80%;"></p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/15.png"></p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/16.png"></p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/17.png"></p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/18.png"></p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/19.png"></p>
<h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h3><p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/20.png"></p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/21.png"></p>
<h1 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h1><h3 id="Image-Types-and-Formats"><a href="#Image-Types-and-Formats" class="headerlink" title="Image Types and Formats"></a>Image Types and Formats</h3><p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/22.png"></p>
<p>transparency是指照片是否支持透明背景。 jpeg格式的照片是不支持透明背景的，gif只支持256种颜色。</p>
<h3 id="Content-Images"><a href="#Content-Images" class="headerlink" title="Content Images"></a>Content Images</h3><p>我们可以在html语言中插入图片。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/meal.jpg"</span> <span class="attr">alt</span>=<span class="string">"A bowl of salmon and curry"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>src就是图片的路径，alt 是当下载图片失败的时候，我们看到的替代图片的文字。</p>
<p>当我们想要插入的图片并不需要描述时，比如一个箭头之类的装饰性图片，我们可以把alt置为空字符串，但是不要删去alt，因为这样浏览器就会将alt默认设置为这张图片的名字。</p>
<p>我们可以设置width属性来调整图片的大小，但是放得太大会导致画面失真。</p>
<h3 id="Background-Images"><a href="#Background-Images" class="headerlink" title="Background Images"></a>Background Images</h3><p>现在我们来说说背景图。我们在css中可以设置背景图。</p>
<p>首先是background属性，这个属性既可以写颜色，又可以将图片设置为背景，我们只需要将url写入即可。</p>
<p>如果不做任何修改，那么背景图就会在浏览器窗口平铺，也就是不断重复排列。因此如果我们不希望重复排列，我们可以将<code>background-repeat</code>属性设置为no-repeat.</p>
<p>接下来，我们可以通过设置<code>background-position</code> 属性来调整图片在窗口中的位置。并通过 <code>background-size</code> 来调整背景图片的大小。</p>
<p>比如这样编写css: </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"../images/bg-paper.jpg"</span>);</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/23.png"></p>
<p>不过，我们可以直接使用 cover值，效果和写两个100% 是一样的</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"../images/bg-paper.jpg"</span>);</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们用金门大桥作为背景，然后写一个<code>h1</code></p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/24.png"></p>
<p>现在我将height改成300vh，我们发现背景会随着滚轮一块滚动，而且图片也随之扩大了3倍。</p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/25.png"></p>
<p>为了固定住背景图，只让内容滚动，我们可以使用<code>background-attachment</code> ，将其设置为fixed。</p>
<p>效果如下：</p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/0.gif"></p>
<h3 id="CSS-Sprites"><a href="#CSS-Sprites" class="headerlink" title="CSS Sprites"></a>CSS Sprites</h3><p>我们可以在 <a href="http://flaticon.com/" target="_blank" rel="noopener">http://flaticon.com/</a> 网站上下载图标</p>
<p>比如:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">  &lt;img src="images/dishes.png" alt=""&gt;</span><br><span class="line">  &lt;img src="images/landing.png" alt=""&gt;</span><br><span class="line">  &lt;img src="images/rocketship.png" alt=""&gt;</span><br><span class="line">  &lt;img src="images/saturn.png" alt=""&gt;</span><br><span class="line">  &lt;img src="images/ufo.png" alt=""&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/26.png"></p>
<p>但是这样一来，浏览器加载一次就需要加载五张图片。能不能通过一种方法将五张图合并起来，但是又能在不同的地方使用单个标签，这样就使得浏览器只请求一次即可。</p>
<p>我们可以用 CSS Sprites 工具： <a href="http://cssspritestool.com/" target="_blank" rel="noopener">http://cssspritestool.com/</a></p>
<p>只需要将图片拖入，然后进行简单的设置。就可以得到一张包含五个 图标的图了。</p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/27.png"></p>
<p>我们还得到一个自动生成的css文件，教我们如何在网页中引用这些图标</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bg-rocketship</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">'css-sprite-combined.2.png'</span>) <span class="number">0px</span> -<span class="number">0px</span>;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">100px</span>;<span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">display</span>:inline-block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bg-saturn</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">'css-sprite-combined.2.png'</span>) -<span class="number">100px</span> -<span class="number">0px</span>;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">100px</span>;<span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">display</span>:inline-block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bg-ufo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">'css-sprite-combined.2.png'</span>) -<span class="number">200px</span> -<span class="number">0px</span>;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">100px</span>;<span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">display</span>:inline-block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bg-dishes</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">'css-sprite-combined.2.png'</span>) -<span class="number">300px</span> -<span class="number">0px</span>;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">100px</span>;<span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">display</span>:inline-block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bg-landing</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">'css-sprite-combined.2.png'</span>) -<span class="number">400px</span> -<span class="number">0px</span>;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">100px</span>;<span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">display</span>:inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只需要修改一下相对路径，然后将图片的class设置成图标名称，就能使用单个图标了，实际上，css做的是一个切割的动作。</p>
<p>但是这样做也有缺点。</p>
<ul>
<li>文件可能会很大</li>
<li>这样操作，不是很灵活，万一有新的图标加入会比较麻烦</li>
</ul>
<h3 id="Data-URI"><a href="#Data-URI" class="headerlink" title="Data URI"></a>Data URI</h3><p>Data URI 是另一种减少HTTP请求的优化技巧。使用这种方法，我们可以将图片直接嵌入到一个HTML文件中去。</p>
<p>我们可以借助 <a href="https://www.cssportal.com/image-to-data/" target="_blank" rel="noopener">https://www.cssportal.com/image-to-data/</a> 网站来实现。</p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/28.png"></p>
<p>当我们拖入图片后，就可以生成Data URI，在src中写入后，就能显示图片了。利用这种方法，HTTP并没有发出request请求。</p>
<p>但是，Data URI 也有问题</p>
<ul>
<li>嵌入式的代码所占的空间比之前的图片大小还要大</li>
<li>增加了HTML文件的复杂度</li>
<li>在移动端访问较慢</li>
</ul>
<h3 id="Clipping"><a href="#Clipping" class="headerlink" title="Clipping"></a>Clipping</h3><p>使用CSS，我们可以轻松将图片裁剪。</p>
<p>我们在这个网站上就能定制裁剪后的图片了。<a href="https://bennettfeely.com/clippy/" target="_blank" rel="noopener">https://bennettfeely.com/clippy/</a></p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/29.png"></p>
<p>只要将生成的CSS代码复制粘贴就能用了</p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/30.png"></p>
<h3 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h3><p>在css中，我们可以对图片使用很多种滤镜。</p>
<ul>
<li>灰度滤镜 <code>filter: grayscale();</code> 括号中可以使用百分号表示灰色的程度，默认为100%</li>
</ul>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/31.png" style="zoom:67%;"></p>
<ul>
<li>模糊效果 <code>filter: blur(3px);</code> 同样在括号中使用px来表示模糊的程度。</li>
</ul>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/32.png" style="zoom:67%;"></p>
<p>此外如果我们这样编写css，那么当鼠标移动到图片上的时候图片就会变灰变模糊</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.meal</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">3px</span>) <span class="built_in">grayscale</span>(<span class="number">70%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/1.gif"></p>
<p>我们可以在 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/filter" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/CSS/filter</a> 上找到更多的滤镜函数。</p>
<h3 id="Supporting-High-density-Screens"><a href="#Supporting-High-density-Screens" class="headerlink" title="Supporting High-density Screens"></a>Supporting High-density Screens</h3><p>我们直到，苹果在手机以及自家的显示屏上都在使用 Retiina (视网膜屏)，但是同一张照片，在iphone3(480x320)上和iphone4(960x640)上显示的位置是一样的，因此这势必会拉长同一幅照片，造成失真。我们可以通过 images元素中的 srcset属性来帮助我们在不同的显示屏上显示不同分辨率的照片。</p>
<p>首先，我们找到2388x2388分辨率的原图，然后利用Photoshop将其变为 400x400, 800x800, 1200x1200 三种分辨率的图片。分别命名为 meal.jpg/ meal@2x.jpg/ meal@3x.jpg<br>然后，我们这样编写html和css：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/meal.jpg"</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">alt</span>=<span class="string">"A bowl of salmon and curry"</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">class</span>=<span class="string">"meal"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">srcset</span>=<span class="string">"images/meal.jpg 1x,</span></span></span><br><span class="line"><span class="tag"><span class="string">       		 images/meal@2x.jpg 2x, </span></span></span><br><span class="line"><span class="tag"><span class="string">       		 images/meal@3x.jpg 3x"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.meal</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/33.png" style="zoom:67%;"></p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/34.png" style="zoom:67%;"></p>
<p>我在我4k以及1080p的屏幕上分别测试了一下，发现4k上用的是最高分辨率的meal@3x, 1080p上用的是最低分辨率meal</p>
<p>使用了这个技巧，我们就可以在不同分辨率的屏幕上展示不同大小的图片了</p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/35.png" style="zoom:67%;"></p>
<p>使用刚才的方法仍然不太方便，比如说：iPhone iPad和iMac的屏幕大小各不相同，假设他们都会选择meal@2x这张照片。</p>
<p>加入我的css写的只是400px，那图片仍然能保持一致，但是如果我的css写的是100vw，那么浏览器会拉长我们的图片，于是大屏的电脑和pad上的照片就会显得十分模糊。</p>
<p>对此，我们可以提供大小不同的三种图片，然后让浏览器根据屏幕的大小来自动选择最优图片。</p>
<p>我们可以将css清空，然后这样编写 html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/meal.jpg"</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">alt</span>=<span class="string">"A bowl of salmon and curry"</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">class</span>=<span class="string">"meal"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">srcset</span>=<span class="string">"images/meal.jpg 400w,</span></span></span><br><span class="line"><span class="tag"><span class="string">              images/meal@2x.jpg 800w,</span></span></span><br><span class="line"><span class="tag"><span class="string">              images/meal@3x.jpg 200w"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">sizes</span>=<span class="string">"(max-width:500px) 100vw,</span></span></span><br><span class="line"><span class="tag"><span class="string">            (max-width: 700px) 50vw,</span></span></span><br><span class="line"><span class="tag"><span class="string">            33vw"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果 width 小于 500px的话，那么使用第一张图片并撑满整个宽</p>
<p>如果width大于500px而小于700px的话，那么使用第二张图片，并占一半的宽</p>
<p>如果width大于700px，那么使用第三张图片并占三分之一的宽</p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/2.gif" style="zoom:150%;"></p>
<p>我们可以使用<a href="http://reponsivebreakpoints.com/" target="_blank" rel="noopener">http://reponsivebreakpoints.com/</a> 这个网站帮我们为” breakpoints “生成不同大小的照片，就不再需要我们使用photoshop 自己调了</p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/37.png" style="zoom:150%;"></p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/38.png" style="zoom:100%;"></p>
<h3 id="Using-Modern-Image-Formats"><a href="#Using-Modern-Image-Formats" class="headerlink" title="Using Modern Image Formats"></a>Using Modern Image Formats</h3><p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/41.png" style="zoom:100%;"></p>
<p><a href="https://cloudconvert.com/" target="_blank" rel="noopener">https://cloudconvert.com/</a> 这是一个很好的在线转换工具。</p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/40.png" style="zoom:100%;"></p>
<p>我们可以将之前的 JPG文件转换成 WEBP文件，会小很多，浏览器加载起来也十分方便。</p>
<p>但是，IE是不支持显示WEBP文件的，因此我们应该这样写：使用<code>&lt;picture&gt;</code> 元素</p>
<p>picture元素可以根据屏幕匹配的不同尺寸显示不同图片，如果没有匹配到或浏览器不支持 picture 属性则使用 img 元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">"image/webp"</span>  <span class="attr">src</span>=<span class="string">"images/meal.webp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">"image/jpeg"</span> <span class="attr">src</span>=<span class="string">"images/meal.jpg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/meal.jpg"</span> <span class="attr">alt</span>=<span class="string">"A bowl of salmon and curry"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Art-Directions"><a href="#Art-Directions" class="headerlink" title="Art Directions"></a>Art Directions</h3><p>接下来我们继续使用picture元素来实现一些酷炫的操作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">   &lt;<span class="selector-tag">picture</span>&gt;</span><br><span class="line">     &lt;source media="(max-width: 500px)"  srcset="images/meal-cropped.jpg"&gt;</span><br><span class="line">     &lt;source media="(min-width: 501px)" srcset="images/meal.jpg"&gt;</span><br><span class="line">     &lt;img src="images/meal.jpg" alt="A bowl of salmon and curry"&gt;</span><br><span class="line">   &lt;/picture&gt;</span><br><span class="line"> &lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>在picture中写queriemedia </p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/3.gif" style="zoom:100%;"></p>
<h3 id="Scalable-Vector-Graphic"><a href="#Scalable-Vector-Graphic" class="headerlink" title="Scalable Vector Graphic"></a>Scalable Vector Graphic</h3><p>Scalable Vector Graphic 就是可伸缩向量图形，其缩写就是SVG</p>
<p>我们可以使用  illustrator这个软件来创建SVG 文件，SVG文件小，且是永远不会失真的。 SVG也常常用于背景当中，我们可以利用 <a href="https://www.svgbackgrounds.com/" target="_blank" rel="noopener">https://www.svgbackgrounds.com/</a> 来帮助我们选择背景。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(../images/constellation.svg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Font-Icons"><a href="#Font-Icons" class="headerlink" title="Font Icons"></a>Font Icons</h3><p>我们可以使用 Icon font来打出很多标签符号。有很多符号库，比如 Font Awesome ，Ionicons， Material Design Icons等。这里以 <a href="https://fontawesome.com/" target="_blank" rel="noopener">https://fontawesome.com/</a> 为例</p>
<p>在我们注册之后，我们只需要将其提供给我们的\<script\> 元素复制到html文件当中就可了</script\></p>
<p>然后我们点击一个免费的图标，开始使用，然后复制其代码就可以了。</p>
<p>我们通过css对图标进行修改：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.icon</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">color</span>: dodgerblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/43.png" style="zoom:100%;"></p>
<h3 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h3><p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/44.png" style="zoom:100%;"></p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/45.png" style="zoom:100%;"></p>
<p> <img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/46.png" style="zoom:100%;"></p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/47.png" style="zoom:100%;"></p>
<h3 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h3><p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/48.png" style="zoom:100%;"></p>
<p><img src="/2021/02/03/HTMLandCSS%E5%9F%BA%E7%A1%803-%E5%8D%B0%E5%88%B7%E4%B8%8E%E5%9B%BE%E7%89%87/49.png" style="zoom:100%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/01/31/datalab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/31/datalab/" class="post-title-link" itemprop="url">datalab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-31 11:01:43 / Modified: 22:57:48" itemprop="dateCreated datePublished" datetime="2021-01-31T11:01:43+08:00">2021-01-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="datalab"><a href="#datalab" class="headerlink" title="datalab"></a>datalab</h1><p>这是我们做的第一个lab，题解是早就写在pdf里的，只是一直没有写成博客。现在我们来一题一题看：</p>
<h2 id="int-bitAnd-int-x-int-y"><a href="#int-bitAnd-int-x-int-y" class="headerlink" title="int bitAnd(int x,int y)"></a>int bitAnd(int x,int y)</h2><p>首先是 bitAnd，顾名思义就是按位与：全是1结果才是1，有0结果就是0.</p>
<p>因为这题只能用 <code>|</code>和 <code>~</code> ，</p>
<p>比如说两个数都是1，那么取反后他们都是0，或一下再取反后就为1；两个数中间有一个1有一个0，那么去反之后还是有一个1一个0，或以下为1，再取反之后为0；同理如果两个数都为0，取反之后都为1，或一下再取反则为0.</p>
<p>因此这囊括了所有情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitAnd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~(~x | ~y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="int-getByte-int-x-int-n"><a href="#int-getByte-int-x-int-n" class="headerlink" title="int getByte(int x,int n)"></a>int getByte(int x,int n)</h2><p>getByte这个函数要求我们再以十六进制计数的情况下以大端法取Byte，一个byte就是8bit，两位十六进制数。</p>
<p>首先我们先让n扩大8倍，因为一个n代表8个bit</p>
<p>然后我们让x右移n位，比如说n等于0就不移动，n=1时右移8位，n=2的时候右移16位，这样就能保证得到的数的倒数后8位(2进制形式)就是我们想要取得的byte</p>
<p>然后我们让其和 0xff 按位与。就能获得最后的答案</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * getByte - Extract byte n from word x</span></span><br><span class="line"><span class="comment"> *   Bytes numbered from 0 (LSB) to 3 (MSB)</span></span><br><span class="line"><span class="comment"> *   Examples: getByte(0x12345678,1) = 0x56</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 6</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getByte</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  n = n &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  x = x &gt;&gt; n;</span><br><span class="line">  x = x &amp; <span class="number">0xff</span>; <span class="comment">// 取最后两位</span></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="int-logicalShift-int-x-int-n"><a href="#int-logicalShift-int-x-int-n" class="headerlink" title="int logicalShift(int x, int n)"></a>int logicalShift(int x, int n)</h2><p>这是让我们实现逻辑右移，也就是向右移动k位，数字丢弃最高的k位，并在左端补上k个0. </p>
<p>但是我们知道，这不是unsigned而是int类型的，直接使用右移符号使用的是算术右移。因此我们要创造出一个mask，长这样 <code>0x0...0f...f</code> (n个0，32-n个1) 的掩码。</p>
<p>首先我们要获得 32-n这个数，因为直接用减号是非法的，我们可以用反码+1的方式取得n的负数然后再加上32. 在制作掩码的时候，如下图所示：</p>
<p><img src="/2021/01/31/datalab/1.jpg" style="zoom: 80%;"></p>
<p>但是还有一种情况需要我们考虑，也就是当n=31, cnt=0 的时候，按理说我们应该得到的掩码是11….1(32个1),但是按照 <code>(1&lt;&lt;cntn)+(~0)</code> 的计算方法得到的却是 000…000(32个0),为了避免这种情况的发生，我们可以在后面再加一个 <code>(((~(!n)) + 1))</code>,这样当n=0的时候，这个式子的值就是 <code>1....1</code>; 而当n不等于0的时候，这个式子就等于 <code>0....0</code>，对最终结果是没有影响的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalShift - shift x to the right by n, using a logical shift</span></span><br><span class="line"><span class="comment"> *   Can assume that 0 &lt;= n &lt;= 31</span></span><br><span class="line"><span class="comment"> *   Examples: logicalShift(0x87654321,4) = 0x08765432</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 20</span></span><br><span class="line"><span class="comment"> *   Rating: 3 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalShift</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> cntn = <span class="number">32</span> + ((~n) + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> temp = (<span class="number">1</span> &lt;&lt; cntn) + (~<span class="number">0</span>) + (((~(!n)) + <span class="number">1</span>)); <span class="comment">//1右移32位相当于1没移动</span></span><br><span class="line">  <span class="keyword">return</span> (x &gt;&gt; n) &amp; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="int-bitCount-int-x"><a href="#int-bitCount-int-x" class="headerlink" title="int bitCount(int x)"></a>int bitCount(int x)</h2><p>这题的难度比较高，用语言比较难解释清楚。</p>
<p>首先我们要理解一个比特串中1的个数可以通过什么来计算？</p>
<p><img src="/2021/01/31/datalab/1.png" style="zoom:80%;"></p>
<p>看懂了这张图就可以打开思路，一开始我们可以计算奇数位上的1个数和偶数位上的1的个数，得到一个新的比特串，再求两位中1的个数，4位中1的个数，最后求32位中1的个数。如下图所示：</p>
<p><img src="/2021/01/31/datalab/2.png" style="zoom:80%;"></p>
<p>那么我们怎么来根据这个原理来制作掩码呢？</p>
<p><img src="/2021/01/31/datalab/3.png" style="zoom:80%;"></p>
<p><img src="/2021/01/31/datalab/4.png" style="zoom:80%;"></p>
<p><img src="/2021/01/31/datalab/5.png" style="zoom:80%;"></p>
<p>根据上面这样的计算步骤，扩展到32位，我们需要做5个掩码，分别是</p>
<p><code>010101....01</code>, <code>00110011...0011</code>,<code>00001111000011110000111100001111</code>，<code>00000000111111110000000011111111</code>, <code>11111111111111111111111111111111</code></p>
<p>因为我们不能直接使用十六进制来表现这些数，所以我们需要一些帮助比如： 0x55左移；0x33左移；0x0f左移，0xff左移</p>
<p>最后我们利用这些掩码和数字按位与并相加，最终得到比特串中1的个数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bitCount - returns count of number of 1's in word</span></span><br><span class="line"><span class="comment"> *   Examples: bitCount(5) = 2, bitCount(7) = 3</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 40</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> tempmask = (<span class="number">0x55</span>) | (<span class="number">0x55</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">int</span> mask1 = (tempmask) | (tempmask &lt;&lt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> tempmask2 = (<span class="number">0x33</span>) | (<span class="number">0x33</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">int</span> mask2 = (tempmask2) | (tempmask2 &lt;&lt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> tempmask3 = (<span class="number">0x0f</span>) | (<span class="number">0x0f</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">int</span> mask3 = (tempmask3) | (tempmask3 &lt;&lt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> mask4 = (<span class="number">0xff</span>) | (<span class="number">0xff</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> mask5 = (<span class="number">0xff</span>) | (<span class="number">0xff</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  count = (x &amp; mask1) + ((x &gt;&gt; <span class="number">1</span>) &amp; mask1);</span><br><span class="line">  count = (count &amp; mask2) + ((count &gt;&gt; <span class="number">2</span>) &amp; mask2);</span><br><span class="line">  count = (count &amp; mask3) + ((count &gt;&gt; <span class="number">4</span>) &amp; mask3);</span><br><span class="line">  count = (count &amp; mask4) + ((count &gt;&gt; <span class="number">8</span>) &amp; mask4);</span><br><span class="line">  count = (count &amp; mask5) + ((count &gt;&gt; <span class="number">16</span>) &amp; mask5);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="int-bang-int-x"><a href="#int-bang-int-x" class="headerlink" title="int bang(int x)"></a>int bang(int x)</h2><p>这道题也比较简单，是计算非x的值，但是不能使用 ！</p>
<p>首先我们让x和其相反数取或来判断x是否等于0，当x不等于0的时候，temp等于1；当x等于0的时候，temp等于0</p>
<p>然后我们让temp算术右移31位，这时候若x不等于0，ans=11…11;若 x为0，ans=0</p>
<p>最后返回ans+1就是答案了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bang - Compute !x without using !</span></span><br><span class="line"><span class="comment"> *   Examples: bang(3) = 0, bang(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bang</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = x | ((~x) + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> ans = temp &gt;&gt; <span class="number">31</span>; <span class="comment">//!0为11...11;0为 00..00</span></span><br><span class="line">  <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="int-tmin-void"><a href="#int-tmin-void" class="headerlink" title="int tmin(void)"></a>int tmin(void)</h2><p>这道题也非常简单，就是求补码的最小值，我们只要得到 100….00这个数就可以了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two's complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="int-fitsBits-int-x-int-n"><a href="#int-fitsBits-int-x-int-n" class="headerlink" title="int fitsBits(int x, int n)"></a>int fitsBits(int x, int n)</h2><p>这道题要我们判断x是否能被表示为n位数的补码形式</p>
<p>有两个规律: 假设n=4只有当<code>[1xxx]</code>或<code>[0xxx]</code> 我们才能用n个二进制位来表式x，然后我就将x往右移n-1位<code>~((~n)+1)</code>，判断剩下的数字是不是<strong>全1</strong>或者<strong>全0</strong>就可以了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * fitsBits - return 1 if x can be represented as an </span></span><br><span class="line"><span class="comment"> *  n-bit, two's complement integer.</span></span><br><span class="line"><span class="comment"> *   1 &lt;= n &lt;= 32</span></span><br><span class="line"><span class="comment"> *   Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fitsBits</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = x &gt;&gt; (~((~n) + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">int</span> flag = (!temp | !(temp + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> flag; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="int-divpwr2-int-x-int-n"><a href="#int-divpwr2-int-x-int-n" class="headerlink" title="int divpwr2(int x, int n)"></a>int divpwr2(int x, int n)</h2><p>这道题要我们计算  $x/(2^n)$ 的值,只要我们了解二进制数除以$2^k$的 原理就能很好的解决。</p>
<p><img src="/2021/01/31/datalab/6.png" style="zoom:80%;"></p>
<p>这里我定义了 flag和 cnt，其中flag是判断这个二进制数是否为负数，若为负数，则为 1…1, 否则为0….0</p>
<p>cnt就是32-k个0和k个1，也就是$(1&lt;&lt;k)-1$ </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30</span></span><br><span class="line"><span class="comment"> *  Round toward zero</span></span><br><span class="line"><span class="comment"> *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divpwr2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> flag = x &gt;&gt; <span class="number">31</span>; <span class="comment">//负数的话为 0xFFFFF否则为0</span></span><br><span class="line">  <span class="comment">//要构造 2^k-1; 也就是 32-k个0和k个1</span></span><br><span class="line">  <span class="keyword">int</span> cnt = ~((~<span class="number">0</span>) &lt;&lt; n);</span><br><span class="line">  <span class="keyword">return</span> (x + (flag &amp; cnt)) &gt;&gt; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="int-negate-int-x"><a href="#int-negate-int-x" class="headerlink" title="int negate(int x)"></a>int negate(int x)</h2><p>负数就是反码+1,这个题不用过多解释。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *X   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (~x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="int-isPositive-int-x"><a href="#int-isPositive-int-x" class="headerlink" title="int isPositive(int x)"></a>int isPositive(int x)</h2><p>这道题要我们判断x是否为正数，注意，0和负数都要返回0</p>
<p>首先我们判断这个数是负数还是非负数，若为负数，则返回1；否则返回0</p>
<p>然后我们还要判断这个数是不是等于0</p>
<p>最后将他们的按位或后的结果取反就是答案</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isPositive - return 1 if x &gt; 0, return 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Example: isPositive(-1) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 8</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPositive</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> flag = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">  <span class="keyword">int</span> ifzero = !x;</span><br><span class="line">  <span class="keyword">return</span> !(flag^ifzero);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="int-isLessOrEqual-int-x-int-y"><a href="#int-isLessOrEqual-int-x-int-y" class="headerlink" title="int isLessOrEqual(int x, int y)"></a>int isLessOrEqual(int x, int y)</h2><p>这道题说 如果 $x&lt;= y$ 就返回1，否则就返回0</p>
<p>这是有符号数，存在向上向下溢出的情况，我们必须考虑到所有情况。</p>
<p>第一种：x，y同号，且y-x 大于等于0</p>
<p>第二种：x,y 异号，只可能是 x小于0而y大于0</p>
<p>signx和signy是判断x，y是否小于0的，如果小于0，就为1；</p>
<p>samesignflag判断x和y是否同号，若同号则为1，若异号则为0；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> signx = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">  <span class="keyword">int</span> signy = (y &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">  <span class="keyword">int</span> Samesignflag = !(signx ^ signy);</span><br><span class="line">  <span class="keyword">int</span> positiveflag = !(((~x) + <span class="number">1</span> + y) &gt;&gt; <span class="number">31</span>);</span><br><span class="line">  <span class="comment">//要么同号相减大于0，要么异号 x小于0</span></span><br><span class="line">  <span class="keyword">return</span> (Samesignflag &amp; positiveflag) | ((!Samesignflag) &amp; signx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="int-ilog2-int-x"><a href="#int-ilog2-int-x" class="headerlink" title="int ilog2(int x)"></a>int ilog2(int x)</h2><p>想法是二分的思想，公式$log(x)=16<em>a+8</em>b+4<em>c+2</em>d+e$。那么count=abcde。因为x长32位，首先我们先将<code>x&gt;&gt;16</code>，判断<strong>高16位</strong>是不是还&gt;0，如果&gt;0，<code>!(x&gt;&gt;16)</code>就是0，我们要将他转换到a的位置就是将<code>! !(x&gt;&gt;16)</code>再次取非是1，然后<code>&lt;&lt;4</code>，到a的位置，就说明这个数大于16，1肯定在高16位处，然后在接着将高位折半到8位，就是<code>&gt;&gt;8+16</code>，看看高8位是不是也是<code>&gt;0</code>。这样一步步下去就是答案了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ilog2 - return floor(log base 2 of x), where x &gt; 0</span></span><br><span class="line"><span class="comment"> *   Example: ilog2(16) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 90</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ilog2</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  count = (!!(x &gt;&gt; <span class="number">16</span>)) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">  count = count + ((!!(x &gt;&gt; (<span class="number">8</span> + count))) &lt;&lt; <span class="number">3</span>);</span><br><span class="line">  count = count + ((!!(x &gt;&gt; (<span class="number">4</span> + count))) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">  count = count + ((!!(x &gt;&gt; (<span class="number">2</span> + count))) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  count = count + ((!!(x &gt;&gt; (<span class="number">1</span> + count))) &lt;&lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="unsigned-float-neg-unsigned-uf"><a href="#unsigned-float-neg-unsigned-uf" class="headerlink" title="unsigned float_neg(unsigned uf)"></a>unsigned float_neg(unsigned uf)</h2><p><img src="/2021/01/31/datalab/7.png" style="zoom:80%;"></p>
<p>float-neg就是让我们求出浮点数的负数,我们知道浮点数 s,exp,frac 字段分别为 1 位， k=8 位和 n=23 位</p>
<p>给定一个浮点数,我们首先让temp=浮点数左移1位,这样开头8位就都是 exp字段了.</p>
<p>然后,我们必须去除掉NaN的情况,也就是 exp等于<code>11111111</code>,而后面的 frac字段不为零. 因此我们先让 <code>wu&amp;tmp</code>是否等于wu,若相等,则位denormalized情况,然后再判断 <code>temp!=wu</code> 如果不等于,就是 NaN;如果等于,就是 Infinity的情况.如果是无穷的,那和普通的浮点数一样只要改变一下符号就可以了,如果是NaN就不用改, 直接返回NaN</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_neg - Return bit-level equivalent of expression -f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representations of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_neg</span><span class="params">(<span class="keyword">unsigned</span> uf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> x = <span class="number">0x80000000</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> wu = <span class="number">0xFF000000</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> tmp = uf &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ((wu &amp; tmp) == wu) <span class="comment">//FF后面不为0则为NaN</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (tmp != wu)</span><br><span class="line">      <span class="keyword">return</span> uf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> uf ^ x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="unsigned-float-i2f-int-x"><a href="#unsigned-float-i2f-int-x" class="headerlink" title="unsigned float_i2f(int x)"></a>unsigned float_i2f(int x)</h2><p>这个函数要我们将一个有符号数x转换成浮点数的格式</p>
<p>浮点数的总共由3个部分组成,s,exp和frac</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_i2f - Return bit-level equivalent of expression (float) x</span></span><br><span class="line"><span class="comment"> *   Result is returned as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_i2f</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> ans;</span><br><span class="line">  <span class="keyword">int</span> tmpx = x;</span><br><span class="line">  <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> delta = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> E = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//如果x等于0,那么就直接返回 x</span></span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  <span class="comment">//如果x是最小值,即-2^31,那么 1 10011111 000..0 e=159,E=32,f=0,M=1</span></span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">0x80000000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xcf000000</span>;</span><br><span class="line"></span><br><span class="line">  ans = x &amp; <span class="number">0x80000000</span>; <span class="comment">//固定第一位,符号位</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ans)</span><br><span class="line">    tmpx = -x; <span class="comment">//若x是负数,那么tempx取x的相反数(为正)</span></span><br><span class="line"><span class="comment">//为了构造小数字段,我们先舍去1,然后再尾巴上补0,一直补到23位为止</span></span><br><span class="line">  <span class="keyword">while</span> ((tmpx &gt;&gt; E))<span class="comment">//计算得到tmpx总共有几位</span></span><br><span class="line">    E++;</span><br><span class="line">  E = E - <span class="number">1</span>;</span><br><span class="line">   <span class="comment">//以12345为例,现在二进制表达为 11000000111001,E=13, </span></span><br><span class="line">  tmpx = tmpx &lt;&lt; (<span class="number">31</span> - E);         <span class="comment">//  然后tmpx左移18位,现在tmpx一共31位</span></span><br><span class="line">    <span class="comment">//tmpx = 11000000111001 000000000000000000</span></span><br><span class="line">  tail = (tmpx &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x007FFFFF</span>; <span class="comment">//将tmpx右移8位,给阶码空出位置,现在tail为</span></span><br><span class="line">    <span class="comment">//10000001110010000000000</span></span><br><span class="line">  f = tmpx &amp; <span class="number">0xff</span>;</span><br><span class="line">  <span class="comment">//向偶数舍入</span></span><br><span class="line">  delta = (f &gt; <span class="number">128</span>) || ((f == <span class="number">128</span>) &amp;&amp; (tail &amp; <span class="number">1</span>));</span><br><span class="line">  tail += delta;</span><br><span class="line"></span><br><span class="line">  E = E + <span class="number">127</span>; <span class="comment">// 计算阶码,E=e+偏移量</span></span><br><span class="line">	</span><br><span class="line">  <span class="comment">//如果frac段大于23位了,那么就要在exp段加一个1,表示进一位,同时舍去最高位</span></span><br><span class="line">  <span class="keyword">if</span> (tail &gt;&gt; <span class="number">23</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    tail = tail &amp; <span class="number">0x007FFFFF</span>;</span><br><span class="line">    E += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ans = ans | E &lt;&lt; <span class="number">23</span> | tail;<span class="comment">//将这三段合并,得到最终的答案</span></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="unsigned-float-twice-unsigned-uf"><a href="#unsigned-float-twice-unsigned-uf" class="headerlink" title="unsigned float_twice(unsigned uf)"></a>unsigned float_twice(unsigned uf)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_twice - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_twice</span><span class="params">(<span class="keyword">unsigned</span> uf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//把浮点数拆成 s(1位)E(8位)M(23位),利用掩码分别取出</span></span><br><span class="line">  <span class="keyword">int</span> Smask = uf&amp;<span class="number">0x80000000</span>;</span><br><span class="line">  <span class="keyword">int</span> Emask = uf&amp;<span class="number">0x7f800000</span>;</span><br><span class="line">  <span class="keyword">int</span> Mmask = uf&amp;<span class="number">0x007fffff</span>;</span><br><span class="line">  <span class="keyword">int</span> E_infty = <span class="number">0xff000000</span>;</span><br><span class="line">  <span class="keyword">int</span> tempuf = uf&lt;&lt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> ans =uf;</span><br><span class="line">    <span class="comment">//首先要排除NaN的情况,如果uf是NaN,就返回uf</span></span><br><span class="line">  <span class="keyword">if</span>((tempuf&amp;E_infty)==E_infty)</span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">	<span class="comment">//如果 exp这段不为0,那么就在exp这段加上1</span></span><br><span class="line">  <span class="keyword">if</span>(Emask!=<span class="number">0</span>)</span><br><span class="line">    ans = Smask+Mmask+Emask+<span class="number">0x00800000</span>;</span><br><span class="line">   <span class="comment">//如果exp这段为0,说明是 denormalized,我们只需要将Mmask左移一位就可以了</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(Mmask!=<span class="number">0</span>)</span><br><span class="line">    ans = Smask+Emask+(Mmask&lt;&lt;<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">439</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    

  

</body>
</html>
